= Introduction

These are notes taken when exploring the different options we might have when 
hosting NuGet packages (.NET).

== Options

Depending on the use case, the team, the organization, we might have to start
abstracting classes/assemblies into re-usable libraries that can be shared amongst
teams, amongst the company with ease.

We all (.NET programmers) are already used to hearing the term `Nuget` which is
just another alias for a **library**. Most of the time, we get all the packages we
need from a "free" and already configured repository (https://api.nuget.org/v3/index.json[LINK]).

It's however that sometimes we might have internal assemblies we might want to
redistribute privately, may it be for security/privacy concerns or by company
policy, or simply because it would be way easier to have our _own Nuget repository_
to which we can drop any NuGet we might want and then for anyone with access to
said repository to simply look for it, and **install it**.

With this background in mind there are many options that we will be exploring
today:

- NuGet.Server (tldr; Don't)
- BaGet
- Nexus OSS
- Artifactory
- Azure/GitHub

== NuGet.Server

Basically, there's a NuGet that helps us setting up a server really easily.

[NOTE]
====
SIKE! This is complete hype. `NuGet.Server` is actually an old implementation that
was for **.NET Framework**. The old man that should be retired by now but software
entropy allows him to still live through life support.
====

This package is for the old .NET, it would typically run under `IIS`. And, well,
please, let's move forward, if you have to work on Framework _maybe_ this is a good
idea, but the repo will not focus on old tech. (_Unless something specific is needed_).

== BaGet

This is an open-source, _modern_ take in what would `NuGet.Server` would've become,
had Microsoft actually focused on the community before.

Anyway, there are 2 ways of setting up BaGet, the easier one is with `docker`,
plug-and-play type of thing. The second one is by setting up a project yourself
that you can then publish and host.

=== Docker

Plug-and-play:

````
docker run -d \
  --name baget \
  -p 5555:80 \
  -v $(pwd)/baget-data:/var/baget \
  loicsharma/baget
````
- Running a container with the `baget` name
- We are binding the container's `5555` port to out host's `80` port
- We are binding a local path at the container to our host's `/var/baget` path
- We are pulling the baget image from Docker hub

This will store all the nuget packages in hour host's `/var/baget`. This is but
an example, you can obviously set another directory to persist the packages.

[NOTE]
====
As you know. Linux is _convention_ driven, and the `/var/` directory has a clear
intent and purpose: **store variable data files that change frequently during the
system's operation (logs, temp files, spool files)
====

If you head to `localhost` on the browser you should see a pretty looking `NuGet`
interface. Let's now run a couple of test to see how to use this tool.

_Extra:_ The feed, would actually be under `http://localhost:5555/v3/index.json`.

==== Pushing a package

We will setup one library class project that will start pushing its releases to
our BaGet server.

**EXTRA:** And so, even in here you have options, _oh so many options_. But it's nice
that you get them, since it means that the teams designing these tools have seen
all sorts of situations and issues, and created solutions for them:

[IMPORTANT]
====
When talking about `NuGet`. We need to understand a **feed**, which in short is just
a URL to a NuGet server. We can have many of them besides the _official_ one. These
feeds can be added in different scopes
====

This small table showcases how we can setup feeds:

| Scope    | File Location                 | Affects                    | Best For             |
| -------- | ----------------------------- | -------------------------- | -------------------- |
| Global   | `~/.nuget/NuGet/NuGet.Config` | All projects for that user | Convenience          |
| Solution | `./NuGet.config`              | Projects in that solution  | Team setup           |
| Project  | Inside project folder         | That project only          | Fine-grained control |

For a `private` repo, I'd assume your setup, constraints and conditions are fairly
specific, if everything is behind a firewall and away from prying eyes, you can
get away with extra things. Still, we want to keep things really fine grained, specially
since our repository is a solution hosting different projects and artifacts that
DEMO the different options we have for NuGet repositories.

And so, in order to setup a quick and easy demo I did this:

- Created a Class Library
- Executed `dotnet new nugetconfig` in said library's directory
- Created a Web API project
- Executed `dotnet new nugetconfig` in said library's directory
- Added in the `nuget.config` file the feed for our local server:
+
````
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <!--To inherit the global NuGet package sources remove the <clear/> line below -->
    <clear />
    <add key="nuget" value="https://api.nuget.org/v3/index.json" />
    <add key="BaGet" value="http://localhost:5555/v3/index.json" />
  </packageSources>
</configuration>

````

[IMPORTANT]
====
By default, NuGet enforces the usage of `https` and that's definitely an extra layer
we can go through _if we wanted to_. Since we don't really have any sort of requirement
to push us towards researching how to setup a secure NuGet repo and also consuming it
we will not use that.
====

So when trying to consume an `http` feed, we will get an error:
https://learn.microsoft.com/en-us/nuget/reference/errors-and-warnings/nu1302[NuGet requires HTTPS sources]
in order to get around it you can just mark the feed as "secured":

````
<add key="BaGet" value="http://localhost:5555/v3/index.json" allowInsecureConnections="true"/>
````

After this you can head down do your library project and just run:

- `dotnet pack`
  - If you were to look into the folders you will notice that this generates under
  `/Release` a `.nupkg` file. This is the "executable" that we can then push to
  a NuGet repo
- `dotnet nuget push ./bin/Release/Wan.SelfNuGets.BaGet.TestLibrary.1.0.0.nupkg -s http://localhost:5555/v3/index.json`
  - **IMPORTANT:** You should be pushing to the same URL that is used to retrieve
  NuGet packages. Don't listen to some tutorials that list `/nuget` or something.

After you have effectively pushed your NuGet, you can head down to the BaGet's
portal and check if your package is now being listed. _It should_.

[NOTE]
====
If you want to start consuming "non-Https" repos. In an IDE such as Rider, you have
to do some "manual stuff". And that is. When looking at the `Sources`. Rider will inded
pick up on the configurations you have. **BUT ONLY IF YOU HAVE A `nuget.config` file
at a _Solution Level_. (Is this perhaps to enforce a good practice?). So anyways.
Depending on the setup, you can indeed have a `nuget.config` file at a project level,
but if you wanna consume things normally, you should at the very least setup one
file at a solution level.
====

_Rider specific hack:_ Even then, our BaGet source won't be listed by default, and
we won't be able to install it in the project we want unless:

. We select under Rider's Sources (in NuGet)
. Select the detected Solution level `nuget.config`
. To the right mark the next empty item's (after the official NuGet) "Allow Insecure"
. After this `BaGet` will pop into existence, and we will be able to search for the
NuGet packages that our local repo provides
. We will also be able to install our pushed package normally

==== Versioning packages and automation

**Nomenclature:**

The first thing you need to know is that the universally accepted standard for
.NET libraries is **Semantic Versioning (SemVer)**. The format is `MAJOR.MINOR.PATCH`.

- **MAJOR (x.0.0):** Increment when you make **incompatible API changes**. If
consumers of your library need to change their code to update, that is a major
bump.
- **MINOR (1.y.0):** Increment when you add **backwards-compatibility functionality.**
New features, but no breaking changes.
- **PATCH (1.0.Z):** Increment when you make **backwards compatible bug fixes**.

For pre-release versions, you add a suffix `-alpha`, `-beta`, `-rc1` (Release Candidate).
E.g., `1.2.0-beta.1`.

**NuGet - Dotnet:**

. We have to leverage the `<Version>` property in our project's `.csproj` file. This
allows us to tag a specific release build. Avoid old `AssemblyInfo.cs` attributes
for versioning a NuGet package.
. **Be strict with dependencies:** If a library depends on another package, specify
a range, not a fixed version, unless there's a good reason (e.g., `[1.0, 2.0)`, means
`>=1.0.0 and <2.0.0`)
. **Version everything:** Every build that could be consumed should have a unique
version. Avoid pushing the same version twice to the feed (this can cause caching
issues)

**Automating:**

We will go a bit _overkill_ but I think it's good to know about **tools** we can
**_leverage_** to make our lives easier and avoid annoying menial tasks so we
focus more on **VALUE**.

- Step 1: Install GitVersion `dotnet tool install -g GitVersion.Tool`
- Step 2: Create a `GitVersion.yml` **config file** in the repo root. A simple
starting point is simply: `next-version: 1.0.0`

- Step 3. And now, we don't want to be running manually all of this, like. WHAT?
Leverage scripting. (I am running Linux), so we should create something like:

[source, bash]
----
#!/bin/bash

# Configuration
PROJECT_PATH="./Wan.SelfNuGets.BaGet.TestLibrary.csproj" <.>
NUGET_SOURCE="http://localhost:5555/v3/index.json"
# API_KEY="your-api-key"
# We are not configuring security for now

# Calculate the next semantic version using GitVersion
echo "Calculating version using GitVersion..."
VERSION_INFO=$(dotnet-gitversion /output json /showvariable SemVer) <.>
# For a pre-release version with branch name, you might use:
# VERSION_INFO=$(dotnet-gitversion /output json /showvariable NuGetVersionV2)

if [ -z "$VERSION_INFO" ]; then
    echo "Failed to calculate version."
    exit 1
fi

echo "Version to publish: $VERSION_INFO"

# Update the .csproj file with the new version.
# This uses `sed` (Linux/macOS). On Windows in Git Bash, it should also work.
sed -i "s/<Version>.*<\/Version>/<Version>$VERSION_INFO<\/Version>/g" $PROJECT_PATH <.>

echo "Updated project file to version $VERSION_INFO"

# Build, Pack, and Push
dotnet build $PROJECT_PATH -c Release --nologo
dotnet pack $PROJECT_PATH -c Release --output ./nupkgs --no-build --nologo <.>

# Find the specific .nupkg file we just created
NUPKG_FILE=$(find ./nupkgs -name "*$VERSION_INFO.nupkg" | head -n 1) <.>

if [ -z "$NUPKG_FILE" ]; then
    echo "Could not find the generated .nupkg file."
    exit 1
fi

echo "Pushing $NUPKG_FILE to $NUGET_SOURCE..."
# dotnet nuget push "$NUPKG_FILE" --source $NUGET_SOURCE --api-key $API_KEY <.>
dotnet nuget push "$NUPKG_FILE" --source $NUGET_SOURCE

echo "Done! Published $VERSION_INFO"

----
<.> This is a great pattern, remember this for scripting. You should declare all
the variables you will use at the beginning, (and of course if you are feeding things
at runtime this makes declaration and ETC factor even less since it's way easier to
spot this)
<.> The algorithm the tool uses to calculate is quite sophisticated, and we will
break down a bit of its logic after this, but just so you know that we are running
the tool to generate a `json` output, and then extracting the value of one specific
property there
<.> And this is, _I think_ the best aspect of this script, we don't have to go
and manually setup each new version by typing and and wasting time thinking of the
version. (Of course, by following the conventions explained before we can manually
go and edit the `GitVersion.yml` file to make the tool push a specific idea we have
in mind). But here, we literally edit _through the script_ our `.csproj` file.
<.> By looking at this line you should recognize the `pack` command in it. This is
what we did manually before (it pays off to do things yourself first, to then start
automating, breaking stuff apart, it also helps debugging later way easier since you've
made your homework, you went through trial-by-fire)
<.> Again, depending on **YOUR USE CASE** you can bend "rules" a bit, skipping over
an `API-KEY`, not using `https` it's all situational. Don't fret over the fact that
perhaps the _framework_ throws an error because you are doing something it doesn't like.
For testing purposes, dev environments, even integration environments (or UAT), it
all will depend on the requirements, and you **making it work**. Nothing else matters.

**How GitVersion Calculates Version Info**

Let's break down `VERSION_INFO=$(dotnet-gitversion /output json /showvariable SemVer)`

`GitVersion` basically analyzes the project's Git history and uses a sophisticated
rule system. The `SemVer` variable typically follows the pattern: `MAJOR.MINOR.PATCH-{metadata}`.

**_EXAMPLE_**

As an example, we did the whole process on the previous steps of these notes. And
I configured the next version to be `1.0.1`. **_However_**, in the end the pushed
version ended up as `1.0.0-8`.

This -8 is what's known as "commit height" or "patch increment" from the last
tagged version:

````
Initial commit/tag: 1.0.0
  │
Commit 1
  │
Commit 2
  │
...
  │
Commit 8  ← You are here → Version: 1.0.1-8
````

GitVersion thought: "We're 8 commits ahead of the last stable version, so let's
create a pre-release version with height 8."


