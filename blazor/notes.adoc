= Introduction

These are notes for different things found in the Blazor (.NET) component frontend
framework. As a starter, we will have notes on a https://www.udemy.com/course/blazor-deep-dive-from-beginner-to-advanced/[Udemy]
course.

== Blazor Deep Dive - From Beginner to Advanced in .NET 8

=== Course Content

==== NET 9 Updates

.NET 9 introduced a few changes to Blazor. These changes are minor however. One
thing worth of note though is that you should include **SSR (Server Side Rendering)**
in a Blazor app configured to use server interactivity with global location.

==== What is Blazor

TL;DR: Blazor is a **component based** SPA web application framework that achieves
interactivity with C#.

_Component based SPA web application framework:_ This differs from the traditional
web application paradigm (which is also the first one that was invented). In the
sense that we are not responding to individual pages that a server requests, and
then spits back to the client.

The user will send requests to the web server as well, however the web server will
route all requests to **ONE PAGE**. This is in theory called _the root component_,
but you can still define it as this _root page_. No matter how many requests are
sent, they will always go to one single page. The Blazor Framework will look for
different components, and it will then **place the component** inside the root
component.

A simple workflow would be:

1. A first request will go to the server, the server will then request for the
necessary components to render that path.
2. A second request will come and the server will "erase" the previous components
and render others that respond to that specific request. And so on.

Components are a powerful paradigm because you can nest components inside of other
components, effectively turning this structure as a **component tree**, the levels
and children will be mandated by requirements.

The main idea is that you should **think in components**. Blazor uses C# in order
to reach interactivity. React, Angular, Vue, etc all use **javascript**.

==== Choices of interactivity

What is _interactivity_?

E.g., If we have a page, and on this page we have a list, we want to allow users
to search on that list based on a filter, only matching results to the filter
should show up in the list. We would have a search bar, a button. In order to
add _reactivity_ or _interactivity_ normally you would start using javascript.
But in Blazor we achieve that with C#, and C# only. The main idea behind the
framework's design is to unify code as much as possible and not rely on Javascript,
(although you will be still using it in really specific edge cases).

There are different ways to implement interactivity with Blazor, the types of
interactivity are:

No interactivity (base):: This is one type, in case you don't need any sort of reactivity,
this is also called SSR (Static Server Side Rendering). In most use cases, you will
create a project with this default interactivity setting. You would only need to
add interactivity based on **requirements**.
Server Interactivity:: This will make the application to establish a SignalR channel
from server to client (this is a WebSocket implementation). This is like a P2P
communication and it needs to be sustained. In order for this channel to work,
a javascript file is created inside of the page that is being rendered on the
browser, **this is not created by a developer** but by the framework. Whenever the
user does something, the event will be handled by said javascript server and sent
to the backend server, to then make a decision. It will compare the previous state
of the page and then a newly calculated state, that difference is then sent back
to the client so that it can attach it and re-render the page on the fly. (No
reload of the whole page)
WebAssembly Interactivity:: This is based on Blazor SSR, the components that require
WASM will then get packaged with tons of extra DLLs and WASM files and sent back
to the browser. This is then leveraged by the browser in order to run the interactions.
A good point here is that WASM is way faster than javascript since it runs at almost
native speeds. There's another approach in which the whole component gets compiled
into WASM and that gets sent to the browser to then be interpreted and run. But
either way, **some kind of files will be downloaded from the server to the browser**
and these files will then be executed by the browser.

Blazor SSR = **BASE OF EVERYTHING** When Web Interactivity is required, you can
choose WASM, Server Interactivity or a hybrid model in which some "pages" and components
run on server and others on WASM.

==== Blazor SSR Project Structure

In order to start getting familiar with Blazor SSR, we will create some dummy project
and describe its components.

First of all, when creating a Blazor Web Application, starting on .NET 8 the recommended
template is simple **Blazor Web App**. There are other variations however that might
apply to specific use cases.

[IMPORTANT]
====
We will select the "Interactivity Mode" as `None`, this is the stock Server Side
Static Rendering (SSR). And it's recommended to start your project with this setting,
the other ones are _Server, WebAssembly, Auto (Hybrid)_. Many pages that you create
you will see that require no interactivity, meaning that by selecting `None` you
can add interactivity to components that actually need it.
====

After we create the project with a "Interactivity" set, it will not matter later.

**NOTE:** Just to get things straight, the entry point is `Program.cs`. The paradigm
is simple, we do a `app.Run()` and the app stays alive as if in a "for-loop" and
will pick up on any Http Request that comes in. Once a request comes in, it goes
through different functions, which are called _Middlewares_.

[source, csharp]
----
using ServerManagement.Components;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddRazorComponents();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error", createScopeForErrors: true);
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}

app.UseHttpsRedirection(); <.>


app.UseAntiforgery();

app.MapStaticAssets();
app.MapRazorComponents<App>(); <.>

app.Run();
----
<.> Something like this is a Middleware, a request that comes will pass through the
logic that's stated here and maybe get something added to it, or extracted, middlewares
are multi-purpose in nature.
<.> This is a pretty important line of code, this will map all the Http requests
to the `App` class.

If we go and analyze the `App.razor` file that should be under `Components`. We
should find something like this:

[source, razor]
----
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <base href="/"/>
    <link rel="stylesheet" href="@Assets["lib/bootstrap/dist/css/bootstrap.min.css"]"/>
    <link rel="stylesheet" href="@Assets["app.css"]"/>
    <link rel="stylesheet" href="@Assets["ServerManagement.styles.css"]"/>
    <ImportMap/>
    <link rel="icon" type="image/png" href="favicon.png"/>
    <HeadOutlet/> <.>
</head>

<body>
<Routes/> <.>
<script src="_framework/blazor.web.js"></script>
</body>

</html>
----
This isn't the only place that will have `html` code declared inside of it. The
specific notations such as `HeadOutlet` and `Routes` will later come into play
when dealing with the framework's functionalities.

[IMPORTANT]
====
The `App.cs` component/razor file, is actually the _ROOT COMPONENT_. In here we
will be rendering all the components, hence it's configured in a way such that
all Http requests are mapped to this very specific component. This is the **one page** 
of the SPA.
====

It's through `<Routes />` that then the root component can resolve/render corresponding
components that respond to different routes.

Now this component can also be read, it should be right next to the `App.razor`
file.

[source, razor]
====
<Router AppAssembly="typeof(Program).Assembly">
    <Found Context="routeData">
        <RouteView RouteData="routeData" DefaultLayout="typeof(Layout.MainLayout)"/> <.>
        <FocusOnNavigate RouteData="routeData" Selector="h1"/>
    </Found>
</Router> <.>
====
<.> A key concept here is `DefaultLayout="typeof(Layout.MainLayout)"` this notation
specifically makes it so that the component will be spat out as HTML to the browser.

And so, in short, all the routes here will respond to a specific set of components
or "screens". Depending on the route that the server got, then all the respective
**content** will be displayed/replaced on the place that holds the `<Routes />`
tag.

The `MainLayout`, so the actual code that will render HTML can also be visualized
under `Components > Layout > MainLayout.razor`. Technically all blazor components
are under `.razor` files.

[source, razor]
.MainLayout.razor
====
@inherits LayoutComponentBase

<div class="page">
    <div class="sidebar">
        <NavMenu/>
    </div>

    <main>
        <div class="top-row px-4">
            <a href="https://learn.microsoft.com/aspnet/core/" target="_blank">About</a>
        </div>

        <article class="content px-4">
            @Body <.>
        </article>
    </main>
</div>
====
<.> The `@Body` annotation/tag is a really important piece of notation to keep in
mind, it's a placeholder for **any component**, no matter what type of component
is required by the user, it will come in here and replace the placeholder.

This is the _basic, theoretical flow_:

. Request comes into `Program.cs`
. Request goes to `App.razor`
. Goes to the `Routes.razor`
. Goes to `MainLayout.razor`

And through it all, it will render and swap out placeholders and places on each
layer respectively.

If you run the application, we should see both a terminal session and a web site
on our Default Browser.

The terminal holds some bits of info that's great:

. It will tell us at which ports the Blazor App is running
. It will also tell us which is the Root Page (component)

In short, the `MainLayout.razor` site renders a side bar, and then has content
that will change based on the route. This is how it all works, if you inspect
the HTML you will see how this rings true, how the sidebar is effectively **static**.

It's however Blazor that under the scenes takes care of replacing content based
on the routes.

This is the basic SSR setup, if we want WASM interactivity we will need to add a
second project, but overall it will remain the same. Hence it's said that
`SSR is the base of everything else`.

=== Blazor SSR

==== Two Types of Components

There are two types:

Routable Components:: Also called _Page Components_. This will respond directly
to a route.
Non-Routable Components:: Also called _Reusable Components_. These are used inside
routable components, and also inside of other non-routable components.

So, let's start playing around with the components and features. Say, we want to
create a Page that will respond to a new route. We should then create a `.razor`
file inside of `Pages`. Something like `Servers.razor`. You should _technically_
always create a _Razor Component_. But it's through anotations and other things
that we establish a routable and non-routable component and so on.

If we create with the scaffold:

[source, razor]
====
@page "/Servers" <.>
<h3>Servers</h3>

@code {
    
}
====
<.> This is the single most important thing that marks a component as a `routable
component`.

After adding this new component, and reloading the web site, we can manually type
`/servers` at the URL bar, if we get something rendered (in this case a simple heading
with `Servers`), then everything is working as expected.

We will now create a non-routable component, the course's convention is creating
a folder called `Controls`. And inside adding a `.razor` file. All of the components
inside should be _non-routable_. Another convention is to always suffix these components
with `Component` e.g., `ServerComponent.razor`

Once we create this component we can add some code to it to see if it renders, and
after that we can then use this component inside of any of our pages. In this case
if we were to put it into `Servers.razor`:

[source, razor]
====
@page "/servers"
@using ServerManagement.Components.Controls <.>

<h3>Servers</h3>
<br/>
<br/>
<ServerComponent/> <.>

@code {

}
====
<.> You could just import the namespace like this, but there's a more clean and
recommended way.
<> And here you can just write the component name with this syntax (that's really
close to how React would do it, or even Angular for that matter)

The better and cleaner approach to imports is to put the namespace import under the
`_Imports.razor` component that should be at the root of the `Components` folder.
In here you woul see things such as:

[source, razor]
====
@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using static Microsoft.AspNetCore.Components.Web.RenderMode
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.JSInterop
@using ServerManagement
@using ServerManagement.Components

@using ServerManagement.Components.Controls <.>
====
<.> This import can indeed be powerful, because, if by convention we create
all re-usable components under this namespace, next time, when trying to call them
from other components or pages, we won't have to always be importing them, this
centralized the import and makes things leaner.
====

If you were to declare `<ServerComponent />` twice, then its content should be
replicated normally. This is a reusability example, _don't forget about that_.

==== Razor Syntax Implicit Razor Expression

Blazor achieves interactivity with C#, this is at the frontend level. However
at the backend we also use C#, how will that work?

So that we can start using C# code we have to leverage **Razor Syntax**

[source, razor]
====
<p>
    @status <.>
</p>

@code {
    private string status = "Server is offline"; <.>
}
====
<.> This is called _implicit syntax_ we can reference variables that are written
in C# directly on the `HTML` part.
<2> As you can see we are using C# code here to assign a value to then be rendered.

We can then concatenate both HTML and "evaluation code". `@status at @DateTime.Now`.
Whenever there's an `@` then this is actually syntax that tells Blazor that something
from C# needs to come here (and be evaluated).

[NOTE]
====
Okay, thank god that Hot Reload is a _thing_. Hopefully it's stable now in .NET
9. https://learn.microsoft.com/en-us/aspnet/core/test/hot-reload?view=aspnetcore-9.0[hopefully].
====

The course leans heavily on this process of "Apply a change, restart the server",
and that is _so slow_. The industry standard should be hot reload (React, Angular
had over Blazor a long time ago). The way to _enable_ hot reload is to simply run
the application with `dotnet watch` this will keep a demon checking for changes
on the source code files, and if it's detected then it will auto reload itself,
in case something really critical is updated it will prompt the user to please
reload manually (better than wasting time).
====

What if we wanted to leverage some class? We can then create a model (POCO) under
something like `Models`. A typical POCO with `ServerId, City, Name` perhaps.
Nothing out of the ordinary.

And then we can reference it in our component like so:

[source, csharp]
.ServerComponent.razor
----
<p>
    @server.Name is in @server.City
</p>

@code {
    private Server server = new()
    {
        Name = "Server 1",
        City = "Toronto"
    };
}
----
As you can see, we are using **implicit syntax**, and after spaces then the evaluation
stops, hence always before spaces we should reference expressions that are C#
code related. We can use the **implicit syntax** under any HTML by the way, not
just paragraphs (`<p>`). This can even be evaluated on HTML properties.

And again, we should add its namespace to the `_Imports.razor` component so that
globally any model we add we can seamlessly consume from anywhere and removing
the need to import it always.

==== Razor syntax Explicit Razor Expression

The Razor expression would be limited if we only had the implicit type, since we
can't really do anything with logic or concatenation since a **space** literally
marks it as finished. And it's due to this that an _explicit expression is necessary_.

[source, razor]
====
<p>
    @server.Name is in @server.City that is @(server.IsOnline ? "online" : "offline") <.>
</p>

@code {
    private Server server = new()
    {
        Name = "Server 1",
        City = "Toronto"
    };
}
====
<.> With the `@()` syntax you can easily write more explicit code and logic so that
some rendering is applied based on pre-existing conditions. We can use the explicit
syntax even on attributes for an html element. Any C# expression can be used inside the
`@()`.

See how explicit syntax can be so powerful that it can literally be used for conditional
rendering and styling:

[source, razor]
====
<div style="color: @(server.IsOnline ? "green" : "red")" data-name="@server.Name" data-status="@(server.IsOnline ? "online" : "offline")"> <.>
    @server.Name is in @server.City that is @(server.IsOnline ? "online" : "offline")
</div>

@code {
    private Server server = new()
    {
        Name = "Server 1",
        City = "Toronto"
    };
}
====
<.> In here under a `style` we can literally conditionally apply a color or something
alike. It's extremely powerful.

_NOTE:_ We can also use a direct object for style: `style="@($"color: {(server.IsOnline ? "green" : "red")}")"`,
the thing with this syntax though is that we can nest another "evaluation expressions"
inside of the existing @() part. So this is a great way to keep adding more complex
condition paths in the same structure.

The Razor expression syntax has tons of power when it comes to rendering things
with C# code and bound objects.

==== Create a static data repository

In order to keep exploring Blazor's capabilities we can now create a mode for
mocking data. In our case we'll use the Repository pattern to create a `ServersRepository.cs`
class.

There's nothing worth of note here, more than a simple CRUD but that's managing
a static list in memory. We won't connect to some backing service since the focus
of the whole course is Blazor, we just need a source of data.

==== Razor Syntax Output list with looping

We are going to use looping to output a list inside of a Razor component.

[source, razor]
----
@page "/servers"

<h3>Servers</h3>
<br/>
<br/>
<ul>
    @foreach (var server in servers) <.>
    {
        <li>
            @server.Name in @server.City is <.>
            <span style="color: @(server.IsOnline ? "green" : "red")"> <.>
                @(server.IsOnline ? "online" : "offline")
            </span>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
}
----
<.> Se use the `@foreach` control directive to then loop over a list and render
_repeatedly_ HTML elements as we see fit (per entry of the list).
<.> We will then have code that can easily resemble what we already saw previously
but now applied to this new "iterative logic".

==== Assignment 1: Output city buttons list

We are going to output city buttons.

The idea is to practice the `@foreach` loop syntax, the rules are as follows:

. We are going to create a city model
. We will create a city repository
. We will output the cities as lists

We will work with static lists, so under `Models > CitiesRepository.cs` we will
simply have a string list with city names.

==== Assignment 1: Answer

Under the `Servers.razor` file:

[source, razor]
----
@page "/servers"

<h3>Servers</h3>
<br/>
<br/>
<ul>
    @foreach (var city in cities)
    {
        <button type="button">@city</button> <.>
    }
</ul>
<ul>
    @foreach (var server in servers)
    {
        <li>
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
    private List<string> cities = CitiesRepository.Cities;
}
----
<.> This is something that works just fine, BUT, Blazor by default comes with
bootstrap already installed, so we can style this with `class="btn btn-primary"`.

Now, the course does really hacky stuff, in order to add a space between the buttons
it uses this interesting syntax called `<text></text>` that you can use to enclose
some special characters, I guess that's, cool? Don't really know. But we can style
components as we would without issue by creating a file like:

````
|-- Servers.razor
|-- Servers.razor.css
````

And in there we can start adding as much styling as we want to, by default Blazor
will then compile this into isolated CSS so we shouldn't class with other styles
and we will keep things lean.

[NOTE]
====
IF YOU CAN'T SEE THE STYLES GETTING APPLIED/LOADED THAT'S PROBABLY BECAUSE YOU HAVE
TO RELOAD THE WHOLE APP. This is dumb, tbh, the hot reload doesn't pick up on
styles apparently, so it's not that "scoping is not working", it's more so that
we have to work with manual restarts
====

This is how the component code would look like:

[source, razor]
----
@page "/servers"

<h3>Servers</h3>
<br/>
<br/>
<ul class="button-list">
    @foreach (var city in cities)
    {
        <li> <.>
            <button type="button" class="btn btn-primary">@city</button> <.>
        </li>
    }
</ul>
<br/>
<br/>
<ul>
    @foreach (var server in servers)
    {
        <li>
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
    private List<string> cities = CitiesRepository.Cities;
}
----
<.> By convention, and to avoid errors, you should only have direct children of
a <ul>, <li> elements, inside of those elements you can then do whatever you want.

And the css that would make the buttons look nice and also use good css practices:

[source, css]
----
.button-list {
    display: flex;
    gap: 1rem;
    list-style: none;
    padding: 0;
}

.button-list li {
    display: flex; /* ensures buttons align neatly */
}
----
Since we have to work our way around the list elements, the default css will
add bullet points so we have to get rid of them with `list-style: none`, plus
no default padding: `0`. And so that the buttons, or the children elements align
neatly we will also apply a `display: flex` property to all of them. And the
different with a simple `<button>` is that the content will not have a padded
button at the beginning, this will neatly fit into the whole container.


**NOTE:** So, an interesting thing and piece of info in general is that the course
uses a bootstrap property to literally make the buttons change their layout as the
screen gets smaller, this is with a bootstrap class `container-fluid` apparently,
and it doesn't use a list it uses a div and inside of it buttons, then the buttons
stack up as the screen gets smaller, which is cool, I guess.

[source, razor]
----
@page "/servers"

<h3>Servers</h3>
<br/>
<br/>
<div class="container-fluid text-center"> <.>
    <div class="row w-50"> <.>
        @foreach (var city in cities)
        {
            <div class="col"> <.>
                <button type="button" class="btn btn-primary">@city</button>
            </div>
        }
    </div>
</div>
<br/>
<br/>
<ul>
    @foreach (var server in servers)
    {
        <li>
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
    private List<string> cities = CitiesRepository.Cities;
}
----
<.> So `container-fluid` simply makes a full-width content wrapper with padding.
<.> After that we are creating another `div` that I think could be simplified into
one div. But anyway, this has the `row` class with something that lets it grow
only until half the view port (width: 50%).
<.> Inside of this parent we have `class="col"` which are containers that help
everything stack as the screen grows larger or smaller. It's a bit magical since
you get these behaviors by applying bootstraps built-in classes, but... yeah. Trying
to replicate the same behavior and styling requires more in raw css, but again,
you can simplify so much and not be as bloated.

==== Working with Static Resources

Before going further into development, we need to learn another convention established
by Blazor. And that's a folder for static resources that the server can resolve
automatically, for that we need to have a look at the `Program.cs` file again:

[source, cs]
----
using ServerManagement.Components;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddRazorComponents();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error", createScopeForErrors: true);
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}

app.UseHttpsRedirection();


app.UseAntiforgery();

app.MapStaticAssets(); <.>
app.MapRazorComponents<App>(); <.>

app.Run();
----
<.> Just like the razor components middleware this takes care of configuring the app
so that all files under `wwwroot` are served by the server automatically (it can
resolve the static resources correctly). Without this middleware we wouldn't be
able to reference a resource and have that being retrieved by the server just fine.
<.> Remember, this line is a middleware that takes care of hooking up all requests
to the server to some specific razor page. Something to bear in mind though,
this had a different name before, it was `UseStaticFiles()`.

Under `wwwroot` we can nest many folders to keep things organized, but it's not
a hard requirement. For example, the scaffolded project has bootstrap in here,
as well as the root `css` file.

The course already provides for some images, these images are of the cities that
we have under `CitiesRepository.cs`. In order to style really good the buttons alongside
the city photos, we can use a bootstrap component called `Card`, by googling this
we can copy the boilerplate code straight from Bootstrap's page:

[source, razor]
----
@foreach (var city in cities)
        {
            <div class="col">
                <div class="card">
                    <img class="card-img-top" src="@($"/images/{city}.png")" alt="Card image cap"> <.>
                    <div class="card-body">
                        <button type="button" class="btn btn-primary">@city</button>
                    </div>
                </div>
            </div>
        }
----
<.> All of the other HTML code is redundant to explain, the meat of everything is here,
this is how we can access static resources, at the beginning we have `/` which means
we start from the `root`. The folder were we should place the images is `wwwroot`,
you can make the connection that way. And once we are there we can start building the
paths to the static resources depending on if things are nested or not. Pretty
neat. String interpolation comes back in its **explicit syntax** so that we can
evaluate a specific variable value but have it be interpolated accordingly.

==== Assignment 2: Create a routable component

==== Assignment 2: Answer

==== Route Parameters and Route Constraints
