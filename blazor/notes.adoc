= Introduction

These are notes for different things found in the Blazor (.NET) component frontend
framework. As a starter, we will have notes on a https://www.udemy.com/course/blazor-deep-dive-from-beginner-to-advanced/[Udemy]
course.

== Blazor Deep Dive - From Beginner to Advanced in .NET 8

=== Course Content

==== NET 9 Updates

.NET 9 introduced a few changes to Blazor. These changes are minor however. One
thing worth of note though is that you should include **SSR (Server Side Rendering)**
in a Blazor app configured to use server interactivity with global location.

==== What is Blazor

TL;DR: Blazor is a **component based** SPA web application framework that achieves
interactivity with C#.

_Component based SPA web application framework:_ This differs from the traditional
web application paradigm (which is also the first one that was invented). In the
sense that we are not responding to individual pages that a server requests, and
then spits back to the client.

The user will send requests to the web server as well, however the web server will
route all requests to **ONE PAGE**. This is in theory called _the root component_,
but you can still define it as this _root page_. No matter how many requests are
sent, they will always go to one single page. The Blazor Framework will look for
different components, and it will then **place the component** inside the root
component.

A simple workflow would be:

1. A first request will go to the server, the server will then request for the
necessary components to render that path.
2. A second request will come and the server will "erase" the previous components
and render others that respond to that specific request. And so on.

Components are a powerful paradigm because you can nest components inside of other
components, effectively turning this structure as a **component tree**, the levels
and children will be mandated by requirements.

The main idea is that you should **think in components**. Blazor uses C# in order
to reach interactivity. React, Angular, Vue, etc all use **javascript**.

==== Choices of interactivity

What is _interactivity_?

E.g., If we have a page, and on this page we have a list, we want to allow users
to search on that list based on a filter, only matching results to the filter
should show up in the list. We would have a search bar, a button. In order to
add _reactivity_ or _interactivity_ normally you would start using javascript.
But in Blazor we achieve that with C#, and C# only. The main idea behind the
framework's design is to unify code as much as possible and not rely on Javascript,
(although you will be still using it in really specific edge cases).

There are different ways to implement interactivity with Blazor, the types of
interactivity are:

No interactivity (base):: This is one type, in case you don't need any sort of reactivity,
this is also called SSR (Static Server Side Rendering). In most use cases, you will
create a project with this default interactivity setting. You would only need to
add interactivity based on **requirements**.
Server Interactivity:: This will make the application to establish a SignalR channel
from server to client (this is a WebSocket implementation). This is like a P2P
communication and it needs to be sustained. In order for this channel to work,
a javascript file is created inside of the page that is being rendered on the
browser, **this is not created by a developer** but by the framework. Whenever the
user does something, the event will be handled by said javascript server and sent
to the backend server, to then make a decision. It will compare the previous state
of the page and then a newly calculated state, that difference is then sent back
to the client so that it can attach it and re-render the page on the fly. (No
reload of the whole page)
WebAssembly Interactivity:: This is based on Blazor SSR, the components that require
WASM will then get packaged with tons of extra DLLs and WASM files and sent back
to the browser. This is then leveraged by the browser in order to run the interactions.
A good point here is that WASM is way faster than javascript since it runs at almost
native speeds. There's another approach in which the whole component gets compiled
into WASM and that gets sent to the browser to then be interpreted and run. But
either way, **some kind of files will be downloaded from the server to the browser**
and these files will then be executed by the browser.

Blazor SSR = **BASE OF EVERYTHING** When Web Interactivity is required, you can
choose WASM, Server Interactivity or a hybrid model in which some "pages" and components
run on server and others on WASM.

==== Blazor SSR Project Structure

In order to start getting familiar with Blazor SSR, we will create some dummy project
and describe its components.

First of all, when creating a Blazor Web Application, starting on .NET 8 the recommended
template is simple **Blazor Web App**. There are other variations however that might
apply to specific use cases.

[IMPORTANT]
====
We will select the "Interactivity Mode" as `None`, this is the stock Server Side
Static Rendering (SSR). And it's recommended to start your project with this setting,
the other ones are _Server, WebAssembly, Auto (Hybrid)_. Many pages that you create
you will see that require no interactivity, meaning that by selecting `None` you
can add interactivity to components that actually need it.
====

After we create the project with a "Interactivity" set, it will not matter later.

**NOTE:** Just to get things straight, the entry point is `Program.cs`. The paradigm
is simple, we do a `app.Run()` and the app stays alive as if in a "for-loop" and
will pick up on any Http Request that comes in. Once a request comes in, it goes
through different functions, which are called _Middlewares_.

[source, csharp]
----
using ServerManagement.Components;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddRazorComponents();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error", createScopeForErrors: true);
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}

app.UseHttpsRedirection(); <.>


app.UseAntiforgery();

app.MapStaticAssets();
app.MapRazorComponents<App>(); <.>

app.Run();
----
<.> Something like this is a Middleware, a request that comes will pass through the
logic that's stated here and maybe get something added to it, or extracted, middlewares
are multi-purpose in nature.
<.> This is a pretty important line of code, this will map all the Http requests
to the `App` class.

If we go and analyze the `App.razor` file that should be under `Components`. We
should find something like this:

[source, razor]
----
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <base href="/"/>
    <link rel="stylesheet" href="@Assets["lib/bootstrap/dist/css/bootstrap.min.css"]"/>
    <link rel="stylesheet" href="@Assets["app.css"]"/>
    <link rel="stylesheet" href="@Assets["ServerManagement.styles.css"]"/>
    <ImportMap/>
    <link rel="icon" type="image/png" href="favicon.png"/>
    <HeadOutlet/> <.>
</head>

<body>
<Routes/> <.>
<script src="_framework/blazor.web.js"></script>
</body>

</html>
----
This isn't the only place that will have `html` code declared inside of it. The
specific notations such as `HeadOutlet` and `Routes` will later come into play
when dealing with the framework's functionalities.

[IMPORTANT]
====
The `App.cs` component/razor file, is actually the _ROOT COMPONENT_. In here we
will be rendering all the components, hence it's configured in a way such that
all Http requests are mapped to this very specific component. This is the **one page** 
of the SPA.
====

It's through `<Routes />` that then the root component can resolve/render corresponding
components that respond to different routes.

Now this component can also be read, it should be right next to the `App.razor`
file.

[source, razor]
====
<Router AppAssembly="typeof(Program).Assembly">
    <Found Context="routeData">
        <RouteView RouteData="routeData" DefaultLayout="typeof(Layout.MainLayout)"/> <.>
        <FocusOnNavigate RouteData="routeData" Selector="h1"/>
    </Found>
</Router> <.>
====
<.> A key concept here is `DefaultLayout="typeof(Layout.MainLayout)"` this notation
specifically makes it so that the component will be spat out as HTML to the browser.

And so, in short, all the routes here will respond to a specific set of components
or "screens". Depending on the route that the server got, then all the respective
**content** will be displayed/replaced on the place that holds the `<Routes />`
tag.

The `MainLayout`, so the actual code that will render HTML can also be visualized
under `Components > Layout > MainLayout.razor`. Technically all blazor components
are under `.razor` files.

[source, razor]
.MainLayout.razor
====
@inherits LayoutComponentBase

<div class="page">
    <div class="sidebar">
        <NavMenu/>
    </div>

    <main>
        <div class="top-row px-4">
            <a href="https://learn.microsoft.com/aspnet/core/" target="_blank">About</a>
        </div>

        <article class="content px-4">
            @Body <.>
        </article>
    </main>
</div>
====
<.> The `@Body` annotation/tag is a really important piece of notation to keep in
mind, it's a placeholder for **any component**, no matter what type of component
is required by the user, it will come in here and replace the placeholder.

This is the _basic, theoretical flow_:

. Request comes into `Program.cs`
. Request goes to `App.razor`
. Goes to the `Routes.razor`
. Goes to `MainLayout.razor`

And through it all, it will render and swap out placeholders and places on each
layer respectively.

If you run the application, we should see both a terminal session and a web site
on our Default Browser.

The terminal holds some bits of info that's great:

. It will tell us at which ports the Blazor App is running
. It will also tell us which is the Root Page (component)

In short, the `MainLayout.razor` site renders a side bar, and then has content
that will change based on the route. This is how it all works, if you inspect
the HTML you will see how this rings true, how the sidebar is effectively **static**.

It's however Blazor that under the scenes takes care of replacing content based
on the routes.

This is the basic SSR setup, if we want WASM interactivity we will need to add a
second project, but overall it will remain the same. Hence it's said that
`SSR is the base of everything else`.

=== Blazor SSR

==== Two Types of Components

There are two types:

Routable Components:: Also called _Page Components_. This will respond directly
to a route.
Non-Routable Components:: Also called _Reusable Components_. These are used inside
routable components, and also inside of other non-routable components.

So, let's start playing around with the components and features. Say, we want to
create a Page that will respond to a new route. We should then create a `.razor`
file inside of `Pages`. Something like `Servers.razor`. You should _technically_
always create a _Razor Component_. But it's through anotations and other things
that we establish a routable and non-routable component and so on.

If we create with the scaffold:

[source, razor]
====
@page "/Servers" <.>
<h3>Servers</h3>

@code {
    
}
====
<.> This is the single most important thing that marks a component as a `routable
component`.

After adding this new component, and reloading the web site, we can manually type
`/servers` at the URL bar, if we get something rendered (in this case a simple heading
with `Servers`), then everything is working as expected.

We will now create a non-routable component, the course's convention is creating
a folder called `Controls`. And inside adding a `.razor` file. All of the components
inside should be _non-routable_. Another convention is to always suffix these components
with `Component` e.g., `ServerComponent.razor`

Once we create this component we can add some code to it to see if it renders, and
after that we can then use this component inside of any of our pages. In this case
if we were to put it into `Servers.razor`:

[source, razor]
====
@page "/servers"
@using ServerManagement.Components.Controls <.>

<h3>Servers</h3>
<br/>
<br/>
<ServerComponent/> <.>

@code {

}
====
<.> You could just import the namespace like this, but there's a more clean and
recommended way.
<> And here you can just write the component name with this syntax (that's really
close to how React would do it, or even Angular for that matter)

The better and cleaner approach to imports is to put the namespace import under the
`_Imports.razor` component that should be at the root of the `Components` folder.
In here you woul see things such as:

[source, razor]
====
@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using static Microsoft.AspNetCore.Components.Web.RenderMode
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.JSInterop
@using ServerManagement
@using ServerManagement.Components

@using ServerManagement.Components.Controls <.>
====
<.> This import can indeed be powerful, because, if by convention we create
all re-usable components under this namespace, next time, when trying to call them
from other components or pages, we won't have to always be importing them, this
centralized the import and makes things leaner.
====

If you were to declare `<ServerComponent />` twice, then its content should be
replicated normally. This is a reusability example, _don't forget about that_.

==== Razor Syntax Implicit Razor Expression

Blazor achieves interactivity with C#, this is at the frontend level. However
at the backend we also use C#, how will that work?

So that we can start using C# code we have to leverage **Razor Syntax**

[source, razor]
====
<p>
    @status <.>
</p>

@code {
    private string status = "Server is offline"; <.>
}
====
<.> This is called _implicit syntax_ we can reference variables that are written
in C# directly on the `HTML` part.
<2> As you can see we are using C# code here to assign a value to then be rendered.

We can then concatenate both HTML and "evaluation code". `@status at @DateTime.Now`.
Whenever there's an `@` then this is actually syntax that tells Blazor that something
from C# needs to come here (and be evaluated).

[NOTE]
====
Okay, thank god that Hot Reload is a _thing_. Hopefully it's stable now in .NET
9. https://learn.microsoft.com/en-us/aspnet/core/test/hot-reload?view=aspnetcore-9.0[hopefully].
====

The course leans heavily on this process of "Apply a change, restart the server",
and that is _so slow_. The industry standard should be hot reload (React, Angular
had over Blazor a long time ago). The way to _enable_ hot reload is to simply run
the application with `dotnet watch` this will keep a demon checking for changes
on the source code files, and if it's detected then it will auto reload itself,
in case something really critical is updated it will prompt the user to please
reload manually (better than wasting time).
====

What if we wanted to leverage some class? We can then create a model (POCO) under
something like `Models`. A typical POCO with `ServerId, City, Name` perhaps.
Nothing out of the ordinary.

And then we can reference it in our component like so:

[source, csharp]
.ServerComponent.razor
----
<p>
    @server.Name is in @server.City
</p>

@code {
    private Server server = new()
    {
        Name = "Server 1",
        City = "Toronto"
    };
}
----
As you can see, we are using **implicit syntax**, and after spaces then the evaluation
stops, hence always before spaces we should reference expressions that are C#
code related. We can use the **implicit syntax** under any HTML by the way, not
just paragraphs (`<p>`). This can even be evaluated on HTML properties.

And again, we should add its namespace to the `_Imports.razor` component so that
globally any model we add we can seamlessly consume from anywhere and removing
the need to import it always.

==== Razor syntax Explicit Razor Expression

The Razor expression would be limited if we only had the implicit type, since we
can't really do anything with logic or concatenation since a **space** literally
marks it as finished. And it's due to this that an _explicit expression is necessary_.

[source, razor]
====
<p>
    @server.Name is in @server.City that is @(server.IsOnline ? "online" : "offline") <.>
</p>

@code {
    private Server server = new()
    {
        Name = "Server 1",
        City = "Toronto"
    };
}
====
<.> With the `@()` syntax you can easily write more explicit code and logic so that
some rendering is applied based on pre-existing conditions. We can use the explicit
syntax even on attributes for an html element. Any C# expression can be used inside the
`@()`.

See how explicit syntax can be so powerful that it can literally be used for conditional
rendering and styling:

[source, razor]
====
<div style="color: @(server.IsOnline ? "green" : "red")" data-name="@server.Name" data-status="@(server.IsOnline ? "online" : "offline")"> <.>
    @server.Name is in @server.City that is @(server.IsOnline ? "online" : "offline")
</div>

@code {
    private Server server = new()
    {
        Name = "Server 1",
        City = "Toronto"
    };
}
====
<.> In here under a `style` we can literally conditionally apply a color or something
alike. It's extremely powerful.

_NOTE:_ We can also use a direct object for style: `style="@($"color: {(server.IsOnline ? "green" : "red")}")"`,
the thing with this syntax though is that we can nest another "evaluation expressions"
inside of the existing @() part. So this is a great way to keep adding more complex
condition paths in the same structure.

The Razor expression syntax has tons of power when it comes to rendering things
with C# code and bound objects.

==== Create a static data repository

In order to keep exploring Blazor's capabilities we can now create a mode for
mocking data. In our case we'll use the Repository pattern to create a `ServersRepository.cs`
class.

There's nothing worth of note here, more than a simple CRUD but that's managing
a static list in memory. We won't connect to some backing service since the focus
of the whole course is Blazor, we just need a source of data.

==== Razor Syntax Output list with looping

We are going to use looping to output a list inside of a Razor component.

[source, razor]
----
@page "/servers"

<h3>Servers</h3>
<br/>
<br/>
<ul>
    @foreach (var server in servers) <.>
    {
        <li>
            @server.Name in @server.City is <.>
            <span style="color: @(server.IsOnline ? "green" : "red")"> <.>
                @(server.IsOnline ? "online" : "offline")
            </span>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
}
----
<.> Se use the `@foreach` control directive to then loop over a list and render
_repeatedly_ HTML elements as we see fit (per entry of the list).
<.> We will then have code that can easily resemble what we already saw previously
but now applied to this new "iterative logic".

==== Assignment 1: Output city buttons list

We are going to output city buttons.

The idea is to practice the `@foreach` loop syntax, the rules are as follows:

. We are going to create a city model
. We will create a city repository
. We will output the cities as lists

We will work with static lists, so under `Models > CitiesRepository.cs` we will
simply have a string list with city names.

==== Assignment 1: Answer

Under the `Servers.razor` file:

[source, razor]
----
@page "/servers"

<h3>Servers</h3>
<br/>
<br/>
<ul>
    @foreach (var city in cities)
    {
        <button type="button">@city</button> <.>
    }
</ul>
<ul>
    @foreach (var server in servers)
    {
        <li>
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
    private List<string> cities = CitiesRepository.Cities;
}
----
<.> This is something that works just fine, BUT, Blazor by default comes with
bootstrap already installed, so we can style this with `class="btn btn-primary"`.

Now, the course does really hacky stuff, in order to add a space between the buttons
it uses this interesting syntax called `<text></text>` that you can use to enclose
some special characters, I guess that's, cool? Don't really know. But we can style
components as we would without issue by creating a file like:

````
|-- Servers.razor
|-- Servers.razor.css
````

And in there we can start adding as much styling as we want to, by default Blazor
will then compile this into isolated CSS so we shouldn't class with other styles
and we will keep things lean.

[NOTE]
====
IF YOU CAN'T SEE THE STYLES GETTING APPLIED/LOADED THAT'S PROBABLY BECAUSE YOU HAVE
TO RELOAD THE WHOLE APP. This is dumb, tbh, the hot reload doesn't pick up on
styles apparently, so it's not that "scoping is not working", it's more so that
we have to work with manual restarts
====

This is how the component code would look like:

[source, razor]
----
@page "/servers"

<h3>Servers</h3>
<br/>
<br/>
<ul class="button-list">
    @foreach (var city in cities)
    {
        <li> <.>
            <button type="button" class="btn btn-primary">@city</button> <.>
        </li>
    }
</ul>
<br/>
<br/>
<ul>
    @foreach (var server in servers)
    {
        <li>
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
    private List<string> cities = CitiesRepository.Cities;
}
----
<.> By convention, and to avoid errors, you should only have direct children of
a <ul>, <li> elements, inside of those elements you can then do whatever you want.

And the css that would make the buttons look nice and also use good css practices:

[source, css]
----
.button-list {
    display: flex;
    gap: 1rem;
    list-style: none;
    padding: 0;
}

.button-list li {
    display: flex; /* ensures buttons align neatly */
}
----
Since we have to work our way around the list elements, the default css will
add bullet points so we have to get rid of them with `list-style: none`, plus
no default padding: `0`. And so that the buttons, or the children elements align
neatly we will also apply a `display: flex` property to all of them. And the
different with a simple `<button>` is that the content will not have a padded
button at the beginning, this will neatly fit into the whole container.


**NOTE:** So, an interesting thing and piece of info in general is that the course
uses a bootstrap property to literally make the buttons change their layout as the
screen gets smaller, this is with a bootstrap class `container-fluid` apparently,
and it doesn't use a list it uses a div and inside of it buttons, then the buttons
stack up as the screen gets smaller, which is cool, I guess.

[source, razor]
----
@page "/servers"

<h3>Servers</h3>
<br/>
<br/>
<div class="container-fluid text-center"> <.>
    <div class="row w-50"> <.>
        @foreach (var city in cities)
        {
            <div class="col"> <.>
                <button type="button" class="btn btn-primary">@city</button>
            </div>
        }
    </div>
</div>
<br/>
<br/>
<ul>
    @foreach (var server in servers)
    {
        <li>
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
    private List<string> cities = CitiesRepository.Cities;
}
----
<.> So `container-fluid` simply makes a full-width content wrapper with padding.
<.> After that we are creating another `div` that I think could be simplified into
one div. But anyway, this has the `row` class with something that lets it grow
only until half the view port (width: 50%).
<.> Inside of this parent we have `class="col"` which are containers that help
everything stack as the screen grows larger or smaller. It's a bit magical since
you get these behaviors by applying bootstraps built-in classes, but... yeah. Trying
to replicate the same behavior and styling requires more in raw css, but again,
you can simplify so much and not be as bloated.

==== Working with Static Resources

Before going further into development, we need to learn another convention established
by Blazor. And that's a folder for static resources that the server can resolve
automatically, for that we need to have a look at the `Program.cs` file again:

[source, cs]
----
using ServerManagement.Components;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddRazorComponents();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error", createScopeForErrors: true);
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}

app.UseHttpsRedirection();


app.UseAntiforgery();

app.MapStaticAssets(); <.>
app.MapRazorComponents<App>(); <.>

app.Run();
----
<.> Just like the razor components middleware this takes care of configuring the app
so that all files under `wwwroot` are served by the server automatically (it can
resolve the static resources correctly). Without this middleware we wouldn't be
able to reference a resource and have that being retrieved by the server just fine.
<.> Remember, this line is a middleware that takes care of hooking up all requests
to the server to some specific razor page. Something to bear in mind though,
this had a different name before, it was `UseStaticFiles()`.

Under `wwwroot` we can nest many folders to keep things organized, but it's not
a hard requirement. For example, the scaffolded project has bootstrap in here,
as well as the root `css` file.

The course already provides for some images, these images are of the cities that
we have under `CitiesRepository.cs`. In order to style really good the buttons alongside
the city photos, we can use a bootstrap component called `Card`, by googling this
we can copy the boilerplate code straight from Bootstrap's page:

[source, razor]
----
@foreach (var city in cities)
        {
            <div class="col">
                <div class="card">
                    <img class="card-img-top" src="@($"/images/{city}.png")" alt="Card image cap"> <.>
                    <div class="card-body">
                        <button type="button" class="btn btn-primary">@city</button>
                    </div>
                </div>
            </div>
        }
----
<.> All of the other HTML code is redundant to explain, the meat of everything is here,
this is how we can access static resources, at the beginning we have `/` which means
we start from the `root`. The folder were we should place the images is `wwwroot`,
you can make the connection that way. And once we are there we can start building the
paths to the static resources depending on if things are nested or not. Pretty
neat. String interpolation comes back in its **explicit syntax** so that we can
evaluate a specific variable value but have it be interpolated accordingly.

==== Assignment 2: Create a routable component

We have to create a routable component that we can redirect through the different
elements on the list of servers. Use Bootstrap LinkButton, click and then replace
the content with a new dummy "Add Server" button.

I chose a "badge". The issue is that the course is definitely with an Old Bootstrap
version, (3 - 4), and the newest version (5) has differences in class names.

https://getbootstrap.com/docs/4.0/components/badge/#links[Links Bootstrap 4]

https://getbootstrap.com/docs/5.3/components/badge/#pill-badges[Links Bootstrap 5]

In the currrent project if trying to use `<a href="#" class="badge badge-primary">Primary</a>`
then the styling wouldn't work at all. And so had to go into the Bootstrap 5 docs
to see the valid class name: `<a href="/add-server" class="badge bg-primary">Add Server</a>`

==== Assignment 2: Answer

. Create a Page component under `Pages` (Remember that by convention these components
don't have the `Component` suffix)
. So the course was unclear, it was an `Edit` page.

The files would look like something like this:

[source, razor]
.Pages/EditServer.razor
----
@page "/servers/edit" <.>
<h3>AddServer</h3>

@code {
    
}
----
<.> This marks this component as to something that will respond to a server call
to /servers/edit.

[source, razor]
.Servers.razor
----
@foreach (var server in servers)
    {
        <li>
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
            <a href="/servers/edit" class="btn btn-link">Edit</a> <.>
        </li>
    }
----
<.> This is a bit "unconventional" in the sense that it could be an actual button
and not an anchor link, but I guess that due to web standard's defaults we will
trigger a call to the server that will then route to our created component. The
`btn btn-link` styles work just fine in Bootstrap 5. Another thing worthy of note
is that in order for us to build the different routes that will then map to
pages, is to start at root always `/`, and then build the respective route.

[NOTE]
====
The course uses this hack way of adding artificial spaces with `&nbsp;`. Again, this
is not a good practice for web dev in any shape or form.
====

Besides that, the instructor expands on adding a link in the navbar at the left
so that we can actually see the list of servers that up until now we have simply
accessed by writing manually the route on the browser.

Now, the way to build your way to the respective file that we need to edit. You
have to start at the root `App.razor`. Remember that in there there's a `<Routes/>`
component.

The routes component has this code:

[source, razor]
.Routes.razor
----
<Router AppAssembly="typeof(Program).Assembly">
    <Found Context="routeData">
        <RouteView RouteData="routeData" DefaultLayout="typeof(Layout.MainLayout)"/> <.>
        <FocusOnNavigate RouteData="routeData" Selector="h1"/>
    </Found>
</Router>
----
<.> For now, the only important part of the code is this `Layout.MainLayout` line,
this is what will be rendered in place of `<Routes />`, this component is under
`Components > Layout > MainLayout.razor`.

And under here by reading the razor code you can notice a component with styling
such as `sidebar` and this pointing to a `<NavMenu />`, component that conveniently
is under the same `Layout` folder. This is the code with a plus entry for accessing
the `/servers` route:

[source, razor]
.NavMenu.razor
----
<div class="top-row ps-3 navbar navbar-dark">
    <div class="container-fluid">
        <a class="navbar-brand" href="">ServerManagement</a>
    </div>
</div>

<input type="checkbox" title="Navigation menu" class="navbar-toggler"/>

<div class="nav-scrollable" onclick="document.querySelector('.navbar-toggler').click()">
    <nav class="nav flex-column">
        <div class="nav-item px-3">
            <NavLink class="nav-link" href="" Match="NavLinkMatch.All">
                <span class="bi bi-house-door-fill-nav-menu" aria-hidden="true"></span> Home
            </NavLink>
        </div>

        <div class="nav-item px-3">
            <NavLink class="nav-link" href="weather">
                <span class="bi bi-list-nested-nav-menu" aria-hidden="true"></span> Weather
            </NavLink>
        </div>
        
        <div class="nav-item px-3">
            <NavLink class="nav-link" href="servers"> <.>
                <span class="bi bi-list-nested-nav-menu" aria-hidden="true"></span> Manage Servers <.>
            </NavLink>
        </div>
    </nav>
</div>
----
<.> The route resolve works both for `/servers` or `servers`.
<.> And under here we can add the new entry that should redirect us to the server
list page, this has a label of `Manage Servers`.

==== Route Parameters and Route Constraints

We have created the routable component, we can navigate to it, but we don't have
any idea of how to know what server are we editing.

The way to pass information from one page to the next one (one of the ways) is
through the url (a route parameter). So we want to be able to put `/servers/edit/1`
and then be on a routed component that has now the information of server 1 to
edit.

The way to prepare our triggering page to then go into the respective url we would
do something like this:

````
<a href="/servers/edit/@server.Id" class="btn btn-link">Edit</a>
````

This is at `Servers.razor`, as you can see we are using implicit syntax to then
be able to dynamically retrieve the `Id` of the server so that it then routes back
to the routable component with that specific server state loaded.

If we hover over the link we would see the link ending with `1, 2, 3, etc...`.
Now of course, if we click the link we would get hit with a 404. But wiring this
up is pretty easy.

On the receiving page you should mark one of the resource levels with a specific
syntax:

[source, razor]
.AddServer.razor
----
@page "/servers/edit/{id}" <.>
<h3>AddServer</h3>
<br/>
@Id <.>

@code {
    [Parameter] <.>
    public string Id { get; set; } = string.Empty;
}
----
<.> In here between curly braces you can give a name to whatever route parameter
you are setting the page to accept.
<.> And with implicit syntax we can then test and print the receiving value that
should be bound to the url's route parameter.
<.> And lastly so that we bind everything correctly, we have to decorate a property
with `[Parameter]`, in this case we are binding to a `string` since that will take
whatever.

After setting this, we should be able to access the respective server's edit page,
and we should be rendering the respective ID that comes from the route parameter.

There's something odd here though, if we try and hit `/servers/edit` we will get
rendered `edit` which is odd, we are expecting only numbers here, luckily there
is a feature to apply constraints to the route parameters. (We want only an integer).

These are called **Route Constraints**.

The way to add constraints is by appending a type:

````
@page "/servers/edit/{id:int}"
<h3>AddServer</h3>
<br/>
@Id

@code {
    [Parameter]
    public int Id { get; set; }
}
````
After a colon, you can add tons of constraints, in our case we are simply saying
that the route should be an `int` and of course the state variable should also
be of the respective type.

After this (probably restart the server, hot reload doesn't really work), and we
should be able to still navigate just fine, on top of getting a 404, or error
if trying to set the route to something like `edit/edit`. This makes it so that
our route constraint works.

The Microsoft Docs points to the different constraints that are supported at
its https://learn.microsoft.com/en-us/aspnet/core/blazor/fundamentals/routing?view=aspnetcore-9.0#route-constraints[website].
But they are not that complex, a route parameter should be akin to a primitive type
by convention and security.

An extra piece of info that is good to know is optional parameters:

[source, razor]
----
@page "/route-parameter-2/{text?}" <.>

<PageTitle>Route Parameter 2</PageTitle>

<h1>Route Parameter Example 2</h1>

<p>Blazor is @Text!</p>

@code {
    [Parameter]
    public string? Text { get; set; } <.>

    protected override void OnParametersSet() => Text = Text ?? "fantastic"; <.>
}
----
<.> If you want a route to take a possible null value as a route parameter, just
suffix it with a `?` mark.
<.> And of course, make the state variable match the route parameter with a nullable
type.
<.> Lastly, this might be a good recipe for further use cases down the line, we can
hook into the `OnParametersSet` method so that in case the route doesn't have
the respective parameter we coalesce its value to some default, this seems pretty
handy.

==== Use OnParametersSet to receive parameter value

Blazor has the concept of **Lifecycle events**, in this lesson we will leverage
`OnParametersSet` specifically to retrieve route parameter values.

_NOTE:_ There's a `OnParametersSetAsync` method.

Our Use Case requires for us to get the route parameter value and then load information
based on the `Id`, this info can be used for further logic and/or display purposes.

[source, razor]
----
@page "/servers/edit/{id:int}"
<h3>AddServer</h3>
<br/>
<p> <.>
    @_server?.Name
</p>
<p>
    @_server?.City
</p>
<p>
    @_server?.IsOnline
</p>

@code {
    [Parameter]
    public int Id { get; set; }
    
    private Server? _server { get; set; }

    protected override void OnParametersSet() <.>
    {
        _server = ServersRepository.GetServerById(Id); <.>
    }

}
----
<.> We could add a `if (server is not null)` but that's a bit Ugly I think, unless
there's a bigger render reason to not show a whole chunk of html, so using coalesce
like this is classier.
<.> The lifecycle hooks should always be overriden (and are protected), we shouldn't
have to call the base method since it's redundant.
<.> It is on the body of the lifecycle hook that we can then be sure that we have
the variable with the correct piece of data to then retrieve a server Id and save
the instance into a private member (a field).

This component should now display the server info as we expect it. We can even
add a `Go Back` button after that will throw us into the `/servers` page again.
And we can even style an anchor as if it were a button with `btn btn-primary`.

==== Use Form and Input components to display and collect data

Traditionally in Web Systems, an extremely important piece of interactivity are
**Forms**. And so these are built with native tags such as `<form>`, `<input>`,
`<button type="submit">`.

Because Blazor is a component-based web framework, Microsoft has already out-of-
the-box built-in componnets. Instead of plain html, we can use <EditForm>. This is
a built-in component that has tons of functionality already ready to be consumed
so we don't have to implement things from zero.

And for controls we have:

`<InputText>`
`<InputNumber>`
`<InputCheckbox>`

We can use these components inside of the form. We will display data, collect data
and everything.

By using the built-in form we save a lot of time specially for things such as
validation.

[source, razor]
----
@if (_server is null)
{
    return; <.>
}

<EditForm Model="_server"> <.>
    <InputText @bind-Value="_server.Name"></InputText> <.>
    <InputText @bind-Value="_server.City"></InputText>
    <InputCheckbox @bind-Value="_server.IsOnline"></InputCheckbox>
</EditForm>
----
<.> Learned this in prod :). A clean way of returning early and avoiding unnecessary
rendering.
<.> So there are different ways of binding models to the form, one of them is
with this `Model` attribute that we can bind to a state field, in this case is the
`_server` that we received from the repository.
<.> Lastly, we can then add inside different components for different controls
and the specific field they match to.

Now, if we wanted to make it look pretty, we can leverage Bootstraps form control
styles and other utilities:

[source, razor]
----
<EditForm Model="_server">
    <div class="row mb-3"> <.>
        <div class="col-2"> <.>
            <label class="col-form-label"> <.>
                Name
            </label>
        </div>
        <div class="col-6"> <.>
            <InputText class="form-control" @bind-Value="_server.Name"></InputText> <.>
        </div>
    </div>
    <div class="row mb-3">
        <div class="col-2">
            <label class="col-form-label">
                City
            </label>
        </div>
            <div class="col-6">
                <InputText class="form-control" @bind-Value="_server.City"></InputText>
            </div>
    </div>
    <div class="row mb-3">
        <div class="col-2">
            <label class="col-form-label">
                Online
            </label>
        </div>
        <div class="col-6">
            <InputCheckbox class="form-check-input" @bind-Value="_server.IsOnline"></InputCheckbox> <.>
        </div>
    </div>
</EditForm>
<a href="/servers" class="btn btn-primary ">Go Back</a>
----
<.> The layout calls for different rows for a control that holds both a `label` and
a `control`, so we would have 3 controls. The `row` style of boostrap simply states:
"The things inside should be on the same line (row), all of them will be referred
to as columns". `mb-3` simply adds 3 units of margin at the bottom.
<.> `col-2` simply states that this container will take 2-parts (cols) of the
12-part grid.
<.> `col-form-label` styles the `<label>` element so that it aligns properly
with the control (input)
<.> `col-6` simply states that this container will take 6-parts (cols) of the 12-part
grid.
<.> `form-control` Simply styles the control with Bootstrap's stuff
<.> `form-check-input` styles the control specifically for a checkbox with Bootstrap

[NOTE]
====
Overall, this is so cute, because it's really beginner code, we can definitely
abstract this even further so that we don't duplicate as much code. It's harder
to edit later.
====

**EXTRA:** This `12-grid` concept is a core concept special to **Bootstrap**. By
default Bootstrap divides every row into 12 equal parts horizontally. Every row
is 12 units wide, and the way you style child components will make them take more
or less space of that 12 unit space. _Why 12?_ It's flexible, you can divide it
evenly in many ways (apparently).

You can definitely check the code for Bootstrap's controls and other utility
classes at its https://getbootstrap.com/docs/5.3/forms/form-control/#example[docs].

Just remember that depending on your need, you can use different built-in control
components from Microsoft's Blazor Library and not have to worry of reinventing
the wheel.

==== Form submission and model binding

We are going to learn how to submit data, this is specifically for Blazor SSR,
with interactivity the process is quite different.

SSR = Is really similar to traditional web applications, a form submission is just
a traditional form submission.

A form is in the browser, when the user clicks a `submit` then the url, form values
are packed and sent to the server. When the server receives the HTTP request it
will process it.

Blazor SSR works the same, we should code a function and its paremeters so that
the logic gets triggered depending on the request that's coming into the server.

[source, razor]
----
@page "/servers/edit/{id:int}"
<h3>Edit Server</h3>
<br/>

@if (_server is null)
{
    return;
}

<EditForm Model="_server" FormName="formServer" OnSubmit="Submit"> <.>
    <div class="row mb-3">
        <div class="col-2">
            <label class="col-form-label">
                Name
            </label>
        </div>
        <div class="col-6">
            <InputText class="form-control" @bind-Value="_server.Name"></InputText>
        </div>
    </div>
    <div class="row mb-3">
        <div class="col-2">
            <label class="col-form-label">
                City
            </label>
        </div>
        <div class="col-6">
            <InputText class="form-control" @bind-Value="_server.City"></InputText>
        </div>
    </div>
    <div class="row mb-3">
        <div class="col-2">
            <label class="col-form-label">
                Online
            </label>
        </div>
        <div class="col-6">
            <InputCheckbox class="form-check-input" @bind-Value="_server.IsOnline"></InputCheckbox>
        </div>
    </div>
</EditForm>
<a href="/servers" class="btn btn-primary ">Go Back</a>

@code {
    [Parameter]
    public int Id { get; set; }

    [SupplyParameterFromForm(FormName = "formServer")] <.>
    private Server? _server { get; set; }

    private void Submit() <.>
    {
    }

    protected override void OnParametersSet()
    {
        _server = ServersRepository.GetServerById(Id);
    }

}
----
<.> So the `<EditForm>` component can receive two properties: `FormName` and `OnSubmit`.
One will help us identify the form in case there are multiple forms and this is a
unique identifier, on the other hand we have to supply a callback that will respond
when the form triggers a submit.
<.> We can leverage `SupplyParameterFromForm` and even specify the specific form name,
this is so that when a submission is triggered, and we need to map-out (bind) all the
form's state we can automatically bind it to a state property.
<.> Lastly we need to create the callback method that will be triggered on form
submission.

This way Blazor will have effectively wire everything so that the form submission
works as expected (as per convention).

The last component we need to but is a submit button actually: `<button class="btn btn-primary" type="submit">Update</button>`.
This is typical stuff, with the only difference is that it should be of `submit`
type.

_NOTE:_ Tried it with Rider, and we can debug Blazor (well at least this simple
project). So if we setup breakpoints in the `Submit` method, we should hit it
after pressing the submit button.

An interesting piece of behavior to highlight here is though that when we hit the
submit, as is, we will notice that the updated state from the view is not actually
being sent at the runtime of the `OnSubmit`. Well it _seems_ that way, but what's happening
is actually that `OnParametersSet()` overrides this value (so it runs before) the
`OnSubmit` gets triggered and we lose state. The easiest way to fix this is by
doing this:

````
protected override void OnParametersSet()
    {
        _server ??= ServersRepository.GetServerById(Id);
    }
````

By using this coalesce we will only try and hit the `ServersRepository` method if
`_server` is null, otherwise we will keep whatever value it had. This effectively
is a circuit-breaker so that we are not hitting always the repo in order to
get data.

A second interesting find, is that because we are doing this whole `SupplyParameterFromForm`,
the whole model will mapped to whatever the form has packaged, and one property
that we don't have right now available is `Id`. If we see the value of the `_server`
variable, we will see `Id = 0`. This is bad since it's not consistent, and if
we were to rely on this Id, it can easily become a bug.

And so, I remembered that in prod we also did this (which is bad), that is adding
a hidden field in the view so that the state is kept and bound correctly:

````
<InputNumber hidden="true" @bind-Value="@_server.Id"></InputNumber>
````

The `InputNumber` component is important since `Id` is an int property, if we
try and use a `TextInput` we will get compilation errors.

With this in mind, we can now code the submit logic.

[source, razor]
----
private void Submit()
    {
        if (_server is null) <.>
        {
            return;
        }
        
        ServersRepository.UpdateServer(_server.Id, _server); <.>
    }
----
<.> Don't forget about the return early principle. (else-less).
<.> And in here we simply update the respective server with its Id, and then
send the whole payload that will update the server.

In Blazor SSR a submission handler takes care of a form submission, there are
actually other types of submits for specific cases `OnValidSubmit`, `OnInvalidSubmit`.

Traditionally the "receive data of a form submission" is what we refer as **Model
Binding**. It's like a two-way data-binding. The moment the form is submitted
we bind all of the payload to a state variable.

==== Form Validations

When the form is submitted we need to validate data. We will use annotations to
add this behavior, not an actual Blazor feature but a plain C# Data Anotation.

[source, csharp]
----
using System.ComponentModel.DataAnnotations; <.>

namespace ServerManagement.Models;

public class Server
{
    public Server()
    {
        var random = new Random();
        var randomNumber = random.Next(0, 2);
        IsOnline = randomNumber % 2 == 0;
    }
    
    public int Id { get; set; }
    
    public bool IsOnline { get; set; } <.>
    
    [Required] <.>
    public string? Name { get; set; }
    
    [Required]
    public string? City { get; set; }
}
----
<.> In order to work with the respective data anotations, we need to import this
specific namespace.
<.> The `bool` type has a `false` default value so it will always have a value, no
need to mark it as `[Required]`
<.> In the model that will be bound to the form we can add all the respective data
anotations we want so that the form is fed this metadata and tries to run validations
automatically against these specific rules.

You can read further at https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations?view=net-9.0[MS Docs],
specifically the `RequiredAttribute` link.

We have tons of attributes that we can use, [Compare Attributes, Display Attribute
(play with the label and the actual underlying value), StringLengthAttribute].
All of them have their own respective use case.

In our case we will use the `[Required]` data anotation, once we have set up all
of our logic. Now, in order to start applying the respective data anotation validations
we need to use a couple of extra components:

[source, razor]
----
<EditForm Model="_server" FormName="formServer" OnValidSubmit="Submit"> <.>
    <DataAnnotationsValidator></DataAnnotationsValidator> <.>
    <ValidationSummary></ValidationSummary> <.>
    // ...etc
----
<.> We can directly hook our method to `OnValidSubmit` so that we run our update
logic only when the form submission is successful (meaning no errors popped up on
model vlaidation). We have the option to hook into `OnInvalidSubmit` also.
<.> In order for the `<EditForm>` to sort of **gain** the ability to start validating
through the model's possible data anotations we need to add this inner component
inside of it (this pattern is pretty interesting, might have to keep it stored for
self-built components or overall a new pattern for approaching these types of use
cases).
<.> And lastly we can simply use a built-in component that spits all the errors
that it might find within the model based on the rules that Data Anotations might
express.

We can test out if our code actually works as intended by going to the website,
deleting the city and name fields and trying to submit. We should be seeing
both a message on red and then the respective fields highlighted with red, Blazor
should have abstracted all of the things that make this work in the background,
(classic Microsoft). We can check that we didn't actually trigger an update by
going back to the server list, we should see that nothing changed. And if we update
something that is valid, we should see the change coming through.

[source, razor]
----
<div class="row mb-3">
        <InputNumber hidden="true" @bind-Value="@_server.Id"></InputNumber>
        <div class="col-2">
            <label class="col-form-label">
                Name
            </label>
        </div>
        <div class="col-6">
            <InputText class="form-control" @bind-Value="_server.Name"></InputText>
        </div>
        <div class="col">
            <ValidationMessage For="() => _server.Name"></ValidationMessage> <.>
        </div>
    </div>
----
<.> Another special component is `ValidationMessage`, we can literally put it next
to control element and then through a Lambda expression point to the specific model
property that should be wired to.

_This is really cute_. But I get the principle. Again, abstract, make things easier
for the devs and all. But we are losing vital knowledge and experience in the way.
Anyway, this component will show a message in red and will also respond based on
the errors that the wired-up field presents.

[NOTE]
====
For the `IsOnline` field we don't have to do the whole `<ValidationMessage>` bit
technically, however for good measure we can add it.

I also just came to the realization that this is all in the default SSR mode,
with no reactivity in mind. Hence we have to do things so cutely (I'm assuming).
It's pretty close to normal HTML, faster and all. So depending on your requirement
you might switch the mode and add/subtract/change the conventions, and patterns
you use.
====

We are free to chose which component to use based on the requirements, never forget
about that.

==== Navigation with NavigationManager & Dependency Injection

We will talk about DependencyInjection, why? Because it's necessary to learn how
to hookup a component to DI services/components.

In short, we are required to somehow "programatically" trigger router navigation,
(this is really interesting now, the languages, frameworks, things might change,
but core concepts that respond to universal programming problems are still there,
you just need to learn how to represent that in a different language most of the
time).

We want to trigger RouterNavigation when we do an update on a server, this has
to be done behind the scenes, take the user to the servers screen to see the server
with hopefully the updated field.

_Cute Blazor:_ By adding a dependency injection component hot reload just doesn't
really work well, I think Microsoft was just too stubborn to realize that the way
they built this didn't account for market standards (React, Angular, Vue, Svelte),
and now have a half-measure for hot reload, but you are forced to keep on reloading
everything. (The con you take for not learning javascript I guess?).

How should we get the `NavigationManager` in our component to start routing:

[source, razor]
----
@inject NavigationManager NavigationManager <.>

// Code

private void Submit()
    {
        if (_server is null)
        {
            return;
        }

        ServersRepository.UpdateServer(_server.Id, _server);
        NavigationManager.NavigateTo("/servers"); <.>
    }
----
<.> This is Blazors solution to DI in a built-in way. The components are under the
hood just classes, and we want to move away from bad patterns of the past. We
want to invert dependencies.
<.> And after we have injected the `NavigationManager` we use the same name to
then start consuming the instance.

We don't want to have classes depend on other classes e.g., `var nav = new NavigationManager()`,
and Microsoft's philosophy is to always abstract things for devs and users so that
they are "easier". To a detriment sometimes, but that's besides the point. In this
attempt, DI is also taken care of for us through the Blazor framework, we just need
to know how to consume it and forget about the details, (abstraction). By inverting
dependencies here, we avoid memory leaks, and forget about lifecycle management
of another class from another class.

[IMPORTANT]
====
This is how under the hood Dependency Injection works:

We want to keep components loosely coupled, not depending between each other.
In order for that to happen we need to decouple them with depency inversion.
Who takes care of this is decided on the framework and designer's minds, but for
ASP.NET Core, which Blazor is a part of, we have an internal component called
"DI Container". This is the _thing_ that helps us inject the required instance
of a component inside of another component, and he will take care of lifecycle
management and all. `NavigationManager` is pre-registered in the DI Container,
that way we can focus entirely on building what matters and not worry too much
about these _"technicalities"_.
====

If we take a look at the `Program.cs` file, we can easily pinpoint the location
of the Dependency Container:

[source, cs]
.Program.cs
----
builder.Services.AddRazorComponents();
----

Inside of the `Services` proprety of the `builder` we are referencing this oh-so-called
mythical dependency container. If we drill down into its code we can see how this
collection abstracts things such as `TryAddSingleton<>`, `AddScoped<>`. These are
all calls to add services into the containers. Tying into the `AddScoped` call and
SignalR (which is what powers Blazor), we should be aware of one key thing: **SCOPED
SERVICES ARE ALIVE AS LONG SIGNALR HAS AN OPEN CHANNEL, ONCE IT CLOSES THE SERVICE
ALSO GETS GARBAGE COLLECTED**.

Reading further into subsequent calls of the code, we can see `services.TryAddScoped<NavigationManager, HttpNavigationManager>();`,
which is actually the `NavigationManager` that we injected into our blazor component.
As you can see, this is abstracted and ready for us to use, but it's still **GOOD
TO KNOW HOW IT WORKS UNDER THE HOOD**.

And yeah, this is all the knowledge you need as a base line. _Remember it_.

The `NavigationManager` is an abstract class, its almost an interface, the concrete
implementation in Blazor is `HttpNavigationManager`. Due to this design decision,
the framework has properly used best practices and correct implementations of
theory, it has effectively removed the dependency in a **concrete implementation**

**BIG TAKEAWAY:** So there's a reason for all of this.


[NOTE]
====
If we need to inject extra services we can add into the DI container with
`builder.Services.AddScoped<>`, `builder.Services.AddSingleton<>`. And always
as a best practice is to add an abstract/interface and then its concrete implementation,
that's the best way to align with clean code.
====

Infrastructure helps, .NET Core, helps with everything. Thanks.

==== Assignment 3: Add Server

We want to add a server.

- Adding a routable component
- Using Forms
- Using NavigationManager

Pretty straightforward, instructions not really clear, but I can only assume that
the city images when pressed on the button it will route back to the Add Server
component and have the city pre-filled. For whatever reason I can't map the
navigation though. It's just not working. Maybe SSR has to play a part in here???
Don't know.

Will have to look at the Answer, _as much as it pains me to do so_.

==== Assignment 3: Answer

AddServer is another routable component: So `Pages > AddServer.razor`. In a
real project, we have the option of turning the `EditServer.razor` in a multiple-purpose
component. But our requirement is constraining us.

But one key takeaway here is that if we are going to get a "multiple-purpose"
type of component this should be placed inside of a reusable components folder,
such as `Controls`.

The course made a mistake, it's setting the `IsOnline` to `false` in the object
initialization. But that's redundant, booleans have a `false` value by default
on C#.

A good point to bring up here and it's worth remembering.

`AddServer.razor` and `EditServer.razor` have repeated code (which is bad but we
are not focusing on this for now). They have the same form name, this is **OKAY**.
Because when we submit a form and the whole page gets packaged alongside the form and
its state, we will have the url as another way of differentiating the requests in
the server, there is no risk of **clashes**.

A couple of additions to the code based on the answer:

- We don't need to add the hidden _id field_, since the ID doesn't exist and will
be calculated on the Repository side.
- We should use the `[SupplyParameterFromForm]` anotation on the model that we have,
don't forget that after a submit the form state will bind to the property that
has this anotation.
- Lastly we need to navigate back to the servers list page with the `NavigationManager`

And this is where the nebulous requirement really messed me up, we are apparently
going to add a button for Add Server at the bottom, none of the fancy stuff I
was trying to do, I'm realizing that the list of cities is probably for filtering
purposes.

So yeah, pretty straightforward, just add an anchor to trigger navigation to the
AddServer page:

````
<a href="/servers" class="btn btn-primary ">Go Back</a>
````

And also the `IsOnline = false` behavior now is clear, because the default constructor
of the `Server` class actually by default turns the server on. But on this specific
page, we don't want that type of behavior, is weird since we will get the checkbox
already checked for us, so we are overriding it to set to false.

The behavior that should be working is that after we try and save the new server,
we should be seeing how the list gets a new line item.

==== Use EditForm to delete data

We will use the `EditForm` to delete data. In our domain, we will delete a server,
and at a technical level we will have to use the `EditForm` because we are with
Blazor SSR.

If we try and _not use the EditForm_, with code like this:

````
<button class="btn btn-primary" @onclick="@(() => DeleteServer(server))">Delete</button>

private void DeleteServer(Server server)
{
}
````

It won't work. Still it's good to breakdown what's happening here. In short, we have
this specific property that Blazor adds to Html elements `@onclick`. In here we
can simply declare a method name as the callback, or use this explicit syntax so
that we can insert a lambda function in order to pass arguments to the method call.

The reason this code won't work in SSR is because we have **NO INTERACTIVITY** at
all. This is all server side, and the `@onclick` syntax is something that assumes
we are going to handle things with javascript/code.

**IMPORTANT:** This is why we need to use our form component to submit the action
back to the server and then trigger the logic on the server side to handle this
deletion.

So the way to properly deal with our requirement under SSR we would have to
do the following:

[source, razor]
----
<ul>
    @foreach (var server in servers)
    {
        <li>
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
            <a href="/servers/edit/@server.Id" class="btn btn-link">Edit</a>
            <EditForm
                Model="server"
                FormName="@($"server-{server.Id}-form")" <.>
                OnValidSubmit="@(() => DeleteServer(server))"> <.>
                <button type="submit" class="btn btn-primary">
                    Delete
                </button>
            </EditForm>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
    private List<string> cities = CitiesRepository.Cities;

    private void DeleteServer(Server server)
    {
        if (server.Id <= 0)
        {
            return;
        }

        ServersRepository.DeleteServer(server.Id);
        servers = ServersRepository.GetServersByCity("Toronto"); <.>
    }

}
----
<.> This is an `<EditForm>` nested within another `<EditForm>`. And because this
is a multiple render piece of code, we would in theory be creating n forms per
line item, if the name is the same it would easily clash. Hence we are applying
explicit syntax on top of string interpolation to compose a _unique enough_ identifier
for the form.
<.> Hooking into `OnValidSubmit` we can then apply the lambda trick to call our
method with respective arguments.
<.> And in here the course varies with my choice, I say we simply update the state
with another retrieval of servers. The course actually injects the `NavigationManager`
and triggers a redirect to the same page. This should be more costly, wouldn't it?

In the end is the same result, but there's nuance to be taken here. We delete
a line item and somehow trigger an update to the page so that the new state is
reflected.

[NOTE]
====
Well, the course actually introduces `NavigationManager.Refresh()` which is good
to know it exists. Maybe it isn't as costly as a full-on navigation? Anywho, at
the time of the tutorial apparently Blazor had a bug and trying to call this method
resulted in an exception. Which is _interesting_. And so, as a workaround, it
actually uses `NavigationManager.NavigateTo("/servers")`.
====

[IMPORTANT]
====
Another piece of "good practices", it's explained that in theory we could literally
code a page that is just in charge of sending a delete signal to the server.
`@page /servers/delete`. Or something like that. But this is really bad because
it can easily be tampered with. Say we call it with an anchor link by passing a
server Id as a route parameter, this will be caught by the browser and a malicious
actor can literally start using it to delete all the data in the server. The form
submit is more secure, since it packages all the data under a `POST`, and the
URL and payload are not really visible. Therefore for deleting data this approach
is the recommended one.
====

With interactivity, this principle and good practices are kinda invalid though.

==== Stream Rendering

We have been using Blazor SSR. Each time we ask for something from the server
we get a response in return. One of the biggest issues of traditional web applications
and Blazor SSR as well is that if the server is under stress, then the response
from the server to the clients slows down. The UX is just waiting.

If we analyze the scaffolded `@attribute [StreamRendering]` from the `Weather.razor`
component. And remove it for testing purposes (because this attribute is specifically
there to solve this issue) we can start putting Blazor SSR to the test.

If we play around with the `NavBar` by clicking on `Home` and then on `Weather`
we will immediately pick up on a specific behavior. Even though we clicked on
the respective menu item, the screen kinda _freezes_ and it seems as though it's
stuck. (We also added a delay of 3 seconds to the code in the component that simulates
a delay responsed from the server). **This is the issue**, the UX ends up affected
negatively. We are waiting for data to come back from the server side so that
the browser renders the respective page.

Because everything renders statically, everything is retrieved from the page request.
Your hands are tied until the response comes back from the server.

[IMPORTANT]
====
However, Blazor SSR has a QoL. This is in the form of a javascript file that you can
easily point towards at `App.razor`. In there there's a line: `<script src="_framework/blazor.web.js"></script>`,
this adds a specific set of behaviors that help us get around this issue of traditional
static sites.
====

With this script, we can then add the attribute that we deleted before to test out
the "stuck" problem. And we see that even though the same delay might be there,
we get a UX that involves going into the page, and seeing some content but also a
`Loading...` message, and after the data is "available" the content gets rendered
accordingly. This is easily solvable by this sole attribute. And also the code
that takes care of showing the loading messages and then further content:

[source, razor]
----
@if (forecasts == null) <.>
{
    <p>
        <em>Loading...</em> <.>
    </p>
}
else
{
    // And in here is logic to show the Weather Forecast table
}
----
<.> As you can seem this is simple conditional rendering in case the state variable
is null, we will display some form of content and if not another form of content.
<.> This stock message of "Loading..." is displayed in case we don't have the list
of forecasts loaded just yet.

"If the data is loaded, it will show "Loading"". So for the use case of using
Blazor SSR, yet a requirement requires for you to run a long running process that
retrieves data or takes time to compute the data and you don't want that bad UX,
you should leverage this `StreamRendering` attribute and display these stock pieces
of content to feedback the user with "Loading".

=== Add Server Interactivity

==== What is interactivity

We need to answer another question first in order to answer "What is interactivity?"

_What is not interactive?_

In traditional static sites, you will send a request to the server and the server
will then respond and the whole page will be reloaded. And in certain use cases
it might feel as though you lost connection to the server for a bit. And this is
because the whole page gets packaged, gets sent, we get it back and re-render.

_The browser is doing something, and the process hangs_ **This is not smooth**.

One could argue that there **is** interactivity, between the user and the web
browser. But, when Microsoft refers to _interactivity_ in Blazor docs, it is
referencing to this idea of the UX not being _as smooth_, and this being qualified
as "not interactive".

An **interactive application** should work like a desktop application, it won't
get the whole page to get refreshed. In order to solve this issue, we can come
to one possible conclusion and that is that we should trigger a partial reload
of the page, update specific parts only. **Partial Page Rendering**, this is what
we call **_interactive_**.

_What is interactive?_

When we try to achieve partial rendering, we use Javascript. This leverages something
called the **DOM** (Document object model). The DOM is part of an HTML page, when
a user interacts with it, it is done by default, however this paradigm/idea takes
the premise that we should intercept the DOM interaction (between the user), and
once that interaction is captured, we will send a request to the backend server.

_Typically_ The Javascript would call a Restful API, wait for a response, get the
response, parse it, maybe process it a little bit and then use that data to **patch**
the DOM. When the patch is finished, we do a **partial re-rendering**, and the data
that the user expects is visualized.

_Traditionally:_ When wanting to add interactivity, a developer has to write
Javascript. However **Microsoft** provides a stock javascript that allows for the
developers to forget about writing javascript.

==== Use Enhanced Navigation in Blazor SSR for interactivity

This is the first step towards making a web app **interactive**.

We have to come clean about something though, this Enhanced Navigation is already
turned on by default on Blazor SSR, hence we are not seeing full page reloads even
when working with this stock, "simple" version of Blazor.

We can test this easily by just looking closely to how the page behaves, when trying
to press the nav bar buttons, we see that the navbar itself stays in place, we
don't get intermitent cuts that make apparent the whole page is being reloaded.

The page by default is **partially rendered**.

If we were to go to `App.razor` and delete the blazor javascript line, and then
reload the website, we can test with Dev Tools how the Network actually triggers
multiple calls, and even some interactions just break (look at the weather component).

If we analyze the Dev Tools again after adding back the blazor script. We will see
how one call is made and no other network call is detected. Another way to put this
thesis to the test is opening up the _Inspect_ section of the Dev Tools, in here
after navigating we can see how some HTML elements are re-rendered, not the whole
DOM.

**How does this work**

Whenever a user interacts with the DOM, an http request is supposed to go to the
server, but the Blazor javascript file intercepts this default behavior and then
sends a fetch to the server on its own. Once it gets back, then the Blazor script
smartly patches the DOM. (The DOM is partially rendered). With this model we reach
**interactivity**.

Blazor SSR by default with the _Enhanced Navigation_ is an **interactive application**
thanks to Blazor's javascript file in `App.razor`.

==== Use Enhanced form handling in Blazor SSR for interactivity

With the help of Enhanced Navigation, even on Blazor SSR devs can easily create
"interactive" web applications. However, this covers the navigation part of it solely.
The user can go from page to page, yet load static pages only in the end. What
if the user wants to do something _dynamic_?

I.e., If we click on the "Montreal" button on the servers page, we want to filter
all the servers in that city. This is an interaction that the user triggers on the
page, and in theory should then trigger a partial-reload of another part of the page.

With the help of **Enhanced Form Handling** even Blazor SSR can make a page dynamic.

We don't need anything fancy (no need of Web Assembly, no SignalR channel). We
can just use the `EditForm` component to achieve dynamic behaviors.

And so, first of all we are going to now start leveraging the `ServerComponent.razor`
component we created way back.

First render it in `Servers.razor`. And we will modify its code like this:

[source, razor]
.ServerComponent.razor
----
@if (server is null)
{
    return; <.>
}

<EditForm Model="server" FormName="serverComponentForm" OnSubmit="ChangeServerStatus"> <.>

    <div style="@($"color: {(server.IsOnline ? "green" : "red")}")" data-name="@server.Name"
         data-status="@(server.IsOnline ? "online" : "offline")">
        @server.Name is in @server.City that is @(server.IsOnline ? "online" : "offline")
        <button type="submit" class="btn btn-primary">Turn On/Off</button> <.>
    </div>
</EditForm>

@code {

    [SupplyParameterFromForm] private Server? server { get; set; } <.>

    private void ChangeServerStatus() <.>
    {
        if (server is null)
        {
            return;
        }

        server.IsOnline = !server.IsOnline;
    }

    protected override void OnParametersSet()
    {
        server ??= new Server <.>
        {
            Name = "Server1",
            City = "Toronto"
        };
    }

}
----
<.> Smart clean code to short circuit renders.
<.> We will leverage EditForm to submit but will add the smart/enhanced variation
for interactivity
<.> We want to bind all the form state to this model, so the respective parameter
should be set as well.
<.> And we will bind to the submisison of the form with a callback method.
<.> Lastly, we should leverage `OnParametersSet` as the hook to go into to initialize
our server, and that is because when we add the anotation for the model binding
of the form, this will be turned into a parameter, so a submission will trigger
this hook.

Now, if we try and run this as is, it won't work, because there are no fields whatsoever
inside of the form that hold values and that can then be bound to the model. We
have to imperatively add some sort of form fields, _this is hacky_.

````
<EditForm Model="server" FormName="serverComponentForm" OnSubmit="ChangeServerStatus">
    <InputNumber @bind-Value="server.Id" hidden></InputNumber>
    <InputText @bind-Value="server.City" hidden></InputText>
    <InputText @bind-Value="server.Name" hidden></InputText>
    <InputCheckbox @bind-Value="server.IsOnline" hidden></InputCheckbox>

    <div style="@($"color: {(server.IsOnline ? "green" : "red")}")" data-name="@server.Name"
         data-status="@(server.IsOnline ? "online" : "offline")">
        @server.Name is in @server.City that is @(server.IsOnline ? "online" : "offline")
        <button type="submit" class="btn btn-primary">Turn On/Off</button>
    </div>
</EditForm>
````

As you can see we are literally putting all the state fields under hidden fields,
(it's good to know that we can put a more concise type of attribute with just `hidden`).

And once we hit the submit, all these values will be bound to the respective model
properties. And after that, we will have the `OnSubmit` callback run its logic
to then modify the state variable accordingly. (And this will trigger a full page
re-render btw). Even the scroll position is lost. Logic works though.

_How do we make the page interactive?_

This is crazy dude:

````
<EditForm Enhance Model="server" FormName="serverComponentForm" OnSubmit="ChangeServerStatus">
````

Literally, one attribute `Enhance`. This could be `Enhance="true"`, but you know
how I like to be as concise as possible.

After adding this, then interactivity is figured out by Blazor without us having
to do anything fancy. Page is partially reloaded.

Again, this is all thanks to `blazor.web.js`, the script at `App.razor`.

These two features were added in `.NET 8` which is actually crazy. This is pretty
new. It's through SSR that we can achieve almost everything we want to achieve.

_But there's something even better:_ **Server Interactivity**

==== What is server interactivity?

In the previous sections we have talked about Enhanced Navigation and Enhanced
Form Handling. We have seen how interactivity is achieved.

But Server Interactivity, Server Interactive is something besides just a javascript
file that works with the DOM and backend server.

On this second paradigm, we still use the javascrip file, but the request and
responses are different. We don't work with HTTP, we work with Web Sockets, we
establish a SignalR channel.

The moment the application is loaded in the browser, the blazor javascript file
establishes this channel between the website and the server. A memory representation
of the web site on the server is created, and said memory representation will receive
all the requests coming from the website and process them respectively. One the
process is finished, a binary message will be returned to the **client**. The
JS script interprets the message, and **patches the DOM**.

The communication is different, and **THE BACKEND AS WELL BEHAVES DIFFERENTLY**.

The messages are binary, so fast, and very minimal, the whole process has been
optimized to its fullest extent (to date). Performance is not bad.

**_Render Tree:_** In the DOM (on the web browser) we have all elements grouped
together, nested and forming what it looks like a **tree**. In the backend when
the in-memory representation of the page, there's also a render tree **held in the
memory.**

The way the algorithm (really simply put) is that in-memory we will always hold a
"previous state render tree" and after processing a "new state render tree", Blazor
will calculate the difference between these two trees and package all that needs
to be updated on the web browser side so that a **smart patch** takes place. It will
only understand "one new component has been added". This has a term, "render tree
difference". The blazor javascript file understands this binary encoded difference
and acts accordingly. (Hence the user sees an update visually).

==== Enable Server Interactivity how to make a component interactive

How do we enable server interactivity?

We are going to make the `ServerComponent.razor` component interactive. (Whilst
it technically is already interactive with Enhanced Form submit, we want the actual
thing).

If we were to change the code a bit:

[source, razor]
----
@if (server is null)
{
    return;
}

<div style="@($"color: {(server.IsOnline ? "green" : "red")}")" data-name="@server.Name"
     data-status="@(server.IsOnline ? "online" : "offline")">
    @server.Name is in @server.City that is @(server.IsOnline ? "online" : "offline")
    <button type="button" class="btn btn-primary" @onclick="ChangeStatus">Turn On/Off</button> <.>
</div>

@code {

    [SupplyParameterFromForm]
    private Server? server { get; set; } = new()
    {
        Name = "Server1",
        City = "Toronto"
    };

    private void ChangeStatus() <.>
    {
        if (server is null)
        {
            return;
        }

        server.IsOnline = !server.IsOnline;
    }

}
----
<.> The `@onclick` syntax is something we use with Server interactivity.
<.> However there's an issue here, and that's that nothing will happen if we
press the button. And that is because we need to turn on Server Interactivity. Even
if you run the app in debug, breakpoints will never be hit.

How do you enable it? Just go to `Program.cs` and add these lines:

````
builder.Services.AddRazorComponents().AddInteractiveServerComponents();
// More code

app.MapRazorComponents<App>().AddInteractiveServerRenderMode();
````
**IMPORTANT:** We have to chain in a fluent way, otherwise we won't have access
to these methods.

With these two lines, we still won't get the button working. We actually have to
add this specific property:

````
<ServerComponent @rendermode="InteractiveServer"></ServerComponent>
````

The render mode will turn on or off the specific SignalR channel type of communication.

If you load the page, the button should work **and** if we analyze http requests
through the Dev Tools, no request should be getting registered. In order to see
the SignalR channel.

If we reload the web page and have a look at the _Network_ we will actually be
able to see how the website downloads the `blazor.web.js` file, and then a request
looking something like this: `ws://localhost:5116/_blazor?id=qfAbJP7iDGSOd4SIdlu6vA`
is registered. **This is the websocket handshake between the component and the
server.**

If you click on the web socket registered connection and click multiple times on the
button, you can see how the messages get logged. And even further you can see
the _byte size_ they have. These messages are the render tree differences that are
getting exchanged.

Again, in short.

. The `blazor.web.js` files negotiaties a SignalR channel between the browser
and the server. This is for the different components that work with server interactivity.
. This channel is used back and forth to send and receive information that updates
the view with interactivity.

==== Interactivity Location

After making a component interactive, by adding on `Program.cs` specific behaviors,
and by marking the component as `@rendermode="InteractiveServer", we manage to
achieve interactivity. This is what's called _Interactivity Location_.

We can add this interactivity location in different places:

- On the parent component
- On the mention of the component on the parent's code
- On the actual component itself

_If we take away the interactivity location and try and test the button, we should
prove the idea that this is what adds interactivity, and hence the workflow works_.

````
@page "/servers"

@rendermode InteractiveServer
````
This is how interactivity location at the parent level would look like. This
cascades interactivity down to all children and their own sublevels.

If not, we can go down to the actual child component and apply **the same notation**,
after that the component and any subsequent children components will have the
interactivity mode setting cascaded down the tree.

This is the **First Type of Interactivity Location**.

1. Page or component level
2. Global

The _Global level_ can be added by going into `App.razor` and then adding the interactivity
mode at the `Routes` component level that is what renders everything on our SPA.

````
<Routes @rendermode="InteractiveServer"/>
````

And here you can switch between different modes, may it be **WebAssembly, Server**.

These are the two type of locations for interactivity leveraging.

**What is recommended?**

We should specify the location at the parent level but on the explicit component
render syntax:

[source, razor]
.Servers.razor
----
<ServerComponent @rendermode="InteractiveServer"></ServerComponent>
----
This is the way. If you add it to the explicit component at its top, you can easily
clash with switching for other render mode, since it will take precedence and your code
will become _HARDER TO EDIT LATER_.

[IMPORTANT]
====
So Microsoft themselves enforce _this specific pattern of specifiying the interactivity
mode where you call the component.
====

==== Server Interactivity in Visual Studio project template

We started with a Blazor SSR template, however what happens if we start with another
mode? (_NOTE:_ The `Blazor Web App` template is the recommended one to use after
.NET 8).

You can select as a template setting to use Server Interactivity, and even set the
Interactivity location "Per Page/Component". This will start a project with the
two lines at `Program.cs` that we saw, plus all components that are pages with
the _cascading interactivity mode_. at the top of each of them. `Routes` does not
have the interactivity location, nor static pages, since they don't require interactivity
at all. Only the `Counter` page has interactivity set on, and that is because it
is required by it. So a rule of thumb is to ask yourself if the component
**really needs to be interactive**. Otherwise a static website will work just
fine.

_Extra:_ What if we select Server render mode and with Global?

Same things, but if we look at `Counter.razor`, we see no interactivity location.
That is because we will have it at the `App.razor`'s `<Routes>`' component level.
This is how the template can be used to set everything up from the start, but the
most important thing: **You know now how this works**.

==== .NET 9 Updates: Include SSR in Global Server Interactivity location

November 4th 2024 - There are a few features that have been introduced in .NET 9,
many minor with this exception:

We will use SSR, but on a Global Server Interactivity Location.

[source, razor]
----
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <base href="/"/>
    <link rel="stylesheet" href="@Assets["lib/bootstrap/dist/css/bootstrap.min.css"]"/>
    <link rel="stylesheet" href="@Assets["app.css"]"/>
    <link rel="stylesheet" href="@Assets["ServerManagement.styles.css"]"/>
    <ImportMap/>
    <link rel="icon" type="image/png" href="favicon.png"/>
    <HeadOutlet @rendermode="InteractiveServer"/> <.>
</head>

<body>
<Routes @rendermode="InteractiveServer"/> <.>
<script src="_framework/blazor.web.js"></script>
</body>

</html>
----
<.> This is another component that should get the Global Interactivity Location.
<.> And this is the Routes component with the Interactivity Location set there so
that all components get it applied.

But there could be exceptions, we could have components that are coded to work
with SSR, not interactivity, hence we want to mark them to keep using SSR. Or
perhaps we just want a couple of specific components to use it. Whilst being
under Global Interactivity Location already. (e.g., A particular component has
to be dependent on cookies. With interactivity, things are done through a SignalR
channel, this, for example, makes it impossible to rely on cookies. So we would
be forced to make the component SSR compatible and use it). 

Microsoft has thought of this use case, and has added a feature to make it easy
to do it:

https://learn.microsoft.com/en-us/aspnet/core/release-notes/aspnetcore-9.0?view=aspnetcore-9.0#add-static-server-side-rendering-ssr-pages-to-a-globally-interactive-blazor-web-app[DOCS]

We must use this attribute in the component, e.g., `AddServerComponent.razor`.
Remember that this should be done in a **ROUTABLE COMPONENT**.

[source, razor]
.AddServerComponent.razor
----
@page "/servers/add"

@attribute [ExcludeFromInteractiveRouting]
----

And lastly we should change the `App.razor` component:

[source, razor]
.App.razor
----
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <base href="/"/>
    <link rel="stylesheet" href="@Assets["lib/bootstrap/dist/css/bootstrap.min.css"]"/>
    <link rel="stylesheet" href="@Assets["app.css"]"/>
    <link rel="stylesheet" href="@Assets["ServerManagement.styles.css"]"/>
    <ImportMap/>
    <link rel="icon" type="image/png" href="favicon.png"/>
    <HeadOutlet @rendermode="@PageRenderMode"/> <.>
</head>

<body>
<Routes @rendermode="@PageRenderMode"/> <.>
<script src="_framework/blazor.web.js"></script>
</body>

</html>

@code {
    [CascadingParameter] private HttpContext HttpContext { get; set; } = default!;

    private IComponentRenderMode? PageRenderMode => HttpContext.AcceptsInteractiveRouting() ? InteractiveServer : null; <.>
}
----
<.> See how we no longer set this to `ServerInteractivity` but to a custom render mode.
<.> Likewise for `Routes`
<.> This is advanced code, we won't break it down for now, this is just copying
things from the Microsoft Docs to enable this specific feature.

At a high level, this `@PageRenderMode` is a switch under a property that will attempt
to run the `AcceptsInteractiveRouting()` extension method that will try and detect
the attribute of exclusion. If it detects it will not try and set the component
with interactivity and keep it as SSR.

==== Three main aspects of interactive components

A brief reiteration:

- The user interacts with the DOM, and the blazor javascript intercepts that
interaction.
- Because a SignalR channel has been setup from the beginning, and we now work
with in-memory representations of components on the server, this makes the application
a **stateful application**.

Once you use interactive components in Blazor, this becomes **stateful**. _At least
for that component_. The component is a stateful component.

An unstateful application is the traditional app. After a request and response,
roundtrip, the server doesn't remember the state of the application. None of
the states are remembered.

**But with interactivity**, the app becomes _stateful_. For stateful applications
there are three main aspects.

And this is in general, not specific to Blazor.

. View = User interacts with the View. The user doesn't care about components. Only
what he sees
. Event = The action on the view triggers a type of event, as developers we do
something with the information the user provided in that interaction that triggered
the event. Maybe we calculate something, get data from the database. This changes the
internal **state variables**.
. States = The handling of the events changes the state variables, the states of
the component. And when the state gets updated, the view gets updated accordingly,
hence these three concepts are closely related to each other.

Any interactive component/application. All SPA applications are stateful.

*8Remember this, it will apply to WebAssembly as well.** This is a key concept that
we should interiorize to then have a framework as to how code properly in Blazor.

==== Event Handling (Passing Data)

When you pass data inside of a event, we need to learn how to leverage Blazor.

The use case that will launch us into learning this concept is as follows:

_We want to be able to press the city buttons on the server list screen and then
filter out the list of servers in that city, move away from the hard coded "Toronto"
list_

The syntax to achieve this is pretty simple:

[source, razor]
====
<div class="card-body">
                        <button type="button" class="btn btn-primary"
                                @onclick="@(() => SelectCity(city))">@city</button> <.>
                    </div>

@code {
    private void SelectCity(string cityName)
    {
        servers = ServersRepository.GetServersByCity(cityName); <.>
    }
}
====
<.> We leverage `@onclick` and we use the explicit syntax in order to wrap a
method call under a lambda that will have the call of the method with an argument.
<.> And then the actual logic of the method will have the received parameter as
a passdown to the `ServersRepository`.

The course makes a point about interactivity not working but this is because it didn't
have the _global_ setting we applied with `.NET 9`'s update lesson before. So we
can kind skip it, however, it's mentioned again the concept of interactivity location,
and how a good practice is to have it in the page that then renders a component.

Understanding the different "settings" or "modes" of interactivity in Blazor is
key to understand and then leverage appropriately based on the use case. `(View -> Event -> State)`

Every time you work with a stateful component, we have the _three aspects_

[IMPORTANT]
====
The whole concept of stateful application and the **in-memory representation** of
a component in the server is key to remember one optimization that Blazor accounts
for. If we have loaded the state in the server, we won't be re-rendering, fetching
data all the time, the server **remembers that component's state**. It's only after
disposal that we might have to reload a component's data. Now, in **Blazor SSR**
the whole state is indeed reconstructed, but it's due to the Enhanced Form and
Enhanced Navigation that we don't see the page reloading every time.
====

InteractiveServer is technically _simpler_ than SSR. However state is kept and
optimizations take place. It looks a bit like javascript. _Simplicity is key_.

==== Assignment 4: Highlight current City

. We want to have the selected city by a click to show visually it's currently
selected
. We should leverage Bootstrap for it apparently

No idea about styling, I will leave that to the course, but the core logic is pretty
simple, and something I didn't catch on before is _why we were adding a field for
the selected city_. That is because we can leverage that to calculate which
city item is selected:

[source, razor]
====
<div class="card">
                    <img style="max-width: 150px; max-height: 150px"
                         src="@($"/images/{city}.png")"
                         class="@($"card-img-top{IsActive(selectedCity, city)}")" <.>
                         alt="Card image cap">
                    <div class="card-body">
                        <button type="button" class="btn btn-primary"
                                @onclick="@(() => SelectCity(city))">@city</button>
                    </div>
                </div>

@code {
    private string selectedCity = "Toronto"; <.>

    private void SelectCity(string cityName)
    {
        selectedCity = cityName; <.>
        servers = ServersRepository.GetServersByCity(cityName);
    }

    private static string IsActive(string currentCity, string cityName) =>
        currentCity.Equals(cityName, StringComparison.InvariantCultureIgnoreCase) ? " active" : string.Empty; <.>
}
====
<.> As you can see on the fly, per rendered item we will calculate if the specific
item corresponds to the selected city, if it does then we will add the `active`
class name, otherwise it will be empty.
<.> And it now makes sense why we have to keep the state of the selected city like
this.
<.> And of course we have to update the state based on the event.
<.> A good way to abstract code and keep the view tight, is by putting calculation
logic behind functions, _this is a good practice_. Hence this takes care of just that,
and that's also another reason as to why we leverage string interpolation so that
we can chain together text and possible calculation method calls.

==== Assignment 4: Answer

When it comes to styling, the course leverages "border primary":

````
<div class="@($"card{IsActive(selectedCity, city)}")">

private static string IsActive(string currentCity, string cityName) =>
        currentCity.Equals(cityName, StringComparison.InvariantCultureIgnoreCase) ? " border-primary" : string.Empty;
````

I actually had to change the function's position, since we are adding the border
to the whole line item, and that was on a superior level not the card image. But
yeah, pretty cool that it's simply by adding `border-primary` that we get what
we want. But it also solidifies my theory of making things easier to edit and add
later. Because this was abstracted behind a method, we simply had to change
one small line of code from `active` to `border-primary`, move around the view code
but it still kept the behavior and it was way easier to read.

[NOTE]
====
The course uses `StringComparison.OrdinalIgnoreCase`, is this better? is this worse?
The answer is not as cookie cutter:

Avoid `CurrentCultureIgnoreCase` in most library/business logic code — it depends
on the user’s local culture and can introduce subtle bugs. Save it for UI-facing
string handling only. So in this specific use case it should be fine, you can argue
that `OrdinalIgnoreCase` is slightly faster and catered towards `identifiers`,
`technical data`, `keys`, `performance-critical paths`.
====

==== Update, state variables with Onchange event

_Remember of the 3 aspects_ **AGAIN**

We will study `onchange` another event handler that we can leverage, it's a bit
similar to `onclick` but with its specific quirks. It's also a window into data
binding.

We will use another requirement to introduce this concept: `we want a search bar
so that we can search for servers`.

[source, razor]
====
<div class="input-group mb-3">
    <input type="text" class="form-control" placeholder="Search Servers" @onchange="HandleServerFilterChange" /> <.>
    <button class="btn btn-outline-secondary" type="button" id="search-button">Search</button> <.>
</div>
@serverFilter

@code {
    private void HandleServerFilterChange(ChangeEventArgs e) => serverFilter = e.Value?.ToString() ?? string.Empty; <.>
}
====
<.> We will hook the `@onchange` to a control directly, and we will have to pass a
callback to it that we also declare.
<.> The button itself has just different styling, but also the fact that it's not
of `submit` type.
<.> This is the callback function, when we hook it up to something like `@onchange`
it will automatically gain the `ChangeEventArgs` argument attached to it, and we
can leverage this object to then run logic, this function is pretty simple, if there's a
value captured it will assign that to a new state variable we declare if not it will
default to an empty string.

It's worth noting that the way `@onchange` triggers is when the control loses
focus, it's only then that our callback will get invoked.

[source, razor]
====
<button class="btn btn-outline-secondary" type="button" id="search-button" @onclick="HandleSearch">Search</button> <.>

@code {
    private void HandleSearch()
    {
        servers = ServersRepository.SearchServers(serverFilter);
        selectedCity = string.Empty; <.>
    }
}
====
<.> We want to stay consistent on naming so the `@onclick` callback should be
prefixed with `HandleSearch`.
<.> And lastly we will extend the requirements and functionality a bit, in the sense
that if we search for a server name we will stop marking an active selected city
and we will also filter the state variable so that only the specific server comes
up.

[NOTE]
====
A nice way of grouping together controls and labels is with bootstrap's `input-group`.
It's good to keep that in mind.
====

The way that the filter works is actually by partial string comparison, hence if we
search for something like `Server1` we will get all servers that have that partial
string at the beginning.

The click on the city name should still work fine, we shouldn't have to worry
about breaking anything.

_Small comment:_ Leveraging `@onchange` hits me as performant heavy, but I don't
know just yet. We'll see.

==== Two way data binding

Previously, we handled an event, and with that event we updated state. This is
how it works normally, but there's something better "data binding".

The value comes from the view to the state: Any change in the view will come back
to the state automatically, _this is called two-way databinding_.

The way to setup this is pretty simple with a really specific thing to keep in mind:

````
<input type="text" class="form-control" placeholder="Search Servers" @bind-value="serverFilter">
````

This syntax looks similar to the SSR Form syntax with one key difference the `value`'s
`v` is actually **lowercase**. In this specific way, this can enable us to bind to
a whole model.

And just like that we can delete the event handler that we created before, and test
out the same workflow and it should still work flawlessly.

_What happens behind the scenes?_

Blazor actually is leveraging the same event we hooked into. But Blazor is doing
that for us. With a `bind-value` it creates the `OnChange` event handler behind
the scenes.

**NOTE:** Sometimes you want to do something when the server filter is set, you
may want to intercept when a value is about to be added to state, in a event handler
setup we can easily intercept and apply custom logic, however with two way databinding
this is no longer possible, unless we use a property:

[source, csharp]
====
private string _serverFilter = string.Empty;
private string serverFilter
{
    get => _serverFilter;
    set
    {
        // Logic before or after
        _serverFilter = value;
    }
}
====
This requires for a backing field and this specific type of setup, but in the end
you will be binding directly to a state variable. The only caveat here might happen
with async use cases, but there are workarounds even there.

**NOTE 2: ** You might want to add more feedback for the user to see as he types
the filtered item, this can be done with a variation of the property:

````
@bind-value:event="oninput"
````
With this setup, then the property will be invoked on every key stroke that is pressed
on the control.

The app will react to every single input and we get instant feedback, so this is
a pretty interesting feature, but I think we should debounce this, performance
heavy. (The premise overall is that MS wants to make your life easier).

==== Interactive EditForm

We used the `EditForm` for SSR. With interactivity this changes a bit.

If we head down to the `AddServer.razor` file, depending on if it has interactivity
location or not, the `<EditForm>` component can now have its `FormName` removed.
It can still have it, but it's not necessary. Secondly, we don't need to specify
the `[SupplyParameterFromForm]`. Why is that? Simply put, because the form will now
be wired as interactive, it won't submit a POST to the server, it will follow
the SPA approach which is to send SignalR signals to the server. The attribute itself
implies that there's a form submission of some kind. But here with interactivity there's
no form submission anymore.

So basically, in case you coded something with SSR and want to move into interactivity
the process is not as painful, you don't have to change `bind-Value` because the
controls will be under `<EditForm>` and the wiring behind the scenes accounts for it
and we don't have to worry about anything.`

==== Use @key to improve list-rendering performance

We want to use the `@key` directive to improve list rendering performance.

Basically, as things stand right now, we have the `Servers.razor` page with a
`@foreach` directive that creates DOM elements based on a collection. But if we
actually test out with the Dev Tools of the browser, say an ad-hoc test workflow
that adds a new server to this collection. (Under the assumption that we are in
a page with interactivity), we can easily see how the DOM updates **all elements**,
Blazor apparently can't really patch only a specific item and re-renders the whole
list.

[NOTE]
====
Depending on the use case, on performance critical applications, this will tank
the UX without a doubt. Luckily we can leverage the `@key` directive to sort of
give Blazor more meta-data so that its difference calculation algorithm is smarter
and patches surgically the elements into the DOM.
====

````
@foreach (var server in servers)
    {
        <li @key="server.Id">
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
            <a href="/servers/edit/@server.Id" class="btn btn-link">Edit</a>
            <EditForm
                Model="server"
                FormName="@($"server-{server.Id}-form")"
                OnValidSubmit="@(() => DeleteServer(server))">
                <button type="submit" class="btn btn-primary">
                    Delete
                </button>
            </EditForm>
        </li>
    }
````
With this specific `@key` attribute, and we try to add a new element, the DOM
will be patched smartly. Be sure to use some form of data that is unique so that
Blazor doesn't clash between values and we lose the performance gain we are
aiming for. That's why this is a **best practice**.

**IMPORTANT:** This directive can be used in list elements `<li>` and table elements
as well. That is because these HTML elements are the one-to-one mapping of collection
line items.

==== Use Virtualization to improve list-rendering performance

Let's expose another possible issue in a specific scenario and a way to deal
with it.

_What if we have a lot of line items, in the thousands or ten thousands?_

When rendering a piece of DOM and the elements are a ton, the browser stalls
(regardless of how fast the PC is). You can easily run into this UX affecting
issue.

_How to solve this?_

Blazor has **virtualization**. This will replace a `@foreach` loop. But only if
three conditions are met:

. You have too many items.
. You are analyzing a foreach loop structure
. The rendered items are of the same height

If you only have hundreds of items, `@foreach` is better. Try to use virtualization
for big collections.

[source, razor]
----
<ul>
    <Virtualize Items="servers" Context="server"> <.>
        <li @key="server.Id">
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
            <a href="/servers/edit/@server.Id" class="btn btn-link">Edit</a>
            <EditForm
                Model="server"
                FormName="@($"server-{server.Id}-form")"
                OnValidSubmit="@(() => DeleteServer(server))">
                <button type="submit" class="btn btn-primary">
                    Delete
                </button>
            </EditForm>
        </li>
    </Virtualize>
</ul>
----
<.> `Virtualize` is a built-in component that Blazor exposes. By leveraging its
attributes you can easily map it to work with the collection that might have been
expanded with a `@foreach`. And just like that, painlessly, you get a way faster
render time for the collection. (No more stalls). 

[NOTE]
=====
What is actually happening? Behind the scenes Blazor takes care of a lot here.
It knows the height of each item and it knows the viewport, and it knows how many
items need to be rendered and it only renders those items. It won't render all of
the collection items. The more the user scrolls further, it will then start replacing
the items that are not rendered with new items, it's smoke and mirrors overall,
but abstracted and ready to consume. We don't have to re-invent the wheel. It
also knows about the `@key` principle and it auto adds it respectively we don't
even have to worry about that.
=====

=== Course Project (Part 1): To-Do List App Basics

==== Requirement of To do list app

We will put all of our knowledge to the test by building a simple app and applying
all the concepts we got introduced. This is a To-do list app, and it has the
following requirements:

. Display a list of tasks (we need to take ordering into account, completed tasks
are higher priority)
. Add Task (click event)
. Input task (two-way data binding)
. Mark task as completed (we can't edit the task further, and we should mark the
completed date)

Advice:

. Think of each use case, one at a time
. Have a framework that simplifies development (Bootstrap)

==== Display a list of tasks use case

Will use the same project, don't wanna create a new repository and all the hassle.

The requirements ask for:

- A text with the to do item
- State of completed or not
- Completed date

[IMPORTANT]
====
If you have issues, you can turn on a debug flag by changing the `appsettings.json`
file: `"DetailedErrors": true,`. Just add that at as a first class property and you
will get more info inside of the browser that helps with debugging way easier.
====

[NOTE]
====
Hot reload doesn't really work. Not really, a simple page add, and render foreach
content on it, just doesn't work. It literally forces you to go and reload things
manually. Don't really like that at all. (Apparently Visual Studio _of course_
has the better hot reload support).
====

Possible solution: `dotnet watch run --no-hot-reload` run this.

_Reconciling course and own solution_

The requirement wants to use a list item, I chose to override defaults so that
we don't get bullet points:

````
ul,
ol {
    list-style: none;   /* remove bullets/numbers */
    margin: 0;          /* reset default margins */
    padding: 0;         /* reset default padding */
}
````
And this was under: `ToDoList.razor.css`.

We have a model, a repository, the razor page for the to-do-list. The course copies
the repository, I implemented a more lean approach.

The course also reminds us of `_Imports.razor`.

**NOTE:** A good point in the course, it controls if the list is actually populated,
if not, we should just skip over rendering code:

````
@if (!_todoItems.Any())
{
    return;
}
````

The course doesn't even go further into actually implementing the Form Control yet
it just focuses on a list of the To-Do items. That's fair, but this is code that
actually does two-way binding and also ripped out of Bootstrap docs, it's literally
the exact UI that was presented as the final result:

https://getbootstrap.com/docs/5.3/forms/input-group/#basic-example[Docs]

[source, razor]
----
<ul class="todo-list">
    @foreach (var item in _todoItems)
    {
        <li @key="item.Id">
            <div class="input-group mb-3">
                <div class="input-group-text">
                    <input @bind-value="item.IsComplete" class="form-check-input mt-0" type="checkbox" <.>
                           aria-label="Checkbox for following text input">
                </div>
                <input @bind-value="item.Text" type="text" class="form-control" aria-label="Text input with checkbox"> <.>
            </div>
        </li>
    }
</ul>
----
<.> As you can see we bind the `bool` property of the line item directly to its respective
rendered control.
<.> And the `Text` property is also bound to the respective control.

==== Add Task use case

- Add a button by the top of the list. When clicking, we will be able to add a new
task.

(My choice): Add a dummy, somehow add for this newly added element a placeholder
text stating (Add the text here...) or something like that.

This is the code:

[source, razor]
----
<button @onclick="AddTodo" class="btn btn-primary mb-3">
    Add Task
</button>

<input @bind-value="item.Text" placeholder="@(CalculatePlaceholder(item.FreshAdd))" type="text" <.>
                       class="form-control" aria-label="Text input with checkbox">

@code {
    private string CalculatePlaceholder(bool freshAdd) => freshAdd ? "What do you want to do?" : string.Empty; <.>

    private void AddTodo()
    {
        TodoItemsRepository.Add(new TodoItem
        {
            FreshAdd = true, <.>
        });
    }
}
----
<.> Focus on `placeholder`, we are abstracting away code to calculate this text
since depending on state it should display a placeholder for better UX.
<.> We basically added a new property to the line item's class, this is something
that will help us display a placeholder for newly added tasks with the button to
add new items to the list.
<.> And we set this flag property to `true` only when they are coming from the
button click event.


_Course content_

- Course makes note of adding the Render Mode.
- It also already shows how the repo takes care of ordering, the priority is "IsCompleted"
and **then** "Id". So, not completed tasks will actually be displayed at the top,
_newly added tasks will be at the top_.

==== Input task name use case

This is something we already implemented I'm pretty sure. Still, it's interesting
to see how there are different ways to tackling the problem.

_Course content_

The course definitely deviates, but we can attribute that to unclear requirements.
It takes away border with a `border-0` class, and it also doesn't get rid of the
bullet points.

==== Mark task as completed use case

This is probably the most complicated use case.

. Dislay the checkbox, and allow the user to check and not check.
. We need to populate the completed date. And if unchecked this needs to be
also cleaned and not displayed anymore.
. The control should also be disabled since it's completed

This is the code to achieve the requirements:

[source, razor]
----
<input @bind-value="item.Text" disabled="@item.IsComplete" <.>
       placeholder="@(CalculatePlaceholder(item.FreshAdd))" type="text"
       class="form-control" aria-label="Text input with checkbox">
@if (item.IsComplete)
{
    <div class="p-3">
        <text>
            Completed Date: @($"{item.CompletedDate:D}") <.>
        </text>
    </div>
}
----
<.> We are actually leveraging `disabled` and implicit syntax to then turn on
or off the input field with concise code.
<.> This is another cool pattern to use. Besides the conditional rendering just in
case the line item is completed, we are also applying `format specifiers`, that on
string literals can help format dates with a pretty concise and clean syntax. The
`D` code is for a human readable "long date". Exactly what the course applies with
not so clean code.

_Note:_ It's also worth mentioning that we did apply fields and properties to
to intercept the change of the two-way bound `IsComplete` property. So that we
can add on the fly the completed date (that is set to that precise moment `DateTime.Now`).

It's nice that two-way data binding integrates with these other patterns nicely
without the need to learn even further.

=== Non-Routable Razor Component Deep-Dive

This is now introducing the idea of **thinking in components**.

This means that we are going to break a monolithic view into multiple components,
all of this in the spirit of _separation of concerns_. Meaning that it's easier
to maintain the code, easier to extend. (Makes editing in the future easy).

There are different principles to provide guidance:

- SRP (Single Responsibility Principle). If a component needs to change for
multiple reasons, then that component might be responsible for too many things.
If we make to many changes within the component, we might start looking at
refactoring.

Theory and its application can get messy, and its most of the time up to interpretation,
but we will follow for our project the idea of: "We will try and aim for our components
to do one specific task"

**The List of Cities**: Currently it's doing **two things**. One is displaying a
list of cities, and then displaying each city component.

**Search servers**: One component to search

**List of servers**: Has a list of servers, the add button, the actual line items.

**Thinking in components:** Is this ability to look at a screen and know what components
should be built, how to break down a screen in short.

This is an ability that should be trained, and is required to be proficient at.

==== Thinking in Components

The server management page will be broken down into multiple components. For the
first broken down component we will do a `ServerListComponent.razor` file addition
and literally carve out all the `ul` view code to it, and comment out things that
end up broken due to us moving away highly coupled pieces of code.

==== Extract the ServerList Component

Something the course focuses on is the fact that our custom components that we
create will also need the interactivity mode set to them, don't forget the syntax
that allows for interactivity to work and for us to leverage its capabilities:

````
<ServerListComponent @rendermode="InteractiveServer"></ServerListComponent>
````

The benefits of separating the code like this is simply to make it easier to
edit in the future. Less code for HTML and backend in the parent component, and
if an issue arises we know where specifically to go to debug.

````
private void DeleteServer(Server server)
{
    if (server.Id <= 0)
    {
        return;
    }

    ServersRepository.DeleteServer(server.Id);
    // servers = ServersRepository.GetServersByCity("Toronto");
    NavigationManager.Refresh(forceReload: true); <.>
}
````
<.> When trying to use the `NavigationManager` on the separated component this
line of code will look as if it doesn't work, we will later discuss how to fix this
properly, but for now, we will simply make it so that the router actually triggers
a full-on browser reload. This is bad, we are losing the SPA benefits and we can
easily introduce bugs due to state ending up lost. But for know, we will live
like this.

==== Use Component Parameters to communicate from parent to child components

Now that we have components, we need to think about how we communicate data across
them. _One way is **component parameters**_.

Looking at a workflow such as:

- Parent Component
- Child Component

We have components that will hold inside of them (orchestrate) child components.
And this parent component will need to somehow send this data from one component
to the other. Based on events, signals will have to be wired.

If we go to `ServerListComponent.razor`, we can add a property with a specific
decorator so that we allow for it to take a property from a parent component:

````
[Parameter]
public string? CityName { get; set; }

private readonly string FALLBACK_CITY = "Toronto";
private List<Server> servers = [];

protected override void OnParametersSet()
{
    servers = ServersRepository.GetServersByCity(CityName ?? FALLBACK_CITY);
}
````
This is using best practices, we have a fallback city name in case we don't get
a paremeter back from a parent. Otherwise we will use the hook in which we are
sure a parent has fed us (or we at least should have an actual value coming from
the parent). `OnParametersSet()`. And there we can run logic with the parameter's
value.

And on the parent:

````
<ServerListComponent CityName="@selectedCity"></ServerListComponent>
````

In short, we should be able to go to the screen and check if the switching of
the servers by city is now working as it was before.

How does this work?

. At the parent we have a `selectedCity` property that we update on each click on
one of the cities.
. This same value is now hooked into the child component, and each time a new value
is fed to it we run the logic to change the line items based on the parameter's
value

And so in short, we pass data from a parent to a Child so that the Child then
gets to run its own logic, effectively abstracting and separating by concern,
really cool, really simple, **simple**. _Don't forget about this type of pattern_.

==== Assignment 5: Extract the Server Component

We established at the beginning that we will have a second component extracted and
that is for one line item of the list. Further abstraction, and better approach.
Our task is to have the logic that lives in `ServerListComponent.razor` for the
line item rendering be in its own component. This of course has to leverage
Parameters.

We created at the very beginning a `ServerComponent.razor` component, at the time
it was only for testing purposes. But now we will replace its content with the
logic of an actual line item.

[source, razor]
.ServerListComponent.razor
----
<ul>
    <Virtualize Items="servers" Context="server"> <.>
        <ItemContent>
            <ServerComponent Server="@server"></ServerComponent> <.>
        </ItemContent>
        <Placeholder>
            <text>Loading...</text> <.>
        </Placeholder>
    </Virtualize>
</ul>

@code {
    [Parameter] public string? CityName { get; set; }

    private readonly string FALLBACK_CITY = "Toronto";
    private List<Server> servers = [];

    protected override async Task OnParametersSetAsync()
    {
        servers = ServersRepository.GetServersByCity(CityName ?? FALLBACK_CITY);
    }

}
----
<.> The Virtualize smart component from Blazor has extra features that we can
leverage.
<.> We can put on the rendered line item piece of code under an `<ItemContent>`
our code for each item that will be rendered smartly.
<.> And then _in theory_ we can put under `<Placeholder>` code that will be rendered
as items are fetched on the list for `Virtualize`. Alas, this doesn't seem to work....

It's on the line item component that things should be rendered as so:

[source, razor]
.ServerComponent.razor
----
@inject NavigationManager NavigationManager

@if (Server is null)
{
    return; <.>
}

<li @key="Server.Id">
    @Server.Name in @Server.City is
    <span style="color: @(Server.IsOnline ? "green" : "red")">
        @(Server.IsOnline ? "online" : "offline")
    </span>
    <a href="/Servers/edit/@Server.Id" class="btn btn-link">Edit</a>
    <EditForm
        Model="Server"
        FormName="@($"Server-{Server.Id}-form")"
        OnValidSubmit="@(() => DeleteServer(Server))">
        <button type="submit" class="btn btn-primary">
            Delete
        </button>
    </EditForm>
</li>

@code {
    [Parameter]
    public Server? Server { get; set; } <.>
    
    private void DeleteServer(Server Server) <.>
    {
        if (Server.Id <= 0)
        {
            return;
        }

        ServersRepository.DeleteServer(Server.Id);
        // Servers = ServersRepository.GetServersByCity("Toronto");
        NavigationManager.Refresh(forceReload: true);
    }
}
----
<.> Never forget good practices
<.> We will get one line item object back so that the component can then render
its respective content
<.> And we will also bring in the deletion method that used to live at the parent
level.

After this surgical extraction and componetization, this should be _easier to
maintain_. As well as adhere to best practices.

==== Assignment 5: Answer

[IMPORTANT]
====
If you place inside of a parent with interactivity configured to it a child component,
**The Child also inherits interactivity**. Hence we don't have to specify at all
the `@rendermode` property again.
====

Basically, what I implemented. So, cool. There's still that `Loading...` issue.
We are not hitting this placeholder text condition at all.

==== Extract city components

After extracting the list of servers and the line item, we are now going to apply
the same principle to the Cities side.

So, on the parent component (page) we will basically start cutting out the code
that renders the list of cities and each line item:

[source, razor]
----
<h3>Servers</h3>
<br/>
<br/>
<CityListComponent></CityListComponent> <.>
<br/>
----
<.> In the end all the logic should be abstracted behind one specific component.

The list component will also have its own child components (line items):

[source, razor]
----
<div class="container-fluid text-center">
    <div class="row w-50">
        @foreach (var city in cities)
        {
            <CityComponent City="@city" SelectedCity="@SelectedCity"></CityComponent> <.>
        }
    </div>
</div>

@code {
    private string SelectedCity { get; set; } = "Toronto"; <.>
    private List<string> cities = CitiesRepository.Cities;
}
----
<.> As you can see we are passing down from the list component (a sort of second-class
parent component), one name for the respective iteration render alongside a state
variable that keeps in check which option has been selected in the UI.

Lastly the line item component:

[source, razor]
----
<div class="col">
    <div class="@($"card{IsActive(SelectedCity, City)}")">
        <img style="max-width: 150px; max-height: 150px"
             class="card-img-top"
             src="@($"/images/{City}.png")"
             alt="Card image cap">
        <div class="card-body">
            <button type="button" class="btn btn-primary"
                    @onclick="@(() => SelectCity(City))">@City</button>
        </div>
    </div>
</div>

@code {
    [Parameter] public string SelectedCity { get; set; } = string.Empty; <.>
    [Parameter] public string City { get; set; } = string.Empty;
    
    private void SelectCity(string cityName)
    {
        SelectedCity = cityName; <.>
    }

    private static string IsActive(string currentCity, string cityName) =>
        currentCity.Equals(cityName, StringComparison.InvariantCultureIgnoreCase) ? " border-primary" : string.Empty;
}
----
<.> Notice how we have as a parameter property the `SelectedCity` property.
<.> And in here we have a callback that updates the respective property. This however
fails to meet the requirements (it breaks the previous working behavior), and that
is because we should notify the parent of a change in the selected city and then
the parent should take care of sending down to the respective childs the updated
information so that the workflow works again.

With this in mind we will tune the `SelectCity` event callback so that we can
notify the parent from the respective child so that the state is changed and the
parent replicates that info to all other children so that the UI behaves correctly.
(i.e., We have the border for the corresponding city).

==== Use EventCallback to pass info from a child to parent components

We have to solve two broken behaviors:

. The listing of respective servers per city is broken
. The highlighting of a selected city is also broken

We need to highlight that we have 2 levels of nesting here, a grandparent, parent
and child chain of component interactions, and it's within this section that we
will see how to communicate information across all these levels effectively.

**Event Callback:** This is supposed to be used by the child component of a component
tree. At the `CityComponent.razor` file we have to create an event callback to notify
the parent.

To fix the first issue we need to introduce the usage of the `EventCallback`

````
[Parameter] public EventCallback<string> SelectCityCallback { get; set; } <.>

private async Task SelectCityAsync(string city)
{
    await SelectCityCallback.InvokeAsync(city); <.>
}
````
<.> We basically stick to the concept of `Parameter` but the kicker here is this
special _Blazor_ type called `EventCallback`. In this instance it encapsulates a
delegate that takes one string parameter.
<.> We are coding the granson's component code to catch the selection event all
the way down the component tree to then invoke the passed down callback from the
parent. The parent should have this method registered under its own state, and
so the moment we run the method in a child, the parent component's code will get
executed under his own context. This trick is a really powerful concept to keep in mind.

````
<CityComponent City="@city" SelectedCity="@SelectedCity"
                           SelectCityCallback="HandleCitySelection"></CityComponent> <.>

@code {
    private void HandleCitySelection(string cityName)
    {
        SelectedCity = cityName;
    }
}
````
<.> Notice how we are passing the method as its signature, no execution of the
method. It is with this that we establish this link/resource that can be passed
from a parent to a child and the child get a way to send a signal back to him.

This fixes the highlighting for sure, since the parent gets back a signal to
update the selected city and that trickles down to the children components.

[NOTE]
====
EventCallbacks have by default only an async `InvokeAsync`, hence we delve into
async programming, however one key element here for cancellation is `CancellationToken`.
Blazor components don't seem to get this injected by default, so we have to manually
create them and then pass them down in every possible call so that we cancel async
calls if the component is destroyed and things alike. Also, this is a **Blazor
thing**. We don't have to apply the usual C# safe-guards checking for a null.
====

The way to solve the second broken behavior will be solved with _double bubbling_,
meaning from a grandson to a parent, a parent to a grandparent. (_This is a really
bad practice, but for now let's keep it this way).

.CityListComponent.razor
````
[Parameter] public EventCallback<string> SelectCityCallback { get; set; }

private async Task HandleCitySelectionAsync(string cityName)
{
    SelectedCity = cityName;

    await SelectCityCallback.InvokeAsync(SelectedCity);
}
````

.Servers.razor
````
<CityListComponent SelectCityCallback="HandleSelectedCity"></CityListComponent>

private void HandleSelectedCity(string cityName)
{
    CityName = cityName;
}
````

As you can see, it's just the same concept applied but twice, when the parent
component gets the signal from the child, it then sends a signal to the grandparent
with the same info that he got from the **child**.

==== Assignment 6: Componentize the search bar

We will work on componetizing the search bar.

. The search bar is inside `Servers.razor` we need to make it its own component.

This is a bit... weird. In the sense that the current architecture is making us
add different things that are not easier to clean later. I think a good guiding
principle for separating logic for components is:

[IMPORTANT]
====
We need an Orchestrator. Someone who takes signals from all sorts of places and
sort of makes sense of them and puts them together, of course this can lead
towards child components executing their own logic based on that idea, but we
shouldn't be making one child component _over-listen_ to events from others, he
should only care about the specific functions it provides to the greater whole.
====

And so the search bar component would be something like this:

[source, razor]
----
<div class="input-group mb-3">
    <input
        type="text" class="form-control"
        placeholder="Search Servers"
        @bind-value="SearchFilter"
        @bind-value:event="oninput">
    <button class="btn btn-outline-secondary" type="button" id="search-button" @onclick="HandleSearchAsync">Search</button>
</div>

@code {
    [Parameter] public EventCallback<string> OnSearchCallback { get; set; } <.>

    private string SearchFilter { get; set; } = string.Empty;

    private async Task HandleSearchAsync()
    {
        await OnSearchCallback.InvokeAsync(SearchFilter); <.>
    }
}
----
<.> The previous code that was in `Servers.razor` has been tuned to fit within the
idea that this is now its own component and state is leveraged through EventCallbacks
alongside `[Parameter]`.
<.> Notice how this is an async variation and the `@onclick` integrates just fine.

The code at the grandparent component will take the signal and then send back
another in the form of special flag values in the `ServerListComponent.razor`:

````
<SearchBarComponent OnSearchCallback="HandleSearch"></SearchBarComponent>

private void HandleSearch(string searchName)
{
    CityName = string.Empty;
    SearchName = searchName;
}
````
Notice how this is making the `CityName` an empty string and then `SearchName`
receiving the value from the `SearchBarComponent`.

These two parameters are being sent down, and then some logic is run so that based
on their values we run normal servers by city logic or other type of logic that
will search based on a search term:

[source, razor]
----
protected override void OnParametersSet()
{
    if (CityName?.Equals(string.Empty) ?? false)
    {
        servers = ServersRepository.SearchServers(SearchCity!);
        return;
    }

    servers = ServersRepository.GetServersByCity(CityName ?? FALLBACK_CITY);
}
----
If the `CityName` is empty, then this means that we are on the search workflow,
hence we run a different code path, otherwise, this is a default city name
workflow. We are applying else-less and return-early as good practice.

==== Assignment 6: Answer

Yeah, what I did, with two additions

- Don't forget we can check for a string with `string.IsNullOrEmpty()` and `string.
IsNullOrWhiteSpace`. That's cleaner.
- A slight bug was introduced, if we search by a filter name, and then try to switch
again to a city's server list it won't switch, and that is because we have to
reset the search filter in order for the code path to go back to the default
city name list workflow.

But yeah, the course also makes usage of this _slightly convoluted way_ of dealing
with two different workflows through the usage of extra parameters and flag values.

==== Reference a child component

Currently everything works, but there are some issues we can iron out. One of them
is the fact that when we filter out servers by city and then try and search by a
filter, the previously selected city _stays marked as selected_. That type of feedback
is confusing, so we'll try and fix that. **Also**, we should clear the search filter
if we select a city.

Since these states/behaviors belong to child components. We need a way to sort of
grab hold of them and make them update their status. Luckily parents have a way
of referencing child components and executing methods inside of them.

And so, we need to modify two places:

[source, razor]
.CityListComponent.razor
----
public void ClearSelection()
{
    SelectedCity = string.Empty;
}
----
A simple method that will be added to the component so that we can clear the
selected city and the border disappears as a result.

And in the grandparent:

[source, razor]
.Servers.razor
----
<CityListComponent @ref="CityListComponent" SelectCityCallback="HandleSelectedCity"></CityListComponent> <.>

@code {
    private CityListComponent CityListComponent = null!; <.>

    private void HandleSearch(string searchName)
    {
        CityListComponent.ClearSelection(); <.>
        CityName = string.Empty;
        SearchName = searchName;
    }
}
----
<.> The way to tie a component to a reference is with `@ref`.
<.> Of course, the reference needs to be stored in a reference variable/state
variable, hence this will be of the respective type (don't forget these components
are in the end classes). And we apply this specific syntax so that we state that the
component will not be null, the reference will be attached once the child component
gets rendered correctly.
<.> And as a simple class method call we can invoke the method we created at the
child component so that we trigger the desired logic.

And with this, the selected border will disappear since we are now sending a signal
from the parent to the child so that it updates its own state (and in turn its own
visuals).

As a mini-assignment we can now apply this same concept but now to clear the
search bar filter based on a city selection:

````
<SearchBarComponent @ref="SearchBarComponent" OnSearchCallback="HandleSearch"></SearchBarComponent>

@code {
    private SearchBarComponent SearchBarComponent = null!;

    private void HandleSelectedCity(string cityName)
    {
        SearchBarComponent.ClearSearchFilter();
        SearchName = string.Empty;
        CityName = cityName;
    }
}
````
As you can see, this is the same principle, yet with the `SearchBarComponent`
now being referenced and then having a method called from its parent.

This is yet **another way to communicate with your child component from a
parent's perspective**.

==== Reuse routable component as non-routable component

Let's learn about re-usage of components (pages).

Our requirement is pretty straightforward:

At the `ServerComponent.razor` level, we have a button that triggers a navigation
to an edit page, but we want to actually render that very same page on the same
screen of this component. You can do something like this:

[source, razor]
.Servers.razor
----
<button type="button" @onclick="@(() => EditingServer = !EditingServer)" class="btn btn-link">Edit</button> <.>

@if (EditingServer)
{
    <br/>
    <ServerManagement.Components.Pages.EditServer Id="@Server.Id"></ServerManagement.Components.Pages.EditServer> <.>
}

@code {
    private bool EditingServer { get; set; }
}
----
<.> And so we can change the button that previously just did a full routing emission
to a simply `@onclick` handler.
<.> Based on a state variable we can then choose to render a specific component,
and this as you can see is a fully qualified name, and also receives and is consumed
as any regular component.

[NOTE]
====
The course makes a highlight here stating that this code won't be used, it was simply
to demonstrate how we can put routable components inside simple components. I should
add my own take here as well, _I don't think this is recommended nor clean_, specially
the visual clutter that is added by having to fully qualify the component.
====

==== Use if statement to output data conditionally

Currently the code that we implemented already has `@if`. However, let's take a
more in-depth look at it in order to really understand the potential it holds.

_Requirement_: We want a button to turn on/off the online status of a server on
the lits.

The course applies an `@if` so that we can render a button that's green or red
in essence depending on the status. And it then takes care of turning it off or
on with a callback. Code is a bit like this:

````
<span class="me-2" style="color: @(Server.IsOnline ? "green" : "red")">
        @(Server.IsOnline ? "online" : "offline")
</span>
@if (Server.IsOnline)
{
    <button class="btn btn-outline-danger">
        Turn Off
    </button>
}
else
{
    <button class="btn btn-outline-success">
        Turn On
    </button>
}
````
My issue with this code is that it's too verbose, we can definitely abstract away
so that we don't repeat so much.

[source, razor]
====
<button class="@($"btn btn-outline-{CalculateButtonType(Server.IsOnline)}")" @onclick="UpdateServerStatus"> <.>
    @(CalculateButtonText(Server.IsOnline))
</button>

@code {
    private static string CalculateButtonType(bool isOnline) => isOnline <.>
        ? "success"
        : "danger";

    private static string CalculateButtonText(bool isOnline) => isOnline <.>
        ? "Turn Off"
        : "Turn On";

    private void UpdateServerStatus()
    {
        if (Server is null)
        {
            return;
        }

        Server.IsOnline = !Server.IsOnline;
        ServersRepository.UpdateServer(Server.Id, Server); <.>
        NavigationManager.Refresh(forceReload: true);
    }
}
====
<.> As you can see we have one method to which we feed the `isOnline` data and
based on that we calculate a part of a string that will dictate if the button looks
green or red.
<.> This method follows the same principle as the previous method, but this calculates
the label text instead of a the class name.
<.> Lastly, we have a callback on the button that due to the binary nature of booleans
can respond to the same workflow (making the code more concise). In this we just
update the component's object state, and then send that to the actual _Repository_
and trigger a manual page reload (we are going to solve this later this is bad and
can lead to bugs since we are moving away from the SPA approach).

[IMPORTANT]
====
By playing around a bit with the code and stuffs came across an interesting behavior that
I should highlight. The code with `UpdateServer(Server.Id, Server)` and `NavigationManager.Refresh`, 
**is not necessary**. The reason being that we are working with a static list that
lives in memory. All the objects that are returned to the parent and then cascaded
to the children pass those same objects by reference. If a child modifies that same
object, then the state gets replicated automatically for all the application (since
everyone is looking at the same object). So that's cool, but the moment we switch
to a database this behavior will completely break and will result in tons of bugs.
This also leads me to the hypothesis that our "edit" is actually not necessary to
have a repo method called since the screen will be manipulating the same object
by reference.
====

==== Assignment 7: Display people online

Requirement: _Display the number of people online_

We should display a random number (only if the server is online), this number
should represent the amount of people that are currently being served by the
n-th server.

Solution is again, trying to write really senior code:

[source, razor]
====
@if (Server.IsOnline)
{
    <text>@(GetRandomPeopleNumber())</text> <.>
}

@code {
    private static string GetRandomPeopleNumber()
    {
        var randomInt = new Random().Next(minValue: 1, maxValue: 15); <.>

        return $" ({randomInt})"; <.>
    }
}
====
<.> Since the assignment says that we don't care about this number at all, then
the responsibility will be offloaded to a _ephemereal_ value that is calculated on
the fly.
<.> I don't really like this because we are creating a new object with every method
call, so performance wise this could tank. For demo, and test purposes though,
that's whatever. Also, adding limits so that the numbers are somewhat "realistic".
<.> And lastly we are just calculating the text to display based on the random number
and with a space so that the UI looks _"good"_.

It's also worth of note how I chose to put all the calculation logic behind a method
so that we keep the "html" side clean/abstract, and for further analysis we can
head down to the `@code` section in order to really drill down into what we might
care, and it also helps with edition being way faster and less cumbersome since we
aren't mixing in logic and render sides of the component.

It's with this that everytime a server is "Online" we will see a number between
parenthesis that is number, yet it gives the feedback to the user of the amount
of people that are currently using it.

==== Assignment 7: Answer

Okay course put the number next to the Turn On/Off button. It also used its weird
`;nbsp` weird space. It also applied something that's "possible", and I guess it's
good to know that, this is possible so that If I find code that does this I don't
get surprised:

````
@if (Server.IsOnline)
{
    var random = new Random();
    var randomInt = random.Next();
    <text>randomInt</text>
}
````
So you can literally just write C# code right there on the template. (But I would
advise against it).

==== CSS Isolation

We are going to take this requirement:

- The search bar and input fields on the "Edit Page" are too long, we want to
control that.

If we take a traditional approach, we would literally go to `wwwroot > app.css`.
And we would start styling things there.

[NOTE]
====
By the way, this `app.css` file gets imported in the `App.razor` hence all the styles
that are available can be consumed by the components.
====

If we add a class in `app.css`:

````
.input-width {
    width: 60%;
}
````

We can easily consume the class in any of our app components:

[source, razor]
.SearchBarComponent.razor
----
<div class="input-group mb-3 input-width"> <.>
    <input
        type="text" class="form-control"
        placeholder="Search Servers"
        @bind-value="SearchFilter"
        @bind-value:event="oninput">
    <button class="btn btn-outline-secondary" type="button" id="search-button" @onclick="HandleSearchAsync">Search</button>
</div>
----
<.> In here, the parent container the _input-group_ can have this other class
applied to it and if we head down to the website, we will see how we controlled
the width of the input.

We can go and do the same for the `EditServer.razor` component.

````
<div class="col-6 input-width">
    <InputText class="form-control" @bind-Value="_server.City"></InputText>
</div>
````
As you can see we apply the class to the outer container, not the component itself.
**REMEMBER THIS TRICK**.

So, we do all of this and we effectively have things working. We fulfill the
requirement. _HOWEVER_.

In real life applications, you tend to work in teams, and many people take care
of maintaining the application and adding changes. If you use the `app.css` together,
you might run into problems in which people will perhaps repeat classes, or some
class will override what you did or just plain merge conflicts plaguing you.
There are tons of ways in which keeping styles in this global `app.css` file, will
make things harder for the whole team in the long run.

The best way to solve this problem is `CSS Isolation`. If we can isolate the scope
of the CSS class we will never have problems, we will simply have a css for the
component itself, and all class names will be specific to a component, we won't
clash or bleed styles from other places without knowing.

_How To:_ Simply create a file that has the name of the component + `css`. Example:

- GoodComponent.razor > GoodComponent.razor.css

If you applied the naming convention correctly, you should see in the IDE how
the css file gets somewhat "grouped" under the component it will hold styles for.

Inside of these files you can have any style that you want.

So we will create two new files for css:

- `EditServer.razor.css`
- `SearchBarComponent.razor.css`

And we will add specific styles there (width: 50%, width: 30% respectively). And
if we reload the website, be sure to check that they get applied correctly. _Note: _
Since hot reload is bad, you might have to start the application again so that the
styles get loaded and applied correctly.

Once you have the isolated css file, you can use it all across the component.
**YOU CANNOT USE IT IN OTHER PARTS OF THE APP EVEN IF YOU WANT TO**. This is a
protection against name clashes.

[IMPORTANT]
====
I'm not sure if this will work in prod (published mode). **BUT**. Something cool
to keep in mind is that you can hit the "Inspect" of the browser's Dev Tools, take
a look at the `<head>` of the HTML and extract the name of the css stylesheet,
in the case of this project I got: `ServerManagement.je9262pioh.styles.css`. You
can take the server's URL, and then append as the second level this stylesheet,
and in the browser you should get the whole stylesheet that the app has in plain
text for you to see, e.g., `http://localhost:5116/ServerManagement.je9262pioh.styles.css`.
====

If we were to analyze the css stylesheet, we will immediately notice how our respective
component names are on comments and then their respective styles are also in there.
If you look up for `input-width`, you will notice there are two ocurrences of it.
However they have some extra values added to it, e.g:

- .input-width[b-yj1s9dz156]
- .input-width[b-w7uhgcqi6g]

These are hashed class names (scope identifier/limiter). This is the mechanism that Blazor applies under the
hood so that we don't clash between names across the different components and their
styles, making it easy for us to simply have same class names yet not running into
issues.

If we analyze each of the respective components (with the Inspect tool), we will
easily be able to see on their rendered HTML how they will reference the identifier
and these identifiers should match respectively to the ones we see on the stylesheet.
That's how isolation works.

[IMPORTANT]
====
Why didn't we apply the class names directly on the input components themselves?
Because the identifier doesn't get applied correctly. Hence the _best practice_ is
to have a container, and then put the class name there, that way the identifier
gets applied to it, and the style takes care of re-shaping an input's width or
other things which is inside of the container.
====

==== Cascading Parameter theory

We have learned about parent components and then how we can nest components, and
how to pass info between them. Parameters, EventCallback. But what if we have
multiple levels? Deep structures (3 levels or more deep).

It would be a hassle to make these webs and webs of Parameter passed down to the
next, and then the next passing down to the next. A solution to avoid writing so
much boilerplate is: **Cascading Parameters**.

As long as you define it in a Parent Component, then any child will be able to
access it.

There are two ways of consuming these cascading parameters:

- CascadingValue (This is a component that should be declared on the template part
of the parent).
- CascadingParameter (This is used inside of the child in order to receive the value
that is being cascaded)

==== Use cascading parameter to pass values down the component tree

Let's put a requirement up and then use a cascading parameter to get to it:

- With each city that we hit to filter the list of servers, we want different
background colors.

We have our base page component, the orchestrator. And we have applied before double
bubble up of event callbacks to get from the city component to the orchestrator.
Since that component knows which is the selected city and hence runs logic to change
the list of servers, we want to now also have him affect the look of each of the
server line items. We have **3 levels** of components, but we don't want to write
a lot of code. Hence we will use `CascadingParameters`.

The first part of this setup is to leverage at the parent level the `<CascadingValue>`
component:

[source, razor]
.Servers.razor
----
<CascadingValue Name="SelectedCity" Value="@CityName"> <.>
    <ServerListComponent CityName="@CityName" SearchCity="@SearchName"></ServerListComponent>
</CascadingValue>
----
<.> As you can see we have the ability to choose what child component(s) will get
the cascading value by leveraging this specific Blazor component. All it requires
is for the name to identify the parameter at the child level, and the actual value
to bind to it.

In order to receive the cascading value, we can head down to the child component
that **needs to receive it**, we don't have to declare it in other components that
might not have any use for it.

[source, razor]
.ServerComponent.razor
----
<li style="background-color: @GetBackgroundColor()" @key="Server.Id"> <.>

@code {
    [CascadingParameter(Name = "SelectedCity")] <.>
    public string? SelectedCity { get; set; }

    private string GetBackgroundColor() <.>
    {
        return SelectedCity switch
        {
            "Toronto" => "powderblue",
            "Montreal" => "lightgray",
            "Ottawa" => "palegreen",
            "Calgary" => "pink",
            _ => "white"
        };
    }
}
----
<.> The course now applies running a method in order to calculate things, this
is of course a much _cleaner approach_.
<.> Cascading Parameters can be multiple, not just one, meaning that we should
make it a habit to identify them and retrieve them by said identifier.
<.> This function is a simple calculation function that will take in whatever
the selected city is and then spit out a specific color to style the background
of the server component.

Lastly, we also want to get rid of the default list styles, luckily bootstrap
comes with a pre-built class to override this:

````
<ul class="list-unstyled">
````

This effectively gets rid of the bullet points of the list that we had rendering
at the `ServerListComponent.razor` component.

==== Cascading parameter crossing render mode boundary

**Render Mode Boundary:** Depending on the component and application, you can extrapolate
render boundaries (SSR Boundary - Outer Boundary), (Interactive Boundary - Inner Boundary).

SSR = Pages are rendered statically (no interactivity). But we have the option
to render components with interactivity switch on. (You can leverage both approaches
depending on your use case). **BUT,** if you want to cascade a parameter from an
SSR context into an interactive component, **you cannot**.

Once you have set a specific render boundary, any other component inside of it
(e.g., A parent that has `InteractiveServer` and then nests children inside),
will inherit this same render mode.

If you want to cascade from the outside to the inside, this means that you want
to _cascade values across render mode boundaries_. And this won't work.

_IMPORTANT:_ We have setup the app to have InteractiveServer mode globally, the
course assumes we are with SSR and then opening up specific components to this
render mode. So replicating the lesson's demo is going to be hard but the takeaway
is as follows.

- We have `App.razor` and inside of there we have `<Routes>`, this component takes
care of rendering all the pages that are shown to the user based on URL. If we
were to wrap a `<CascadingValue>` around the whole content, and try to retrieve
it in say `Servers.razor` we won't be able to get it, since at that level we are
simply with `SSR`.

So, how can we "solve" this? Just make the whole application `InteractiveServer`.
The inner boundary will no longer exist, and we will be cascading across a whole
interactive render mode boundary.

[IMPORTANT]
====
There is however another way of cascading a value regardless of boundaries, and
that is by going to `Program.cs` and using the DI Container to then register the
cascading value like so: `builder.Services.AddCascadingValue("SelectedCity", sp => "Toronto")`.
====

You can however see how this limits our options for leveraging the component's state,
this would be a hard-coded value in essence. But, I guess we can make it work with
services, or some static state object, yet depending on the use case, it could be
a good option or a really bad and risky take.

==== Use templated components to create generic components

We have created a lot of reusable components. And we are in the right track, but
we are still coupling together implementations almost too much. The `CityListComponent.razor`
and `ServerListComponent.razor` only renders a list of `CityComponent.razor` and
`ServerComponent.razor` respectively. It's kinda reusable yet at the same time
we have coupled these components together.

**Templated Component:** This is a higher level component, that expands on that
"reusability" concept. If we analyze our list components, at their core, they
are solely in charge of repeating an HTML plus a bit of logic. What if we created
an abstraction that can take any sort of data and repeat it? (A _repeater component_).

With such a repeater component, we can simplify our code base. These higher level
components are referred as `Templated Components`. An in nature are way more re-usable.

- When we look at the CityList component we see how it only requires for the data
in order to run its rendering logic.
- But a templated component will need both the dataset, **and** the UI element.
(e.g., We need to know what is going to be rendered).
- The "repeater" component will need for the UI to be provided to him so that
he repeats it and stays abstract, that UI element is called **Template**, or _Placeholder_.

Let's practice this new concept with the `EditServer.razor`. If we look at the code
of the input fields:

````
<div class="row mb-3">
     <InputNumber hidden="true" @bind-Value="@_server.Id"></InputNumber>
     <div class="col-2">
         <label class="col-form-label">
             Name
         </label>
     </div>
     <div class="col-6 input-width">
         <InputText class="form-control" @bind-Value="_server.Name"></InputText>
     </div>
     <div class="col">
         <ValidationMessage For="() => _server.Name"></ValidationMessage>
     </div>
 </div>
````
We can see how this structure is repeated all across the component. It has the
potential to be abstracted since the code is verbose and can be generalized with
the help of a Templated Component.

So, how about creating a `FieldComponent.razor` templated component? It would take
a label name and then two specific regions (UI) to render the specific control and
validation control: (We are creating this under `ServerManagement.Components.Controls.Generic`)

[source, razor]
.FieldComponent.razor
----
<div class="row mb-3">
    <div class="col-2">
        <label class="col-form-label">
            @Label <.>
        </label>
    </div>
    <div class="col-6 input-width">
        @Control <.>
    </div>
    <div class="col">
        @ValidationControl
    </div>
</div>

@code {
    [Parameter] public string? Label { get; set; }

    [Parameter] public RenderFragment? Control { get; set; } <.>
    [Parameter] public RenderFragment? ValidationControl { get; set; }
}
----
<.> As you can see we will receive dynamically a parameter from upstream and that
wil lbe rendered on this specific region.
<.> As you can see we are simply placing a state variable where the upstream UI
content should be fed onto.
<.> We will then receive as `Parameter` a `RenderFragment` which is the specific
type for a template that we will later see how it's consumed.

_NOTE:_ We have to add to the `_Imports.razor` our new namespace since we created
a new folder to hold these more _Generic_ components. `@using ServerManagement.Components.Controls.Generic`.

And if we were to go to `EditServer.razor`:

[source, razor]
====
<FieldComponent Label="Name"> <.>
    <Control> <.>
        <InputText class="form-control" @bind-Value="_server.Name"></InputText>
    </Control>
    <ValidationControl> <.>
        <ValidationMessage For="() => _server.Name"></ValidationMessage> <.>
    </ValidationControl>
</FieldComponent>
====
<.> As you can see we are using the previously created component and feeding the
parameter for `Label`.
<.> And this is were things change a bit, for the `RenderFragment` parameters we
have to declare them as components themselves, so the name will correspond to the
RenderFragment's name.
<.> You can see how we feed the first and second render fragments respectively.
<.> And inside of the render fragment, the template code is the UI that will be
passed down to the _templated component_. It's worth noting that all state, all
the wired up things that worked before, _STILL WORK_. State is shared, the
templated component simply takes what's being passed down by reference.

The code in the `EditServer.razor` component will end up looking like this:

````
<EditForm Model="_server" FormName="formServer" OnValidSubmit="Submit">
    <DataAnnotationsValidator></DataAnnotationsValidator>
    <ValidationSummary></ValidationSummary>

    <InputNumber hidden="true" @bind-Value="@_server.Id"></InputNumber>
    <FieldComponent Label="Name">
        <Control>
            <InputText class="form-control" @bind-Value="_server.Name"></InputText>
        </Control>
        <ValidationControl>
            <ValidationMessage For="() => _server.Name"></ValidationMessage>
        </ValidationControl>
    </FieldComponent>

    <FieldComponent Label="City">
        <Control>
            <InputText class="form-control" @bind-Value="_server.City"></InputText>
        </Control>
        <ValidationControl>
            <ValidationMessage For="() => _server.City"></ValidationMessage>
        </ValidationControl>
    </FieldComponent>

    <FieldComponent Label="Online">
        <Control>
            <InputCheckbox class="form-check-input" @bind-Value="_server.IsOnline"></InputCheckbox>
        </Control>
    </FieldComponent>

    <br/>
    <button class="btn btn-primary" type="submit">Update</button>
    <a href="/servers" class="btn btn-primary ">Go Back</a>
</EditForm>
````
As you can see instead of all the repeated HTML code we abstract it behind the
templated component, and simply consume it and feed some bit of parameters on
top of specific HTML content to render that responds to the specific use case.
This is cleaner, and more maintainable.

The web page should work the same as before, we simply refactored.

==== Typed Templated Component

At the theory section we explained how templated components require for UI
**AND** data. But if we analyze `FieldComponent` we can easily see how we have
no actual _data_ fed onto it. So we will now code an actual _full-on templated
component_. This requires for the component to take a **type** and also some
sort of **dataset**.

[IMPORTANT]
====
This doesn't mean that the previously coded templated component is _wrong_ or
doesn't adhere to what the _best practice_ says. It's simply an intermediate type
of templated component useful to fulfill the specific requirement.
====

The example we will implement is the `Repeater`.

Under the same `Generic` folder we will create:

[source, razor]
.RepeaterComponent.razor
====
@typeparam TItem <.>

@if (Items is null || !Items.Any() || Row is null)
{
    return;
}

@Header
<Virtualize Items="Items" Context="item"> <.>
    @Row(item) <.>
</Virtualize>
@Footer

@code {
    [Parameter] public List<TItem>? Items { get; set; } <.>
    [Parameter] public RenderFragment<TItem>? Row { get; set; } <.>
    [Parameter] public RenderFragment? Header { get; set; } <.>
    [Parameter] public RenderFragment? Footer { get; set; }
}
====
<.> In order for a templated component to take some sort of type, we need to declare
it like this. At the top, and marked as generic, we want it as reusable as possible,
not tied into a specific type.
<.> As you can see we are leveraging `Virtualize` again, but we are feeding into
it the dataset.
<.> This is a specific syntax when working with typed RenderFragments, if you need
to feed into it some sort of argument, you can call it as if it where a **method**.
<.> As you can see this is a list of items (dataset) but that's also generic, (paired
up with the same type param we had at <1>).
<.> This is a specific type of `RenderFragment` it's also tied with the <1> type
parameter.
<.> And we are then adding two extra render fragments that will render a static
content as a header and footer from upstream.

Lastly, the way to consume this component will be as follows:

[source, razor]
.ServerListComponent.razor
====
<ul class="list-unstyled"> <.>
    <RepeaterComponent Items="servers"> <.>
        <Row Context="server"> <.>
            <ServerComponent Server="server"></ServerComponent> <.>
        </Row>
    </RepeaterComponent>
</ul>
====
<.> We have to wrap our `Repeater` since the `ServerComponent` is actually a list
element `<li>` and if we don't have that inside of an `<ul>` the rendered content
will break.
<.> As you can see, we are feeding the list of items through the `Items` parameter,
and because we typed the templated component it will infer the type automatically
because of this.
<.> The special typed `RenderFragment` has will receive a specific iteration value
when being rendered at the templated component level, however, because we are working
with the render fragment itself, we have to feed it the actual UI to render inside.
The UI that will render the line item that will be repeated (really confusing at
first I know). In here we are basically stating that the `Context`, which is indeed
what the Repeater will feed as each line item renders, will be under a `server`
variable name, and we then take that reference to feed onto `<ServerComponent>`
to its `Server` parameter the specific object so that it renders accordingly.

This concept is pretty abstract and high level, but in short, we are allowing for
the upstream to control what gets rendered downstream, and through clever usage
of syntax and specific structuring of the components, we are managing to achieve
an extremely abstract-generic component, that takes care of a specific function,
and leaves other components to shape whatever he's going to render within certain
parameters (always a contract in between two interacting modules).

After applying all of this, the web page should still work the same _we have only
applied refactoring_.

==== Use html table in our RepeaterComponent

The current server list is rendered with a list (<ul>), however we should aim
at using a **table**, for better styling and support. This also lets us change to
`QuickGrid` which is a feature that comes bundled with .NET 8.

Code will have to change in two places:

[source, razor]
.ServerListComponent.razor
====
<table class="table table-striped"> <.>
    <RepeaterComponent Items="servers">
        <Header> <.>
            <thead>
            <tr>
                <th>
                    Name
                </th>
                <th>
                    City
                </th>
                <th>
                    Status
                </th>
                <th>
                    People Online
                </th>
                <th></th> <.>
                <th></th>
            </tr>
            </thead>
        </Header>
        <Row Context="server"> <.>
            <ServerComponent Server="server"></ServerComponent>
        </Row>
    </RepeaterComponent>
</table>
====
<.> In order to style the table with Bootstrap's "nice-looking" defaults, you can
apply these two classes.
<.> We added the specific `@Header` RenderFragment previously and in here it integrates
seamlessly into an HTML table structure.
<.> This is just HTML table syntax, if we want a header with labels we would add
that info under a `<thead>, and then under one sole row `<tr>`, we would then add
all the entries we want with `<th>`. The last two _"empty"_ columns are to house
the buttons of the line items.
<.> And under the `Row` RenderFragment we are sending in the code that will repeat
per line item the rendered `ServerComponent`

[source, razor]
.ServerComponent.razor
====
<tr style="background-color: @GetBackgroundColor()" @key="Server.Id"> <.>
    <td> <.>
        @Server.Name
    </td>
    <td>
        @Server.City
    </td>
    <td style="color: @(Server.IsOnline ? "green" : "red")"> <.>
        @(Server.IsOnline ? "online" : "offline")
    </td>
    <td>
        @if (Server.IsOnline)
        {
            <text>@(GetRandomPeopleNumber())</text>
        }
        else
        {
            <text>N/A</text> <.>
        }
    </td>
    <td>
        <button class="@($"ms-2 btn btn-outline-{CalculateButtonType(Server.IsOnline)}")" @onclick="UpdateServerStatus"> <.>
            @(CalculateButtonText(Server.IsOnline))
        </button>
        <a href="/Servers/edit/@Server.Id" class="btn btn-outline-primary">Edit</a>
    </td>
    <td>
        <EditForm
            style="@($"background-color: {GetBackgroundColor()}")" <.>
            Model="Server"
            FormName="@($"Server-{Server.Id}-form")"
            OnValidSubmit="@(() => DeleteServer(Server))">
            <button type="submit" class="btn btn-primary">
                Delete
            </button>
        </EditForm>
    </td>
</tr>
====
<.> Since we are switching to an HTML table, our `ServerComponent.razor` will now
in essence will render a full HTML table row. Hence we are now under a containing
`<tr>`
<.> If we want to add the differen columns for this row, we use `<td>` (HTML basics)
<.> Each column can be styled as you see fit (just use `style=`)
<.> Due to the nature of our table structure, we had to add this fallback piece of
logic. Otherwise we wouldn't get anything rendered into this column that will
become static.
<.> We are housing these buttons on their own columns, notice how we can simply
wrap them and they will be on the same row and fit in automatically.
<.> This is really **IMPORTANT**. The course doesn't seem to show a problem here,
but on this end the form messed up with styling, the background didn't seem to get
applied, and so we had to manually pass onto the component the style to align with
the table's background color. This syntax also is very important, if you don't pass
a explicit syntax here to render this whole string, Blazor will not compile.

[NOTE]
====
When it comes to marrying both HTML and the Blazor render mechanism, I think it's
key understanding how these things work at a base level. As base concepts. Otherwise
you will never truly understand what's going on. In the end, the framework is a just
a mechanism to auto-generate HTML, since that's what the browser understands. So
all the syntax is simply clever engineering to make the framework generate code
on the other end (repeated line items, tables, etc).
====

After all these changes, then everything should be working as before, but looking
even better since we refactored it to use a table.

==== Using QuickGrid to display our servers

This is a component that Microsoft offers developers to quickly and efficiently
display data in a tabular format.

Let's learn some basics of how to use it.

- _Install a NuGet package_
- Search for the package that's made by Microsoft (Microsoft.AspNetCore.Components.QuickGrid)
    - You can even integrate QuickGrid with EF Core, but we won't go there for now
- Install the package

In order to use it, we won't modify our `ServerListComponent.razor` file, but create
a separate `QuickGridDemo.razor`. This will be under `Controls`.

[IMPORTANT]
====
Be careful about the version of the Nuget that you install. I installed the "latest"
but this was a preview for .NET 10. I was in a .NET 9 project, with the previous installed
package the import of `QuickGrid` won't work at all. So be sure to line up the versions
correctly.
====

This is how we would initially attempt to use it:

[source, razor]
====
@page "/quickgrid"
@using Microsoft.AspNetCore.Components.QuickGrid

<h3>QuickGrid Demo</h3>
<br/>

@if (_servers is null)
{
    return;
}

<QuickGrid Items="_servers.AsQueryable()"></QuickGrid> <.>

@code {
    private List<Server>? _servers = ServersRepository.GetServers();
}
====
<.> A small comment here, we need our dataset to bet of `IQueryable` type.

This isn't as simple though, nothing will render like this. In addition to specifying
the component we need to specify each of the columns. The easiest way to render
them is by using the `<PropertyColumn>` render fragment and `<PropertyTemplate>`.

This is how the final template would look like:

[source, razor]
----
<QuickGrid Items="_servers.AsQueryable()">
    <PropertyColumn Property="s => s.Name"></PropertyColumn> <.>
    <PropertyColumn Property="s => s.City"></PropertyColumn>
    <TemplateColumn Title="Status"> <.>
        <div style="color: @(context.IsOnline ? "green" : "red")">
            @(context.IsOnline ? "online" : "offline") <.>
        </div>
    </TemplateColumn>
    <TemplateColumn Title="People Online">
        @if (context.IsOnline)
        {
            <text>@(GetRandomPeopleNumber())</text>
        }
        else
        {
            <text>N/A</text>
        }
    </TemplateColumn>
    <TemplateColumn>
        <button class="@($"ms-2 btn btn-outline-{CalculateButtonType(context.IsOnline)}")"
                @onclick="() => context.IsOnline = !context.IsOnline"> <.>
            @(CalculateButtonText(context.IsOnline))
        </button>
    </TemplateColumn>
    <TemplateColumn>
        <a href="/Servers/edit/@context.Id" class="btn btn-outline-primary">Edit</a>
    </TemplateColumn>
    <TemplateColumn>
        <ChildContent Context="server"> <.>
            <EditForm
                style="@("background-color: white")"
                Model="server"
                FormName="@($"Server-{server.Id}-form")"
                OnValidSubmit="@(() => DeleteServer(server))">
                <button type="submit" class="btn btn-primary">
                    Delete
                </button>
            </EditForm>
        </ChildContent>
    </TemplateColumn>
</QuickGrid>
----
<.> `PropertyColumn` is pretty straightforward, **_if you have to just display the
specific property's content, just use this syntax and point towards the specific
property you want rendered_**
<.> In case this isn't just a simple display of a value, and you want to insert
more complex content leverage `TemplateColumn`, in here you can insert any HTML
that you want and have control of the cell.
<.> By default, `QuickGrid` has a `context` property that implicitly is declared
and we can access from any of the column child components, hence in here we can
access the line item's `IsOnline` and use it for rendering logic.
<.> In here I had to rewrite the function since in the `ServerComponent` use-case
I simply sent a callback implicitly but that's because the setup accounts for a
property called `Server`, in here we are leveraging the lambda in order to access
the line item's object under the `context` name.
<.> A really important thing here is that `EditForm` also loads automatically a
`context` object, (but we can rename it with the `Context=Something` syntax). Still,
for these cases in which variable names might clash, we have `ChildContent` as a
component that can wrap the nested component with its own context, and in that
wrapper we can rename the parent's context to something else. In this instance
we renamed it to `server` and inside of the nested `EditForm` we can access the
parent context just fine by calling said `server` renamed context. (Clever I should
say).

This is but an option, you can use it, or not. Up to you and the requirements really.

Now, the course makes a note that Turn On/Off doesn't work, but that's because its
setup is following the "SSR by default, component's override that" normal setup.
We changed it to follow "everything is interactiveserver", hence for us the interactivity
bit of behavior works out the box. So to fix it you simply add at the beginning
`@rendermode InteractiveServer`.

==== QuickGrid Sorting and Pagination

We will now leverage some other features that are ready for consumption on
QuickGrid. If we want a column to be sortable, you can just add a property like
so:

````
<PropertyColumn Property="s => s.City" Sortable="true"></PropertyColumn>
````

This is cool, since by simply adding this property/flag, we can now head down to
the column's header, and click on it, and it will automatically sort the content
ASC or DESC. Any other columns will not have the clickable header enabled, you
have to mark them yourself.

What if you want to also make a `TemplateColumn` sortable? If you add the same
property by itself it won't work, Blazor will _try_ to sort it, but it won't really
work. So how do you configure it to work?

First of all, understand that a `TemplateColumn` doesn't even know what column you
are trying to map to, it's a free canvas basically. However there's a different
property `SortBy` it takes a specific type of object however:

````
<TemplateColumn Title="Status" SortBy="GridSort<Server>.ByAscending(s => s.IsOnline)">
````
As you can see you feed to the property this specific `GridSort` object, and you
have to specify if by default it will start ASC or DESC, and inside of the method's
parameter you feed a lambda to point to the actual property that will be taken into
account for the sorting logic.

What about Pagination? QuickGrid helps with us not having to implement pagination
from zero.

In order to leverage it you need first a `PaginationState` state variable:

````
private PaginationState _paginationState = new()
{
    ItemsPerPage = 5,
};
````

And you can then feed it into both `<QuickGrid>` and also a `<Paginator>` component
that comes bundled with the Nuget package we installed:

````
<QuickGrid Items="_servers.AsQueryable()" Pagination="_paginationState">

<Paginator State="_paginationState"></Paginator>
````

And with this, based on the object configuration you will get controls and pagination
logic straight out the box. (Pretty cool)

==== Use arbitrary attributes to provide flexibility

=== Course Project (Part 2): Componetize our To-Do List App

==== Componetize the List of items

==== Componetize the to do item
