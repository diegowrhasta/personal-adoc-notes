= Introduction

These are notes for different things found in the Blazor (.NET) component frontend
framework. As a starter, we will have notes on a https://www.udemy.com/course/blazor-deep-dive-from-beginner-to-advanced/[Udemy]
course.

== Blazor Deep Dive - From Beginner to Advanced in .NET 8

=== Course Content

==== NET 9 Updates

.NET 9 introduced a few changes to Blazor. These changes are minor however. One
thing worth of note though is that you should include **SSR (Server Side Rendering)**
in a Blazor app configured to use server interactivity with global location.

==== What is Blazor

TL;DR: Blazor is a **component based** SPA web application framework that achieves
interactivity with C#.

_Component based SPA web application framework:_ This differs from the traditional
web application paradigm (which is also the first one that was invented). In the
sense that we are not responding to individual pages that a server requests, and
then spits back to the client.

The user will send requests to the web server as well, however the web server will
route all requests to **ONE PAGE**. This is in theory called _the root component_,
but you can still define it as this _root page_. No matter how many requests are
sent, they will always go to one single page. The Blazor Framework will look for
different components, and it will then **place the component** inside the root
component.

A simple workflow would be:

1. A first request will go to the server, the server will then request for the
necessary components to render that path.
2. A second request will come and the server will "erase" the previous components
and render others that respond to that specific request. And so on.

Components are a powerful paradigm because you can nest components inside of other
components, effectively turning this structure as a **component tree**, the levels
and children will be mandated by requirements.

The main idea is that you should **think in components**. Blazor uses C# in order
to reach interactivity. React, Angular, Vue, etc all use **javascript**.

==== Choices of interactivity

What is _interactivity_?

E.g., If we have a page, and on this page we have a list, we want to allow users
to search on that list based on a filter, only matching results to the filter
should show up in the list. We would have a search bar, a button. In order to
add _reactivity_ or _interactivity_ normally you would start using javascript.
But in Blazor we achieve that with C#, and C# only. The main idea behind the
framework's design is to unify code as much as possible and not rely on Javascript,
(although you will be still using it in really specific edge cases).

There are different ways to implement interactivity with Blazor, the types of
interactivity are:

No interactivity (base):: This is one type, in case you don't need any sort of reactivity,
this is also called SSR (Static Server Side Rendering). In most use cases, you will
create a project with this default interactivity setting. You would only need to
add interactivity based on **requirements**.
Server Interactivity:: This will make the application to establish a SignalR channel
from server to client (this is a WebSocket implementation). This is like a P2P
communication and it needs to be sustained. In order for this channel to work,
a javascript file is created inside of the page that is being rendered on the
browser, **this is not created by a developer** but by the framework. Whenever the
user does something, the event will be handled by said javascript server and sent
to the backend server, to then make a decision. It will compare the previous state
of the page and then a newly calculated state, that difference is then sent back
to the client so that it can attach it and re-render the page on the fly. (No
reload of the whole page)
WebAssembly Interactivity:: This is based on Blazor SSR, the components that require
WASM will then get packaged with tons of extra DLLs and WASM files and sent back
to the browser. This is then leveraged by the browser in order to run the interactions.
A good point here is that WASM is way faster than javascript since it runs at almost
native speeds. There's another approach in which the whole component gets compiled
into WASM and that gets sent to the browser to then be interpreted and run. But
either way, **some kind of files will be downloaded from the server to the browser**
and these files will then be executed by the browser.

Blazor SSR = **BASE OF EVERYTHING** When Web Interactivity is required, you can
choose WASM, Server Interactivity or a hybrid model in which some "pages" and components
run on server and others on WASM.

==== Blazor SSR Project Structure

In order to start getting familiar with Blazor SSR, we will create some dummy project
and describe its components.

First of all, when creating a Blazor Web Application, starting on .NET 8 the recommended
template is simple **Blazor Web App**. There are other variations however that might
apply to specific use cases.

[IMPORTANT]
====
We will select the "Interactivity Mode" as `None`, this is the stock Server Side
Static Rendering (SSR). And it's recommended to start your project with this setting,
the other ones are _Server, WebAssembly, Auto (Hybrid)_. Many pages that you create
you will see that require no interactivity, meaning that by selecting `None` you
can add interactivity to components that actually need it.
====

After we create the project with a "Interactivity" set, it will not matter later.

**NOTE:** Just to get things straight, the entry point is `Program.cs`. The paradigm
is simple, we do a `app.Run()` and the app stays alive as if in a "for-loop" and
will pick up on any Http Request that comes in. Once a request comes in, it goes
through different functions, which are called _Middlewares_.

[source, csharp]
----
using ServerManagement.Components;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddRazorComponents();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error", createScopeForErrors: true);
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}

app.UseHttpsRedirection(); <.>


app.UseAntiforgery();

app.MapStaticAssets();
app.MapRazorComponents<App>(); <.>

app.Run();
----
<.> Something like this is a Middleware, a request that comes will pass through the
logic that's stated here and maybe get something added to it, or extracted, middlewares
are multi-purpose in nature.
<.> This is a pretty important line of code, this will map all the Http requests
to the `App` class.

If we go and analyze the `App.razor` file that should be under `Components`. We
should find something like this:

[source, razor]
----
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <base href="/"/>
    <link rel="stylesheet" href="@Assets["lib/bootstrap/dist/css/bootstrap.min.css"]"/>
    <link rel="stylesheet" href="@Assets["app.css"]"/>
    <link rel="stylesheet" href="@Assets["ServerManagement.styles.css"]"/>
    <ImportMap/>
    <link rel="icon" type="image/png" href="favicon.png"/>
    <HeadOutlet/> <.>
</head>

<body>
<Routes/> <.>
<script src="_framework/blazor.web.js"></script>
</body>

</html>
----
This isn't the only place that will have `html` code declared inside of it. The
specific notations such as `HeadOutlet` and `Routes` will later come into play
when dealing with the framework's functionalities.

[IMPORTANT]
====
The `App.cs` component/razor file, is actually the _ROOT COMPONENT_. In here we
will be rendering all the components, hence it's configured in a way such that
all Http requests are mapped to this very specific component. This is the **one page** 
of the SPA.
====

It's through `<Routes />` that then the root component can resolve/render corresponding
components that respond to different routes.

Now this component can also be read, it should be right next to the `App.razor`
file.

[source, razor]
====
<Router AppAssembly="typeof(Program).Assembly">
    <Found Context="routeData">
        <RouteView RouteData="routeData" DefaultLayout="typeof(Layout.MainLayout)"/> <.>
        <FocusOnNavigate RouteData="routeData" Selector="h1"/>
    </Found>
</Router> <.>
====
<.> A key concept here is `DefaultLayout="typeof(Layout.MainLayout)"` this notation
specifically makes it so that the component will be spat out as HTML to the browser.

And so, in short, all the routes here will respond to a specific set of components
or "screens". Depending on the route that the server got, then all the respective
**content** will be displayed/replaced on the place that holds the `<Routes />`
tag.

The `MainLayout`, so the actual code that will render HTML can also be visualized
under `Components > Layout > MainLayout.razor`. Technically all blazor components
are under `.razor` files.

[source, razor]
.MainLayout.razor
====
@inherits LayoutComponentBase

<div class="page">
    <div class="sidebar">
        <NavMenu/>
    </div>

    <main>
        <div class="top-row px-4">
            <a href="https://learn.microsoft.com/aspnet/core/" target="_blank">About</a>
        </div>

        <article class="content px-4">
            @Body <.>
        </article>
    </main>
</div>
====
<.> The `@Body` annotation/tag is a really important piece of notation to keep in
mind, it's a placeholder for **any component**, no matter what type of component
is required by the user, it will come in here and replace the placeholder.

This is the _basic, theoretical flow_:

. Request comes into `Program.cs`
. Request goes to `App.razor`
. Goes to the `Routes.razor`
. Goes to `MainLayout.razor`

And through it all, it will render and swap out placeholders and places on each
layer respectively.

If you run the application, we should see both a terminal session and a web site
on our Default Browser.

The terminal holds some bits of info that's great:

. It will tell us at which ports the Blazor App is running
. It will also tell us which is the Root Page (component)

In short, the `MainLayout.razor` site renders a side bar, and then has content
that will change based on the route. This is how it all works, if you inspect
the HTML you will see how this rings true, how the sidebar is effectively **static**.

It's however Blazor that under the scenes takes care of replacing content based
on the routes.

This is the basic SSR setup, if we want WASM interactivity we will need to add a
second project, but overall it will remain the same. Hence it's said that
`SSR is the base of everything else`.

=== Blazor SSR

==== Two Types of Components

There are two types:

Routable Components:: Also called _Page Components_. This will respond directly
to a route.
Non-Routable Components:: Also called _Reusable Components_. These are used inside
routable components, and also inside of other non-routable components.

So, let's start playing around with the components and features. Say, we want to
create a Page that will respond to a new route. We should then create a `.razor`
file inside of `Pages`. Something like `Servers.razor`. You should _technically_
always create a _Razor Component_. But it's through anotations and other things
that we establish a routable and non-routable component and so on.

If we create with the scaffold:

[source, razor]
====
@page "/Servers" <.>
<h3>Servers</h3>

@code {
    
}
====
<.> This is the single most important thing that marks a component as a `routable
component`.

After adding this new component, and reloading the web site, we can manually type
`/servers` at the URL bar, if we get something rendered (in this case a simple heading
with `Servers`), then everything is working as expected.

We will now create a non-routable component, the course's convention is creating
a folder called `Controls`. And inside adding a `.razor` file. All of the components
inside should be _non-routable_. Another convention is to always suffix these components
with `Component` e.g., `ServerComponent.razor`

Once we create this component we can add some code to it to see if it renders, and
after that we can then use this component inside of any of our pages. In this case
if we were to put it into `Servers.razor`:

[source, razor]
====
@page "/servers"
@using ServerManagement.Components.Controls <.>

<h3>Servers</h3>
<br/>
<br/>
<ServerComponent/> <.>

@code {

}
====
<.> You could just import the namespace like this, but there's a more clean and
recommended way.
<> And here you can just write the component name with this syntax (that's really
close to how React would do it, or even Angular for that matter)

The better and cleaner approach to imports is to put the namespace import under the
`_Imports.razor` component that should be at the root of the `Components` folder.
In here you woul see things such as:

[source, razor]
====
@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using static Microsoft.AspNetCore.Components.Web.RenderMode
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.JSInterop
@using ServerManagement
@using ServerManagement.Components

@using ServerManagement.Components.Controls <.>
====
<.> This import can indeed be powerful, because, if by convention we create
all re-usable components under this namespace, next time, when trying to call them
from other components or pages, we won't have to always be importing them, this
centralized the import and makes things leaner.
====

If you were to declare `<ServerComponent />` twice, then its content should be
replicated normally. This is a reusability example, _don't forget about that_.

==== Razor Syntax Implicit Razor Expression

Blazor achieves interactivity with C#, this is at the frontend level. However
at the backend we also use C#, how will that work?

So that we can start using C# code we have to leverage **Razor Syntax**

[source, razor]
====
<p>
    @status <.>
</p>

@code {
    private string status = "Server is offline"; <.>
}
====
<.> This is called _implicit syntax_ we can reference variables that are written
in C# directly on the `HTML` part.
<2> As you can see we are using C# code here to assign a value to then be rendered.

We can then concatenate both HTML and "evaluation code". `@status at @DateTime.Now`.
Whenever there's an `@` then this is actually syntax that tells Blazor that something
from C# needs to come here (and be evaluated).

[NOTE]
====
Okay, thank god that Hot Reload is a _thing_. Hopefully it's stable now in .NET
9. https://learn.microsoft.com/en-us/aspnet/core/test/hot-reload?view=aspnetcore-9.0[hopefully].
====

The course leans heavily on this process of "Apply a change, restart the server",
and that is _so slow_. The industry standard should be hot reload (React, Angular
had over Blazor a long time ago). The way to _enable_ hot reload is to simply run
the application with `dotnet watch` this will keep a demon checking for changes
on the source code files, and if it's detected then it will auto reload itself,
in case something really critical is updated it will prompt the user to please
reload manually (better than wasting time).
====

What if we wanted to leverage some class? We can then create a model (POCO) under
something like `Models`. A typical POCO with `ServerId, City, Name` perhaps.
Nothing out of the ordinary.

And then we can reference it in our component like so:

[source, csharp]
.ServerComponent.razor
----
<p>
    @server.Name is in @server.City
</p>

@code {
    private Server server = new()
    {
        Name = "Server 1",
        City = "Toronto"
    };
}
----
As you can see, we are using **implicit syntax**, and after spaces then the evaluation
stops, hence always before spaces we should reference expressions that are C#
code related. We can use the **implicit syntax** under any HTML by the way, not
just paragraphs (`<p>`). This can even be evaluated on HTML properties.

And again, we should add its namespace to the `_Imports.razor` component so that
globally any model we add we can seamlessly consume from anywhere and removing
the need to import it always.

==== Razor syntax Explicit Razor Expression

The Razor expression would be limited if we only had the implicit type, since we
can't really do anything with logic or concatenation since a **space** literally
marks it as finished. And it's due to this that an _explicit expression is necessary_.

[source, razor]
====
<p>
    @server.Name is in @server.City that is @(server.IsOnline ? "online" : "offline") <.>
</p>

@code {
    private Server server = new()
    {
        Name = "Server 1",
        City = "Toronto"
    };
}
====
<.> With the `@()` syntax you can easily write more explicit code and logic so that
some rendering is applied based on pre-existing conditions. We can use the explicit
syntax even on attributes for an html element. Any C# expression can be used inside the
`@()`.

See how explicit syntax can be so powerful that it can literally be used for conditional
rendering and styling:

[source, razor]
====
<div style="color: @(server.IsOnline ? "green" : "red")" data-name="@server.Name" data-status="@(server.IsOnline ? "online" : "offline")"> <.>
    @server.Name is in @server.City that is @(server.IsOnline ? "online" : "offline")
</div>

@code {
    private Server server = new()
    {
        Name = "Server 1",
        City = "Toronto"
    };
}
====
<.> In here under a `style` we can literally conditionally apply a color or something
alike. It's extremely powerful.

_NOTE:_ We can also use a direct object for style: `style="@($"color: {(server.IsOnline ? "green" : "red")}")"`,
the thing with this syntax though is that we can nest another "evaluation expressions"
inside of the existing @() part. So this is a great way to keep adding more complex
condition paths in the same structure.

The Razor expression syntax has tons of power when it comes to rendering things
with C# code and bound objects.

==== Create a static data repository

In order to keep exploring Blazor's capabilities we can now create a mode for
mocking data. In our case we'll use the Repository pattern to create a `ServersRepository.cs`
class.

There's nothing worth of note here, more than a simple CRUD but that's managing
a static list in memory. We won't connect to some backing service since the focus
of the whole course is Blazor, we just need a source of data.

==== Razor Syntax Output list with looping

We are going to use looping to output a list inside of a Razor component.

[source, razor]
----
@page "/servers"

<h3>Servers</h3>
<br/>
<br/>
<ul>
    @foreach (var server in servers) <.>
    {
        <li>
            @server.Name in @server.City is <.>
            <span style="color: @(server.IsOnline ? "green" : "red")"> <.>
                @(server.IsOnline ? "online" : "offline")
            </span>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
}
----
<.> Se use the `@foreach` control directive to then loop over a list and render
_repeatedly_ HTML elements as we see fit (per entry of the list).
<.> We will then have code that can easily resemble what we already saw previously
but now applied to this new "iterative logic".

==== Assignment 1: Output city buttons list

We are going to output city buttons.

The idea is to practice the `@foreach` loop syntax, the rules are as follows:

. We are going to create a city model
. We will create a city repository
. We will output the cities as lists

We will work with static lists, so under `Models > CitiesRepository.cs` we will
simply have a string list with city names.

==== Assignment 1: Answer

Under the `Servers.razor` file:

[source, razor]
----
@page "/servers"

<h3>Servers</h3>
<br/>
<br/>
<ul>
    @foreach (var city in cities)
    {
        <button type="button">@city</button> <.>
    }
</ul>
<ul>
    @foreach (var server in servers)
    {
        <li>
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
    private List<string> cities = CitiesRepository.Cities;
}
----
<.> This is something that works just fine, BUT, Blazor by default comes with
bootstrap already installed, so we can style this with `class="btn btn-primary"`.

Now, the course does really hacky stuff, in order to add a space between the buttons
it uses this interesting syntax called `<text></text>` that you can use to enclose
some special characters, I guess that's, cool? Don't really know. But we can style
components as we would without issue by creating a file like:

````
|-- Servers.razor
|-- Servers.razor.css
````

And in there we can start adding as much styling as we want to, by default Blazor
will then compile this into isolated CSS so we shouldn't class with other styles
and we will keep things lean.

[NOTE]
====
IF YOU CAN'T SEE THE STYLES GETTING APPLIED/LOADED THAT'S PROBABLY BECAUSE YOU HAVE
TO RELOAD THE WHOLE APP. This is dumb, tbh, the hot reload doesn't pick up on
styles apparently, so it's not that "scoping is not working", it's more so that
we have to work with manual restarts
====

This is how the component code would look like:

[source, razor]
----
@page "/servers"

<h3>Servers</h3>
<br/>
<br/>
<ul class="button-list">
    @foreach (var city in cities)
    {
        <li> <.>
            <button type="button" class="btn btn-primary">@city</button> <.>
        </li>
    }
</ul>
<br/>
<br/>
<ul>
    @foreach (var server in servers)
    {
        <li>
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
    private List<string> cities = CitiesRepository.Cities;
}
----
<.> By convention, and to avoid errors, you should only have direct children of
a <ul>, <li> elements, inside of those elements you can then do whatever you want.

And the css that would make the buttons look nice and also use good css practices:

[source, css]
----
.button-list {
    display: flex;
    gap: 1rem;
    list-style: none;
    padding: 0;
}

.button-list li {
    display: flex; /* ensures buttons align neatly */
}
----
Since we have to work our way around the list elements, the default css will
add bullet points so we have to get rid of them with `list-style: none`, plus
no default padding: `0`. And so that the buttons, or the children elements align
neatly we will also apply a `display: flex` property to all of them. And the
different with a simple `<button>` is that the content will not have a padded
button at the beginning, this will neatly fit into the whole container.


**NOTE:** So, an interesting thing and piece of info in general is that the course
uses a bootstrap property to literally make the buttons change their layout as the
screen gets smaller, this is with a bootstrap class `container-fluid` apparently,
and it doesn't use a list it uses a div and inside of it buttons, then the buttons
stack up as the screen gets smaller, which is cool, I guess.

[source, razor]
----
@page "/servers"

<h3>Servers</h3>
<br/>
<br/>
<div class="container-fluid text-center"> <.>
    <div class="row w-50"> <.>
        @foreach (var city in cities)
        {
            <div class="col"> <.>
                <button type="button" class="btn btn-primary">@city</button>
            </div>
        }
    </div>
</div>
<br/>
<br/>
<ul>
    @foreach (var server in servers)
    {
        <li>
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
    private List<string> cities = CitiesRepository.Cities;
}
----
<.> So `container-fluid` simply makes a full-width content wrapper with padding.
<.> After that we are creating another `div` that I think could be simplified into
one div. But anyway, this has the `row` class with something that lets it grow
only until half the view port (width: 50%).
<.> Inside of this parent we have `class="col"` which are containers that help
everything stack as the screen grows larger or smaller. It's a bit magical since
you get these behaviors by applying bootstraps built-in classes, but... yeah. Trying
to replicate the same behavior and styling requires more in raw css, but again,
you can simplify so much and not be as bloated.

==== Working with Static Resources

Before going further into development, we need to learn another convention established
by Blazor. And that's a folder for static resources that the server can resolve
automatically, for that we need to have a look at the `Program.cs` file again:

[source, cs]
----
using ServerManagement.Components;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddRazorComponents();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error", createScopeForErrors: true);
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}

app.UseHttpsRedirection();


app.UseAntiforgery();

app.MapStaticAssets(); <.>
app.MapRazorComponents<App>(); <.>

app.Run();
----
<.> Just like the razor components middleware this takes care of configuring the app
so that all files under `wwwroot` are served by the server automatically (it can
resolve the static resources correctly). Without this middleware we wouldn't be
able to reference a resource and have that being retrieved by the server just fine.
<.> Remember, this line is a middleware that takes care of hooking up all requests
to the server to some specific razor page. Something to bear in mind though,
this had a different name before, it was `UseStaticFiles()`.

Under `wwwroot` we can nest many folders to keep things organized, but it's not
a hard requirement. For example, the scaffolded project has bootstrap in here,
as well as the root `css` file.

The course already provides for some images, these images are of the cities that
we have under `CitiesRepository.cs`. In order to style really good the buttons alongside
the city photos, we can use a bootstrap component called `Card`, by googling this
we can copy the boilerplate code straight from Bootstrap's page:

[source, razor]
----
@foreach (var city in cities)
        {
            <div class="col">
                <div class="card">
                    <img class="card-img-top" src="@($"/images/{city}.png")" alt="Card image cap"> <.>
                    <div class="card-body">
                        <button type="button" class="btn btn-primary">@city</button>
                    </div>
                </div>
            </div>
        }
----
<.> All of the other HTML code is redundant to explain, the meat of everything is here,
this is how we can access static resources, at the beginning we have `/` which means
we start from the `root`. The folder were we should place the images is `wwwroot`,
you can make the connection that way. And once we are there we can start building the
paths to the static resources depending on if things are nested or not. Pretty
neat. String interpolation comes back in its **explicit syntax** so that we can
evaluate a specific variable value but have it be interpolated accordingly.

==== Assignment 2: Create a routable component

We have to create a routable component that we can redirect through the different
elements on the list of servers. Use Bootstrap LinkButton, click and then replace
the content with a new dummy "Add Server" button.

I chose a "badge". The issue is that the course is definitely with an Old Bootstrap
version, (3 - 4), and the newest version (5) has differences in class names.

https://getbootstrap.com/docs/4.0/components/badge/#links[Links Bootstrap 4]

https://getbootstrap.com/docs/5.3/components/badge/#pill-badges[Links Bootstrap 5]

In the currrent project if trying to use `<a href="#" class="badge badge-primary">Primary</a>`
then the styling wouldn't work at all. And so had to go into the Bootstrap 5 docs
to see the valid class name: `<a href="/add-server" class="badge bg-primary">Add Server</a>`

==== Assignment 2: Answer

. Create a Page component under `Pages` (Remember that by convention these components
don't have the `Component` suffix)
. So the course was unclear, it was an `Edit` page.

The files would look like something like this:

[source, razor]
.Pages/EditServer.razor
----
@page "/servers/edit" <.>
<h3>AddServer</h3>

@code {
    
}
----
<.> This marks this component as to something that will respond to a server call
to /servers/edit.

[source, razor]
.Servers.razor
----
@foreach (var server in servers)
    {
        <li>
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
            <a href="/servers/edit" class="btn btn-link">Edit</a> <.>
        </li>
    }
----
<.> This is a bit "unconventional" in the sense that it could be an actual button
and not an anchor link, but I guess that due to web standard's defaults we will
trigger a call to the server that will then route to our created component. The
`btn btn-link` styles work just fine in Bootstrap 5. Another thing worthy of note
is that in order for us to build the different routes that will then map to
pages, is to start at root always `/`, and then build the respective route.

[NOTE]
====
The course uses this hack way of adding artificial spaces with `&nbsp;`. Again, this
is not a good practice for web dev in any shape or form.
====

Besides that, the instructor expands on adding a link in the navbar at the left
so that we can actually see the list of servers that up until now we have simply
accessed by writing manually the route on the browser.

Now, the way to build your way to the respective file that we need to edit. You
have to start at the root `App.razor`. Remember that in there there's a `<Routes/>`
component.

The routes component has this code:

[source, razor]
.Routes.razor
----
<Router AppAssembly="typeof(Program).Assembly">
    <Found Context="routeData">
        <RouteView RouteData="routeData" DefaultLayout="typeof(Layout.MainLayout)"/> <.>
        <FocusOnNavigate RouteData="routeData" Selector="h1"/>
    </Found>
</Router>
----
<.> For now, the only important part of the code is this `Layout.MainLayout` line,
this is what will be rendered in place of `<Routes />`, this component is under
`Components > Layout > MainLayout.razor`.

And under here by reading the razor code you can notice a component with styling
such as `sidebar` and this pointing to a `<NavMenu />`, component that conveniently
is under the same `Layout` folder. This is the code with a plus entry for accessing
the `/servers` route:

[source, razor]
.NavMenu.razor
----
<div class="top-row ps-3 navbar navbar-dark">
    <div class="container-fluid">
        <a class="navbar-brand" href="">ServerManagement</a>
    </div>
</div>

<input type="checkbox" title="Navigation menu" class="navbar-toggler"/>

<div class="nav-scrollable" onclick="document.querySelector('.navbar-toggler').click()">
    <nav class="nav flex-column">
        <div class="nav-item px-3">
            <NavLink class="nav-link" href="" Match="NavLinkMatch.All">
                <span class="bi bi-house-door-fill-nav-menu" aria-hidden="true"></span> Home
            </NavLink>
        </div>

        <div class="nav-item px-3">
            <NavLink class="nav-link" href="weather">
                <span class="bi bi-list-nested-nav-menu" aria-hidden="true"></span> Weather
            </NavLink>
        </div>
        
        <div class="nav-item px-3">
            <NavLink class="nav-link" href="servers"> <.>
                <span class="bi bi-list-nested-nav-menu" aria-hidden="true"></span> Manage Servers <.>
            </NavLink>
        </div>
    </nav>
</div>
----
<.> The route resolve works both for `/servers` or `servers`.
<.> And under here we can add the new entry that should redirect us to the server
list page, this has a label of `Manage Servers`.

==== Route Parameters and Route Constraints

We have created the routable component, we can navigate to it, but we don't have
any idea of how to know what server are we editing.

The way to pass information from one page to the next one (one of the ways) is
through the url (a route parameter). So we want to be able to put `/servers/edit/1`
and then be on a routed component that has now the information of server 1 to
edit.

The way to prepare our triggering page to then go into the respective url we would
do something like this:

````
<a href="/servers/edit/@server.Id" class="btn btn-link">Edit</a>
````

This is at `Servers.razor`, as you can see we are using implicit syntax to then
be able to dynamically retrieve the `Id` of the server so that it then routes back
to the routable component with that specific server state loaded.

If we hover over the link we would see the link ending with `1, 2, 3, etc...`.
Now of course, if we click the link we would get hit with a 404. But wiring this
up is pretty easy.

On the receiving page you should mark one of the resource levels with a specific
syntax:

[source, razor]
.AddServer.razor
----
@page "/servers/edit/{id}" <.>
<h3>AddServer</h3>
<br/>
@Id <.>

@code {
    [Parameter] <.>
    public string Id { get; set; } = string.Empty;
}
----
<.> In here between curly braces you can give a name to whatever route parameter
you are setting the page to accept.
<.> And with implicit syntax we can then test and print the receiving value that
should be bound to the url's route parameter.
<.> And lastly so that we bind everything correctly, we have to decorate a property
with `[Parameter]`, in this case we are binding to a `string` since that will take
whatever.

After setting this, we should be able to access the respective server's edit page,
and we should be rendering the respective ID that comes from the route parameter.

There's something odd here though, if we try and hit `/servers/edit` we will get
rendered `edit` which is odd, we are expecting only numbers here, luckily there
is a feature to apply constraints to the route parameters. (We want only an integer).

These are called **Route Constraints**.

The way to add constraints is by appending a type:

````
@page "/servers/edit/{id:int}"
<h3>AddServer</h3>
<br/>
@Id

@code {
    [Parameter]
    public int Id { get; set; }
}
````
After a colon, you can add tons of constraints, in our case we are simply saying
that the route should be an `int` and of course the state variable should also
be of the respective type.

After this (probably restart the server, hot reload doesn't really work), and we
should be able to still navigate just fine, on top of getting a 404, or error
if trying to set the route to something like `edit/edit`. This makes it so that
our route constraint works.

The Microsoft Docs points to the different constraints that are supported at
its https://learn.microsoft.com/en-us/aspnet/core/blazor/fundamentals/routing?view=aspnetcore-9.0#route-constraints[website].
But they are not that complex, a route parameter should be akin to a primitive type
by convention and security.

An extra piece of info that is good to know is optional parameters:

[source, razor]
----
@page "/route-parameter-2/{text?}" <.>

<PageTitle>Route Parameter 2</PageTitle>

<h1>Route Parameter Example 2</h1>

<p>Blazor is @Text!</p>

@code {
    [Parameter]
    public string? Text { get; set; } <.>

    protected override void OnParametersSet() => Text = Text ?? "fantastic"; <.>
}
----
<.> If you want a route to take a possible null value as a route parameter, just
suffix it with a `?` mark.
<.> And of course, make the state variable match the route parameter with a nullable
type.
<.> Lastly, this might be a good recipe for further use cases down the line, we can
hook into the `OnParametersSet` method so that in case the route doesn't have
the respective parameter we coalesce its value to some default, this seems pretty
handy.

==== Use OnParametersSet to receive parameter value

Blazor has the concept of **Lifecycle events**, in this lesson we will leverage
`OnParametersSet` specifically to retrieve route parameter values.

_NOTE:_ There's a `OnParametersSetAsync` method.

Our Use Case requires for us to get the route parameter value and then load information
based on the `Id`, this info can be used for further logic and/or display purposes.

[source, razor]
----
@page "/servers/edit/{id:int}"
<h3>AddServer</h3>
<br/>
<p> <.>
    @_server?.Name
</p>
<p>
    @_server?.City
</p>
<p>
    @_server?.IsOnline
</p>

@code {
    [Parameter]
    public int Id { get; set; }
    
    private Server? _server { get; set; }

    protected override void OnParametersSet() <.>
    {
        _server = ServersRepository.GetServerById(Id); <.>
    }

}
----
<.> We could add a `if (server is not null)` but that's a bit Ugly I think, unless
there's a bigger render reason to not show a whole chunk of html, so using coalesce
like this is classier.
<.> The lifecycle hooks should always be overriden (and are protected), we shouldn't
have to call the base method since it's redundant.
<.> It is on the body of the lifecycle hook that we can then be sure that we have
the variable with the correct piece of data to then retrieve a server Id and save
the instance into a private member (a field).

This component should now display the server info as we expect it. We can even
add a `Go Back` button after that will throw us into the `/servers` page again.
And we can even style an anchor as if it were a button with `btn btn-primary`.

==== Use Form and Input components to display and collect data

Traditionally in Web Systems, an extremely important piece of interactivity are
**Forms**. And so these are built with native tags such as `<form>`, `<input>`,
`<button type="submit">`.

Because Blazor is a component-based web framework, Microsoft has already out-of-
the-box built-in componnets. Instead of plain html, we can use <EditForm>. This is
a built-in component that has tons of functionality already ready to be consumed
so we don't have to implement things from zero.

And for controls we have:

`<InputText>`
`<InputNumber>`
`<InputCheckbox>`

We can use these components inside of the form. We will display data, collect data
and everything.

By using the built-in form we save a lot of time specially for things such as
validation.

[source, razor]
----
@if (_server is null)
{
    return; <.>
}

<EditForm Model="_server"> <.>
    <InputText @bind-Value="_server.Name"></InputText> <.>
    <InputText @bind-Value="_server.City"></InputText>
    <InputCheckbox @bind-Value="_server.IsOnline"></InputCheckbox>
</EditForm>
----
<.> Learned this in prod :). A clean way of returning early and avoiding unnecessary
rendering.
<.> So there are different ways of binding models to the form, one of them is
with this `Model` attribute that we can bind to a state field, in this case is the
`_server` that we received from the repository.
<.> Lastly, we can then add inside different components for different controls
and the specific field they match to.

Now, if we wanted to make it look pretty, we can leverage Bootstraps form control
styles and other utilities:

[source, razor]
----
<EditForm Model="_server">
    <div class="row mb-3"> <.>
        <div class="col-2"> <.>
            <label class="col-form-label"> <.>
                Name
            </label>
        </div>
        <div class="col-6"> <.>
            <InputText class="form-control" @bind-Value="_server.Name"></InputText> <.>
        </div>
    </div>
    <div class="row mb-3">
        <div class="col-2">
            <label class="col-form-label">
                City
            </label>
        </div>
            <div class="col-6">
                <InputText class="form-control" @bind-Value="_server.City"></InputText>
            </div>
    </div>
    <div class="row mb-3">
        <div class="col-2">
            <label class="col-form-label">
                Online
            </label>
        </div>
        <div class="col-6">
            <InputCheckbox class="form-check-input" @bind-Value="_server.IsOnline"></InputCheckbox> <.>
        </div>
    </div>
</EditForm>
<a href="/servers" class="btn btn-primary ">Go Back</a>
----
<.> The layout calls for different rows for a control that holds both a `label` and
a `control`, so we would have 3 controls. The `row` style of boostrap simply states:
"The things inside should be on the same line (row), all of them will be referred
to as columns". `mb-3` simply adds 3 units of margin at the bottom.
<.> `col-2` simply states that this container will take 2-parts (cols) of the
12-part grid.
<.> `col-form-label` styles the `<label>` element so that it aligns properly
with the control (input)
<.> `col-6` simply states that this container will take 6-parts (cols) of the 12-part
grid.
<.> `form-control` Simply styles the control with Bootstrap's stuff
<.> `form-check-input` styles the control specifically for a checkbox with Bootstrap

[NOTE]
====
Overall, this is so cute, because it's really beginner code, we can definitely
abstract this even further so that we don't duplicate as much code. It's harder
to edit later.
====

**EXTRA:** This `12-grid` concept is a core concept special to **Bootstrap**. By
default Bootstrap divides every row into 12 equal parts horizontally. Every row
is 12 units wide, and the way you style child components will make them take more
or less space of that 12 unit space. _Why 12?_ It's flexible, you can divide it
evenly in many ways (apparently).

You can definitely check the code for Bootstrap's controls and other utility
classes at its https://getbootstrap.com/docs/5.3/forms/form-control/#example[docs].

Just remember that depending on your need, you can use different built-in control
components from Microsoft's Blazor Library and not have to worry of reinventing
the wheel.

==== Form submission and model binding

We are going to learn how to submit data, this is specifically for Blazor SSR,
with interactivity the process is quite different.

SSR = Is really similar to traditional web applications, a form submission is just
a traditional form submission.

A form is in the browser, when the user clicks a `submit` then the url, form values
are packed and sent to the server. When the server receives the HTTP request it
will process it.

Blazor SSR works the same, we should code a function and its paremeters so that
the logic gets triggered depending on the request that's coming into the server.

[source, razor]
----
@page "/servers/edit/{id:int}"
<h3>Edit Server</h3>
<br/>

@if (_server is null)
{
    return;
}

<EditForm Model="_server" FormName="formServer" OnSubmit="Submit"> <.>
    <div class="row mb-3">
        <div class="col-2">
            <label class="col-form-label">
                Name
            </label>
        </div>
        <div class="col-6">
            <InputText class="form-control" @bind-Value="_server.Name"></InputText>
        </div>
    </div>
    <div class="row mb-3">
        <div class="col-2">
            <label class="col-form-label">
                City
            </label>
        </div>
        <div class="col-6">
            <InputText class="form-control" @bind-Value="_server.City"></InputText>
        </div>
    </div>
    <div class="row mb-3">
        <div class="col-2">
            <label class="col-form-label">
                Online
            </label>
        </div>
        <div class="col-6">
            <InputCheckbox class="form-check-input" @bind-Value="_server.IsOnline"></InputCheckbox>
        </div>
    </div>
</EditForm>
<a href="/servers" class="btn btn-primary ">Go Back</a>

@code {
    [Parameter]
    public int Id { get; set; }

    [SupplyParameterFromForm(FormName = "formServer")] <.>
    private Server? _server { get; set; }

    private void Submit() <.>
    {
    }

    protected override void OnParametersSet()
    {
        _server = ServersRepository.GetServerById(Id);
    }

}
----
<.> So the `<EditForm>` component can receive two properties: `FormName` and `OnSubmit`.
One will help us identify the form in case there are multiple forms and this is a
unique identifier, on the other hand we have to supply a callback that will respond
when the form triggers a submit.
<.> We can leverage `SupplyParameterFromForm` and even specify the specific form name,
this is so that when a submission is triggered, and we need to map-out (bind) all the
form's state we can automatically bind it to a state property.
<.> Lastly we need to create the callback method that will be triggered on form
submission.

This way Blazor will have effectively wire everything so that the form submission
works as expected (as per convention).

The last component we need to but is a submit button actually: `<button class="btn btn-primary" type="submit">Update</button>`.
This is typical stuff, with the only difference is that it should be of `submit`
type.

_NOTE:_ Tried it with Rider, and we can debug Blazor (well at least this simple
project). So if we setup breakpoints in the `Submit` method, we should hit it
after pressing the submit button.

An interesting piece of behavior to highlight here is though that when we hit the
submit, as is, we will notice that the updated state from the view is not actually
being sent at the runtime of the `OnSubmit`. Well it _seems_ that way, but what's happening
is actually that `OnParametersSet()` overrides this value (so it runs before) the
`OnSubmit` gets triggered and we lose state. The easiest way to fix this is by
doing this:

````
protected override void OnParametersSet()
    {
        _server ??= ServersRepository.GetServerById(Id);
    }
````

By using this coalesce we will only try and hit the `ServersRepository` method if
`_server` is null, otherwise we will keep whatever value it had. This effectively
is a circuit-breaker so that we are not hitting always the repo in order to
get data.

A second interesting find, is that because we are doing this whole `SupplyParameterFromForm`,
the whole model will mapped to whatever the form has packaged, and one property
that we don't have right now available is `Id`. If we see the value of the `_server`
variable, we will see `Id = 0`. This is bad since it's not consistent, and if
we were to rely on this Id, it can easily become a bug.

And so, I remembered that in prod we also did this (which is bad), that is adding
a hidden field in the view so that the state is kept and bound correctly:

````
<InputNumber hidden="true" @bind-Value="@_server.Id"></InputNumber>
````

The `InputNumber` component is important since `Id` is an int property, if we
try and use a `TextInput` we will get compilation errors.

With this in mind, we can now code the submit logic.

[source, razor]
----
private void Submit()
    {
        if (_server is null) <.>
        {
            return;
        }
        
        ServersRepository.UpdateServer(_server.Id, _server); <.>
    }
----
<.> Don't forget about the return early principle. (else-less).
<.> And in here we simply update the respective server with its Id, and then
send the whole payload that will update the server.

In Blazor SSR a submission handler takes care of a form submission, there are
actually other types of submits for specific cases `OnValidSubmit`, `OnInvalidSubmit`.

Traditionally the "receive data of a form submission" is what we refer as **Model
Binding**. It's like a two-way data-binding. The moment the form is submitted
we bind all of the payload to a state variable.

==== Form Validations

==== Navigation with NavigationManager & Dependency Injection

==== Assignment 3: Add Server

==== Assignment 3: Answer

==== Use EditForm to delete data

==== Stream Rendering
