= Introduction

These are notes for different things found in the Blazor (.NET) component frontend
framework. As a starter, we will have notes on a https://www.udemy.com/course/blazor-deep-dive-from-beginner-to-advanced/[Udemy]
course.

== Blazor Deep Dive - From Beginner to Advanced in .NET 8

=== Course Content

==== NET 9 Updates

.NET 9 introduced a few changes to Blazor. These changes are minor however. One
thing worth of note though is that you should include **SSR (Server Side Rendering)**
in a Blazor app configured to use server interactivity with global location.

==== What is Blazor

TL;DR: Blazor is a **component based** SPA web application framework that achieves
interactivity with C#.

_Component based SPA web application framework:_ This differs from the traditional
web application paradigm (which is also the first one that was invented). In the
sense that we are not responding to individual pages that a server requests, and
then spits back to the client.

The user will send requests to the web server as well, however the web server will
route all requests to **ONE PAGE**. This is in theory called _the root component_,
but you can still define it as this _root page_. No matter how many requests are
sent, they will always go to one single page. The Blazor Framework will look for
different components, and it will then **place the component** inside the root
component.

A simple workflow would be:

1. A first request will go to the server, the server will then request for the
necessary components to render that path.
2. A second request will come and the server will "erase" the previous components
and render others that respond to that specific request. And so on.

Components are a powerful paradigm because you can nest components inside of other
components, effectively turning this structure as a **component tree**, the levels
and children will be mandated by requirements.

The main idea is that you should **think in components**. Blazor uses C# in order
to reach interactivity. React, Angular, Vue, etc all use **javascript**.

==== Choices of interactivity

What is _interactivity_?

E.g., If we have a page, and on this page we have a list, we want to allow users
to search on that list based on a filter, only matching results to the filter
should show up in the list. We would have a search bar, a button. In order to
add _reactivity_ or _interactivity_ normally you would start using javascript.
But in Blazor we achieve that with C#, and C# only. The main idea behind the
framework's design is to unify code as much as possible and not rely on Javascript,
(although you will be still using it in really specific edge cases).

There are different ways to implement interactivity with Blazor, the types of
interactivity are:

No interactivity (base):: This is one type, in case you don't need any sort of reactivity,
this is also called SSR (Static Server Side Rendering). In most use cases, you will
create a project with this default interactivity setting. You would only need to
add interactivity based on **requirements**.
Server Interactivity:: This will make the application to establish a SignalR channel
from server to client (this is a WebSocket implementation). This is like a P2P
communication and it needs to be sustained. In order for this channel to work,
a javascript file is created inside of the page that is being rendered on the
browser, **this is not created by a developer** but by the framework. Whenever the
user does something, the event will be handled by said javascript server and sent
to the backend server, to then make a decision. It will compare the previous state
of the page and then a newly calculated state, that difference is then sent back
to the client so that it can attach it and re-render the page on the fly. (No
reload of the whole page)
WebAssembly Interactivity:: This is based on Blazor SSR, the components that require
WASM will then get packaged with tons of extra DLLs and WASM files and sent back
to the browser. This is then leveraged by the browser in order to run the interactions.
A good point here is that WASM is way faster than javascript since it runs at almost
native speeds. There's another approach in which the whole component gets compiled
into WASM and that gets sent to the browser to then be interpreted and run. But
either way, **some kind of files will be downloaded from the server to the browser**
and these files will then be executed by the browser.

Blazor SSR = **BASE OF EVERYTHING** When Web Interactivity is required, you can
choose WASM, Server Interactivity or a hybrid model in which some "pages" and components
run on server and others on WASM.

==== Blazor SSR Project Structure

In order to start getting familiar with Blazor SSR, we will create some dummy project
and describe its components.

First of all, when creating a Blazor Web Application, starting on .NET 8 the recommended
template is simple **Blazor Web App**. There are other variations however that might
apply to specific use cases.

[IMPORTANT]
====
We will select the "Interactivity Mode" as `None`, this is the stock Server Side
Static Rendering (SSR). And it's recommended to start your project with this setting,
the other ones are _Server, WebAssembly, Auto (Hybrid)_. Many pages that you create
you will see that require no interactivity, meaning that by selecting `None` you
can add interactivity to components that actually need it.
====

After we create the project with a "Interactivity" set, it will not matter later.

**NOTE:** Just to get things straight, the entry point is `Program.cs`. The paradigm
is simple, we do a `app.Run()` and the app stays alive as if in a "for-loop" and
will pick up on any Http Request that comes in. Once a request comes in, it goes
through different functions, which are called _Middlewares_.

[source, csharp]
----
using ServerManagement.Components;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddRazorComponents();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error", createScopeForErrors: true);
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}

app.UseHttpsRedirection(); <.>


app.UseAntiforgery();

app.MapStaticAssets();
app.MapRazorComponents<App>(); <.>

app.Run();
----
<.> Something like this is a Middleware, a request that comes will pass through the
logic that's stated here and maybe get something added to it, or extracted, middlewares
are multi-purpose in nature.
<.> This is a pretty important line of code, this will map all the Http requests
to the `App` class.

If we go and analyze the `App.razor` file that should be under `Components`. We
should find something like this:

[source, razor]
----
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <base href="/"/>
    <link rel="stylesheet" href="@Assets["lib/bootstrap/dist/css/bootstrap.min.css"]"/>
    <link rel="stylesheet" href="@Assets["app.css"]"/>
    <link rel="stylesheet" href="@Assets["ServerManagement.styles.css"]"/>
    <ImportMap/>
    <link rel="icon" type="image/png" href="favicon.png"/>
    <HeadOutlet/> <.>
</head>

<body>
<Routes/> <.>
<script src="_framework/blazor.web.js"></script>
</body>

</html>
----
This isn't the only place that will have `html` code declared inside of it. The
specific notations such as `HeadOutlet` and `Routes` will later come into play
when dealing with the framework's functionalities.

[IMPORTANT]
====
The `App.cs` component/razor file, is actually the _ROOT COMPONENT_. In here we
will be rendering all the components, hence it's configured in a way such that
all Http requests are mapped to this very specific component. This is the **one page** 
of the SPA.
====

It's through `<Routes />` that then the root component can resolve/render corresponding
components that respond to different routes.

Now this component can also be read, it should be right next to the `App.razor`
file.

[source, razor]
====
<Router AppAssembly="typeof(Program).Assembly">
    <Found Context="routeData">
        <RouteView RouteData="routeData" DefaultLayout="typeof(Layout.MainLayout)"/> <.>
        <FocusOnNavigate RouteData="routeData" Selector="h1"/>
    </Found>
</Router> <.>
====
<.> A key concept here is `DefaultLayout="typeof(Layout.MainLayout)"` this notation
specifically makes it so that the component will be spat out as HTML to the browser.

And so, in short, all the routes here will respond to a specific set of components
or "screens". Depending on the route that the server got, then all the respective
**content** will be displayed/replaced on the place that holds the `<Routes />`
tag.

The `MainLayout`, so the actual code that will render HTML can also be visualized
under `Components > Layout > MainLayout.razor`. Technically all blazor components
are under `.razor` files.

[source, razor]
.MainLayout.razor
====
@inherits LayoutComponentBase

<div class="page">
    <div class="sidebar">
        <NavMenu/>
    </div>

    <main>
        <div class="top-row px-4">
            <a href="https://learn.microsoft.com/aspnet/core/" target="_blank">About</a>
        </div>

        <article class="content px-4">
            @Body <.>
        </article>
    </main>
</div>
====
<.> The `@Body` annotation/tag is a really important piece of notation to keep in
mind, it's a placeholder for **any component**, no matter what type of component
is required by the user, it will come in here and replace the placeholder.

This is the _basic, theoretical flow_:

. Request comes into `Program.cs`
. Request goes to `App.razor`
. Goes to the `Routes.razor`
. Goes to `MainLayout.razor`

And through it all, it will render and swap out placeholders and places on each
layer respectively.

If you run the application, we should see both a terminal session and a web site
on our Default Browser.

The terminal holds some bits of info that's great:

. It will tell us at which ports the Blazor App is running
. It will also tell us which is the Root Page (component)

In short, the `MainLayout.razor` site renders a side bar, and then has content
that will change based on the route. This is how it all works, if you inspect
the HTML you will see how this rings true, how the sidebar is effectively **static**.

It's however Blazor that under the scenes takes care of replacing content based
on the routes.

This is the basic SSR setup, if we want WASM interactivity we will need to add a
second project, but overall it will remain the same. Hence it's said that
`SSR is the base of everything else`.

=== Blazor SSR

==== Two Types of Components

There are two types:

Routable Components:: Also called _Page Components_. This will respond directly
to a route.
Non-Routable Components:: Also called _Reusable Components_. These are used inside
routable components, and also inside of other non-routable components.

So, let's start playing around with the components and features. Say, we want to
create a Page that will respond to a new route. We should then create a `.razor`
file inside of `Pages`. Something like `Servers.razor`. You should _technically_
always create a _Razor Component_. But it's through anotations and other things
that we establish a routable and non-routable component and so on.

If we create with the scaffold:

[source, razor]
====
@page "/Servers" <.>
<h3>Servers</h3>

@code {
    
}
====
<.> This is the single most important thing that marks a component as a `routable
component`.

After adding this new component, and reloading the web site, we can manually type
`/servers` at the URL bar, if we get something rendered (in this case a simple heading
with `Servers`), then everything is working as expected.

We will now create a non-routable component, the course's convention is creating
a folder called `Controls`. And inside adding a `.razor` file. All of the components
inside should be _non-routable_. Another convention is to always suffix these components
with `Component` e.g., `ServerComponent.razor`

Once we create this component we can add some code to it to see if it renders, and
after that we can then use this component inside of any of our pages. In this case
if we were to put it into `Servers.razor`:

[source, razor]
====
@page "/servers"
@using ServerManagement.Components.Controls <.>

<h3>Servers</h3>
<br/>
<br/>
<ServerComponent/> <.>

@code {

}
====
<.> You could just import the namespace like this, but there's a more clean and
recommended way.
<> And here you can just write the component name with this syntax (that's really
close to how React would do it, or even Angular for that matter)

The better and cleaner approach to imports is to put the namespace import under the
`_Imports.razor` component that should be at the root of the `Components` folder.
In here you woul see things such as:

[source, razor]
====
@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using static Microsoft.AspNetCore.Components.Web.RenderMode
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.JSInterop
@using ServerManagement
@using ServerManagement.Components

@using ServerManagement.Components.Controls <.>
====
<.> This import can indeed be powerful, because, if by convention we create
all re-usable components under this namespace, next time, when trying to call them
from other components or pages, we won't have to always be importing them, this
centralized the import and makes things leaner.
====

If you were to declare `<ServerComponent />` twice, then its content should be
replicated normally. This is a reusability example, _don't forget about that_.

==== Razor Syntax Implicit Razor Expression

Blazor achieves interactivity with C#, this is at the frontend level. However
at the backend we also use C#, how will that work?

So that we can start using C# code we have to leverage **Razor Syntax**

[source, razor]
====
<p>
    @status <.>
</p>

@code {
    private string status = "Server is offline"; <.>
}
====
<.> This is called _implicit syntax_ we can reference variables that are written
in C# directly on the `HTML` part.
<2> As you can see we are using C# code here to assign a value to then be rendered.

We can then concatenate both HTML and "evaluation code". `@status at @DateTime.Now`.
Whenever there's an `@` then this is actually syntax that tells Blazor that something
from C# needs to come here (and be evaluated).

[NOTE]
====
Okay, thank god that Hot Reload is a _thing_. Hopefully it's stable now in .NET
9. https://learn.microsoft.com/en-us/aspnet/core/test/hot-reload?view=aspnetcore-9.0[hopefully].
====

The course leans heavily on this process of "Apply a change, restart the server",
and that is _so slow_. The industry standard should be hot reload (React, Angular
had over Blazor a long time ago). The way to _enable_ hot reload is to simply run
the application with `dotnet watch` this will keep a demon checking for changes
on the source code files, and if it's detected then it will auto reload itself,
in case something really critical is updated it will prompt the user to please
reload manually (better than wasting time).
====

What if we wanted to leverage some class? We can then create a model (POCO) under
something like `Models`. A typical POCO with `ServerId, City, Name` perhaps.
Nothing out of the ordinary.

And then we can reference it in our component like so:

[source, csharp]
.ServerComponent.razor
----
<p>
    @server.Name is in @server.City
</p>

@code {
    private Server server = new()
    {
        Name = "Server 1",
        City = "Toronto"
    };
}
----
As you can see, we are using **implicit syntax**, and after spaces then the evaluation
stops, hence always before spaces we should reference expressions that are C#
code related. We can use the **implicit syntax** under any HTML by the way, not
just paragraphs (`<p>`). This can even be evaluated on HTML properties.

And again, we should add its namespace to the `_Imports.razor` component so that
globally any model we add we can seamlessly consume from anywhere and removing
the need to import it always.

==== Razor syntax Explicit Razor Expression

The Razor expression would be limited if we only had the implicit type, since we
can't really do anything with logic or concatenation since a **space** literally
marks it as finished. And it's due to this that an _explicit expression is necessary_.

[source, razor]
====
<p>
    @server.Name is in @server.City that is @(server.IsOnline ? "online" : "offline") <.>
</p>

@code {
    private Server server = new()
    {
        Name = "Server 1",
        City = "Toronto"
    };
}
====
<.> With the `@()` syntax you can easily write more explicit code and logic so that
some rendering is applied based on pre-existing conditions. We can use the explicit
syntax even on attributes for an html element. Any C# expression can be used inside the
`@()`.

See how explicit syntax can be so powerful that it can literally be used for conditional
rendering and styling:

[source, razor]
====
<div style="color: @(server.IsOnline ? "green" : "red")" data-name="@server.Name" data-status="@(server.IsOnline ? "online" : "offline")"> <.>
    @server.Name is in @server.City that is @(server.IsOnline ? "online" : "offline")
</div>

@code {
    private Server server = new()
    {
        Name = "Server 1",
        City = "Toronto"
    };
}
====
<.> In here under a `style` we can literally conditionally apply a color or something
alike. It's extremely powerful.

_NOTE:_ We can also use a direct object for style: `style="@($"color: {(server.IsOnline ? "green" : "red")}")"`,
the thing with this syntax though is that we can nest another "evaluation expressions"
inside of the existing @() part. So this is a great way to keep adding more complex
condition paths in the same structure.

The Razor expression syntax has tons of power when it comes to rendering things
with C# code and bound objects.

==== Create a static data repository

In order to keep exploring Blazor's capabilities we can now create a mode for
mocking data. In our case we'll use the Repository pattern to create a `ServersRepository.cs`
class.

There's nothing worth of note here, more than a simple CRUD but that's managing
a static list in memory. We won't connect to some backing service since the focus
of the whole course is Blazor, we just need a source of data.

==== Razor Syntax Output list with looping

We are going to use looping to output a list inside of a Razor component.

[source, razor]
----
@page "/servers"

<h3>Servers</h3>
<br/>
<br/>
<ul>
    @foreach (var server in servers) <.>
    {
        <li>
            @server.Name in @server.City is <.>
            <span style="color: @(server.IsOnline ? "green" : "red")"> <.>
                @(server.IsOnline ? "online" : "offline")
            </span>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
}
----
<.> Se use the `@foreach` control directive to then loop over a list and render
_repeatedly_ HTML elements as we see fit (per entry of the list).
<.> We will then have code that can easily resemble what we already saw previously
but now applied to this new "iterative logic".

==== Assignment 1: Output city buttons list

We are going to output city buttons.

The idea is to practice the `@foreach` loop syntax, the rules are as follows:

. We are going to create a city model
. We will create a city repository
. We will output the cities as lists

We will work with static lists, so under `Models > CitiesRepository.cs` we will
simply have a string list with city names.

==== Assignment 1: Answer

Under the `Servers.razor` file:

[source, razor]
----
@page "/servers"

<h3>Servers</h3>
<br/>
<br/>
<ul>
    @foreach (var city in cities)
    {
        <button type="button">@city</button> <.>
    }
</ul>
<ul>
    @foreach (var server in servers)
    {
        <li>
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
    private List<string> cities = CitiesRepository.Cities;
}
----
<.> This is something that works just fine, BUT, Blazor by default comes with
bootstrap already installed, so we can style this with `class="btn btn-primary"`.

Now, the course does really hacky stuff, in order to add a space between the buttons
it uses this interesting syntax called `<text></text>` that you can use to enclose
some special characters, I guess that's, cool? Don't really know. But we can style
components as we would without issue by creating a file like:

````
|-- Servers.razor
|-- Servers.razor.css
````

And in there we can start adding as much styling as we want to, by default Blazor
will then compile this into isolated CSS so we shouldn't class with other styles
and we will keep things lean.

[NOTE]
====
IF YOU CAN'T SEE THE STYLES GETTING APPLIED/LOADED THAT'S PROBABLY BECAUSE YOU HAVE
TO RELOAD THE WHOLE APP. This is dumb, tbh, the hot reload doesn't pick up on
styles apparently, so it's not that "scoping is not working", it's more so that
we have to work with manual restarts
====

This is how the component code would look like:

[source, razor]
----
@page "/servers"

<h3>Servers</h3>
<br/>
<br/>
<ul class="button-list">
    @foreach (var city in cities)
    {
        <li> <.>
            <button type="button" class="btn btn-primary">@city</button> <.>
        </li>
    }
</ul>
<br/>
<br/>
<ul>
    @foreach (var server in servers)
    {
        <li>
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
    private List<string> cities = CitiesRepository.Cities;
}
----
<.> By convention, and to avoid errors, you should only have direct children of
a <ul>, <li> elements, inside of those elements you can then do whatever you want.

And the css that would make the buttons look nice and also use good css practices:

[source, css]
----
.button-list {
    display: flex;
    gap: 1rem;
    list-style: none;
    padding: 0;
}

.button-list li {
    display: flex; /* ensures buttons align neatly */
}
----
Since we have to work our way around the list elements, the default css will
add bullet points so we have to get rid of them with `list-style: none`, plus
no default padding: `0`. And so that the buttons, or the children elements align
neatly we will also apply a `display: flex` property to all of them. And the
different with a simple `<button>` is that the content will not have a padded
button at the beginning, this will neatly fit into the whole container.


**NOTE:** So, an interesting thing and piece of info in general is that the course
uses a bootstrap property to literally make the buttons change their layout as the
screen gets smaller, this is with a bootstrap class `container-fluid` apparently,
and it doesn't use a list it uses a div and inside of it buttons, then the buttons
stack up as the screen gets smaller, which is cool, I guess.

[source, razor]
----
@page "/servers"

<h3>Servers</h3>
<br/>
<br/>
<div class="container-fluid text-center"> <.>
    <div class="row w-50"> <.>
        @foreach (var city in cities)
        {
            <div class="col"> <.>
                <button type="button" class="btn btn-primary">@city</button>
            </div>
        }
    </div>
</div>
<br/>
<br/>
<ul>
    @foreach (var server in servers)
    {
        <li>
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
    private List<string> cities = CitiesRepository.Cities;
}
----
<.> So `container-fluid` simply makes a full-width content wrapper with padding.
<.> After that we are creating another `div` that I think could be simplified into
one div. But anyway, this has the `row` class with something that lets it grow
only until half the view port (width: 50%).
<.> Inside of this parent we have `class="col"` which are containers that help
everything stack as the screen grows larger or smaller. It's a bit magical since
you get these behaviors by applying bootstraps built-in classes, but... yeah. Trying
to replicate the same behavior and styling requires more in raw css, but again,
you can simplify so much and not be as bloated.

==== Working with Static Resources

Before going further into development, we need to learn another convention established
by Blazor. And that's a folder for static resources that the server can resolve
automatically, for that we need to have a look at the `Program.cs` file again:

[source, cs]
----
using ServerManagement.Components;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddRazorComponents();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error", createScopeForErrors: true);
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}

app.UseHttpsRedirection();


app.UseAntiforgery();

app.MapStaticAssets(); <.>
app.MapRazorComponents<App>(); <.>

app.Run();
----
<.> Just like the razor components middleware this takes care of configuring the app
so that all files under `wwwroot` are served by the server automatically (it can
resolve the static resources correctly). Without this middleware we wouldn't be
able to reference a resource and have that being retrieved by the server just fine.
<.> Remember, this line is a middleware that takes care of hooking up all requests
to the server to some specific razor page. Something to bear in mind though,
this had a different name before, it was `UseStaticFiles()`.

Under `wwwroot` we can nest many folders to keep things organized, but it's not
a hard requirement. For example, the scaffolded project has bootstrap in here,
as well as the root `css` file.

The course already provides for some images, these images are of the cities that
we have under `CitiesRepository.cs`. In order to style really good the buttons alongside
the city photos, we can use a bootstrap component called `Card`, by googling this
we can copy the boilerplate code straight from Bootstrap's page:

[source, razor]
----
@foreach (var city in cities)
        {
            <div class="col">
                <div class="card">
                    <img class="card-img-top" src="@($"/images/{city}.png")" alt="Card image cap"> <.>
                    <div class="card-body">
                        <button type="button" class="btn btn-primary">@city</button>
                    </div>
                </div>
            </div>
        }
----
<.> All of the other HTML code is redundant to explain, the meat of everything is here,
this is how we can access static resources, at the beginning we have `/` which means
we start from the `root`. The folder were we should place the images is `wwwroot`,
you can make the connection that way. And once we are there we can start building the
paths to the static resources depending on if things are nested or not. Pretty
neat. String interpolation comes back in its **explicit syntax** so that we can
evaluate a specific variable value but have it be interpolated accordingly.

==== Assignment 2: Create a routable component

We have to create a routable component that we can redirect through the different
elements on the list of servers. Use Bootstrap LinkButton, click and then replace
the content with a new dummy "Add Server" button.

I chose a "badge". The issue is that the course is definitely with an Old Bootstrap
version, (3 - 4), and the newest version (5) has differences in class names.

https://getbootstrap.com/docs/4.0/components/badge/#links[Links Bootstrap 4]

https://getbootstrap.com/docs/5.3/components/badge/#pill-badges[Links Bootstrap 5]

In the currrent project if trying to use `<a href="#" class="badge badge-primary">Primary</a>`
then the styling wouldn't work at all. And so had to go into the Bootstrap 5 docs
to see the valid class name: `<a href="/add-server" class="badge bg-primary">Add Server</a>`

==== Assignment 2: Answer

. Create a Page component under `Pages` (Remember that by convention these components
don't have the `Component` suffix)
. So the course was unclear, it was an `Edit` page.

The files would look like something like this:

[source, razor]
.Pages/EditServer.razor
----
@page "/servers/edit" <.>
<h3>AddServer</h3>

@code {
    
}
----
<.> This marks this component as to something that will respond to a server call
to /servers/edit.

[source, razor]
.Servers.razor
----
@foreach (var server in servers)
    {
        <li>
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
            <a href="/servers/edit" class="btn btn-link">Edit</a> <.>
        </li>
    }
----
<.> This is a bit "unconventional" in the sense that it could be an actual button
and not an anchor link, but I guess that due to web standard's defaults we will
trigger a call to the server that will then route to our created component. The
`btn btn-link` styles work just fine in Bootstrap 5. Another thing worthy of note
is that in order for us to build the different routes that will then map to
pages, is to start at root always `/`, and then build the respective route.

[NOTE]
====
The course uses this hack way of adding artificial spaces with `&nbsp;`. Again, this
is not a good practice for web dev in any shape or form.
====

Besides that, the instructor expands on adding a link in the navbar at the left
so that we can actually see the list of servers that up until now we have simply
accessed by writing manually the route on the browser.

Now, the way to build your way to the respective file that we need to edit. You
have to start at the root `App.razor`. Remember that in there there's a `<Routes/>`
component.

The routes component has this code:

[source, razor]
.Routes.razor
----
<Router AppAssembly="typeof(Program).Assembly">
    <Found Context="routeData">
        <RouteView RouteData="routeData" DefaultLayout="typeof(Layout.MainLayout)"/> <.>
        <FocusOnNavigate RouteData="routeData" Selector="h1"/>
    </Found>
</Router>
----
<.> For now, the only important part of the code is this `Layout.MainLayout` line,
this is what will be rendered in place of `<Routes />`, this component is under
`Components > Layout > MainLayout.razor`.

And under here by reading the razor code you can notice a component with styling
such as `sidebar` and this pointing to a `<NavMenu />`, component that conveniently
is under the same `Layout` folder. This is the code with a plus entry for accessing
the `/servers` route:

[source, razor]
.NavMenu.razor
----
<div class="top-row ps-3 navbar navbar-dark">
    <div class="container-fluid">
        <a class="navbar-brand" href="">ServerManagement</a>
    </div>
</div>

<input type="checkbox" title="Navigation menu" class="navbar-toggler"/>

<div class="nav-scrollable" onclick="document.querySelector('.navbar-toggler').click()">
    <nav class="nav flex-column">
        <div class="nav-item px-3">
            <NavLink class="nav-link" href="" Match="NavLinkMatch.All">
                <span class="bi bi-house-door-fill-nav-menu" aria-hidden="true"></span> Home
            </NavLink>
        </div>

        <div class="nav-item px-3">
            <NavLink class="nav-link" href="weather">
                <span class="bi bi-list-nested-nav-menu" aria-hidden="true"></span> Weather
            </NavLink>
        </div>
        
        <div class="nav-item px-3">
            <NavLink class="nav-link" href="servers"> <.>
                <span class="bi bi-list-nested-nav-menu" aria-hidden="true"></span> Manage Servers <.>
            </NavLink>
        </div>
    </nav>
</div>
----
<.> The route resolve works both for `/servers` or `servers`.
<.> And under here we can add the new entry that should redirect us to the server
list page, this has a label of `Manage Servers`.

==== Route Parameters and Route Constraints

We have created the routable component, we can navigate to it, but we don't have
any idea of how to know what server are we editing.

The way to pass information from one page to the next one (one of the ways) is
through the url (a route parameter). So we want to be able to put `/servers/edit/1`
and then be on a routed component that has now the information of server 1 to
edit.

The way to prepare our triggering page to then go into the respective url we would
do something like this:

````
<a href="/servers/edit/@server.Id" class="btn btn-link">Edit</a>
````

This is at `Servers.razor`, as you can see we are using implicit syntax to then
be able to dynamically retrieve the `Id` of the server so that it then routes back
to the routable component with that specific server state loaded.

If we hover over the link we would see the link ending with `1, 2, 3, etc...`.
Now of course, if we click the link we would get hit with a 404. But wiring this
up is pretty easy.

On the receiving page you should mark one of the resource levels with a specific
syntax:

[source, razor]
.AddServer.razor
----
@page "/servers/edit/{id}" <.>
<h3>AddServer</h3>
<br/>
@Id <.>

@code {
    [Parameter] <.>
    public string Id { get; set; } = string.Empty;
}
----
<.> In here between curly braces you can give a name to whatever route parameter
you are setting the page to accept.
<.> And with implicit syntax we can then test and print the receiving value that
should be bound to the url's route parameter.
<.> And lastly so that we bind everything correctly, we have to decorate a property
with `[Parameter]`, in this case we are binding to a `string` since that will take
whatever.

After setting this, we should be able to access the respective server's edit page,
and we should be rendering the respective ID that comes from the route parameter.

There's something odd here though, if we try and hit `/servers/edit` we will get
rendered `edit` which is odd, we are expecting only numbers here, luckily there
is a feature to apply constraints to the route parameters. (We want only an integer).

These are called **Route Constraints**.

The way to add constraints is by appending a type:

````
@page "/servers/edit/{id:int}"
<h3>AddServer</h3>
<br/>
@Id

@code {
    [Parameter]
    public int Id { get; set; }
}
````
After a colon, you can add tons of constraints, in our case we are simply saying
that the route should be an `int` and of course the state variable should also
be of the respective type.

After this (probably restart the server, hot reload doesn't really work), and we
should be able to still navigate just fine, on top of getting a 404, or error
if trying to set the route to something like `edit/edit`. This makes it so that
our route constraint works.

The Microsoft Docs points to the different constraints that are supported at
its https://learn.microsoft.com/en-us/aspnet/core/blazor/fundamentals/routing?view=aspnetcore-9.0#route-constraints[website].
But they are not that complex, a route parameter should be akin to a primitive type
by convention and security.

An extra piece of info that is good to know is optional parameters:

[source, razor]
----
@page "/route-parameter-2/{text?}" <.>

<PageTitle>Route Parameter 2</PageTitle>

<h1>Route Parameter Example 2</h1>

<p>Blazor is @Text!</p>

@code {
    [Parameter]
    public string? Text { get; set; } <.>

    protected override void OnParametersSet() => Text = Text ?? "fantastic"; <.>
}
----
<.> If you want a route to take a possible null value as a route parameter, just
suffix it with a `?` mark.
<.> And of course, make the state variable match the route parameter with a nullable
type.
<.> Lastly, this might be a good recipe for further use cases down the line, we can
hook into the `OnParametersSet` method so that in case the route doesn't have
the respective parameter we coalesce its value to some default, this seems pretty
handy.

==== Use OnParametersSet to receive parameter value

Blazor has the concept of **Lifecycle events**, in this lesson we will leverage
`OnParametersSet` specifically to retrieve route parameter values.

_NOTE:_ There's a `OnParametersSetAsync` method.

Our Use Case requires for us to get the route parameter value and then load information
based on the `Id`, this info can be used for further logic and/or display purposes.

[source, razor]
----
@page "/servers/edit/{id:int}"
<h3>AddServer</h3>
<br/>
<p> <.>
    @_server?.Name
</p>
<p>
    @_server?.City
</p>
<p>
    @_server?.IsOnline
</p>

@code {
    [Parameter]
    public int Id { get; set; }
    
    private Server? _server { get; set; }

    protected override void OnParametersSet() <.>
    {
        _server = ServersRepository.GetServerById(Id); <.>
    }

}
----
<.> We could add a `if (server is not null)` but that's a bit Ugly I think, unless
there's a bigger render reason to not show a whole chunk of html, so using coalesce
like this is classier.
<.> The lifecycle hooks should always be overriden (and are protected), we shouldn't
have to call the base method since it's redundant.
<.> It is on the body of the lifecycle hook that we can then be sure that we have
the variable with the correct piece of data to then retrieve a server Id and save
the instance into a private member (a field).

This component should now display the server info as we expect it. We can even
add a `Go Back` button after that will throw us into the `/servers` page again.
And we can even style an anchor as if it were a button with `btn btn-primary`.

==== Use Form and Input components to display and collect data

Traditionally in Web Systems, an extremely important piece of interactivity are
**Forms**. And so these are built with native tags such as `<form>`, `<input>`,
`<button type="submit">`.

Because Blazor is a component-based web framework, Microsoft has already out-of-
the-box built-in componnets. Instead of plain html, we can use <EditForm>. This is
a built-in component that has tons of functionality already ready to be consumed
so we don't have to implement things from zero.

And for controls we have:

`<InputText>`
`<InputNumber>`
`<InputCheckbox>`

We can use these components inside of the form. We will display data, collect data
and everything.

By using the built-in form we save a lot of time specially for things such as
validation.

[source, razor]
----
@if (_server is null)
{
    return; <.>
}

<EditForm Model="_server"> <.>
    <InputText @bind-Value="_server.Name"></InputText> <.>
    <InputText @bind-Value="_server.City"></InputText>
    <InputCheckbox @bind-Value="_server.IsOnline"></InputCheckbox>
</EditForm>
----
<.> Learned this in prod :). A clean way of returning early and avoiding unnecessary
rendering.
<.> So there are different ways of binding models to the form, one of them is
with this `Model` attribute that we can bind to a state field, in this case is the
`_server` that we received from the repository.
<.> Lastly, we can then add inside different components for different controls
and the specific field they match to.

Now, if we wanted to make it look pretty, we can leverage Bootstraps form control
styles and other utilities:

[source, razor]
----
<EditForm Model="_server">
    <div class="row mb-3"> <.>
        <div class="col-2"> <.>
            <label class="col-form-label"> <.>
                Name
            </label>
        </div>
        <div class="col-6"> <.>
            <InputText class="form-control" @bind-Value="_server.Name"></InputText> <.>
        </div>
    </div>
    <div class="row mb-3">
        <div class="col-2">
            <label class="col-form-label">
                City
            </label>
        </div>
            <div class="col-6">
                <InputText class="form-control" @bind-Value="_server.City"></InputText>
            </div>
    </div>
    <div class="row mb-3">
        <div class="col-2">
            <label class="col-form-label">
                Online
            </label>
        </div>
        <div class="col-6">
            <InputCheckbox class="form-check-input" @bind-Value="_server.IsOnline"></InputCheckbox> <.>
        </div>
    </div>
</EditForm>
<a href="/servers" class="btn btn-primary ">Go Back</a>
----
<.> The layout calls for different rows for a control that holds both a `label` and
a `control`, so we would have 3 controls. The `row` style of boostrap simply states:
"The things inside should be on the same line (row), all of them will be referred
to as columns". `mb-3` simply adds 3 units of margin at the bottom.
<.> `col-2` simply states that this container will take 2-parts (cols) of the
12-part grid.
<.> `col-form-label` styles the `<label>` element so that it aligns properly
with the control (input)
<.> `col-6` simply states that this container will take 6-parts (cols) of the 12-part
grid.
<.> `form-control` Simply styles the control with Bootstrap's stuff
<.> `form-check-input` styles the control specifically for a checkbox with Bootstrap

[NOTE]
====
Overall, this is so cute, because it's really beginner code, we can definitely
abstract this even further so that we don't duplicate as much code. It's harder
to edit later.
====

**EXTRA:** This `12-grid` concept is a core concept special to **Bootstrap**. By
default Bootstrap divides every row into 12 equal parts horizontally. Every row
is 12 units wide, and the way you style child components will make them take more
or less space of that 12 unit space. _Why 12?_ It's flexible, you can divide it
evenly in many ways (apparently).

You can definitely check the code for Bootstrap's controls and other utility
classes at its https://getbootstrap.com/docs/5.3/forms/form-control/#example[docs].

Just remember that depending on your need, you can use different built-in control
components from Microsoft's Blazor Library and not have to worry of reinventing
the wheel.

==== Form submission and model binding

We are going to learn how to submit data, this is specifically for Blazor SSR,
with interactivity the process is quite different.

SSR = Is really similar to traditional web applications, a form submission is just
a traditional form submission.

A form is in the browser, when the user clicks a `submit` then the url, form values
are packed and sent to the server. When the server receives the HTTP request it
will process it.

Blazor SSR works the same, we should code a function and its paremeters so that
the logic gets triggered depending on the request that's coming into the server.

[source, razor]
----
@page "/servers/edit/{id:int}"
<h3>Edit Server</h3>
<br/>

@if (_server is null)
{
    return;
}

<EditForm Model="_server" FormName="formServer" OnSubmit="Submit"> <.>
    <div class="row mb-3">
        <div class="col-2">
            <label class="col-form-label">
                Name
            </label>
        </div>
        <div class="col-6">
            <InputText class="form-control" @bind-Value="_server.Name"></InputText>
        </div>
    </div>
    <div class="row mb-3">
        <div class="col-2">
            <label class="col-form-label">
                City
            </label>
        </div>
        <div class="col-6">
            <InputText class="form-control" @bind-Value="_server.City"></InputText>
        </div>
    </div>
    <div class="row mb-3">
        <div class="col-2">
            <label class="col-form-label">
                Online
            </label>
        </div>
        <div class="col-6">
            <InputCheckbox class="form-check-input" @bind-Value="_server.IsOnline"></InputCheckbox>
        </div>
    </div>
</EditForm>
<a href="/servers" class="btn btn-primary ">Go Back</a>

@code {
    [Parameter]
    public int Id { get; set; }

    [SupplyParameterFromForm(FormName = "formServer")] <.>
    private Server? _server { get; set; }

    private void Submit() <.>
    {
    }

    protected override void OnParametersSet()
    {
        _server = ServersRepository.GetServerById(Id);
    }

}
----
<.> So the `<EditForm>` component can receive two properties: `FormName` and `OnSubmit`.
One will help us identify the form in case there are multiple forms and this is a
unique identifier, on the other hand we have to supply a callback that will respond
when the form triggers a submit.
<.> We can leverage `SupplyParameterFromForm` and even specify the specific form name,
this is so that when a submission is triggered, and we need to map-out (bind) all the
form's state we can automatically bind it to a state property.
<.> Lastly we need to create the callback method that will be triggered on form
submission.

This way Blazor will have effectively wire everything so that the form submission
works as expected (as per convention).

The last component we need to but is a submit button actually: `<button class="btn btn-primary" type="submit">Update</button>`.
This is typical stuff, with the only difference is that it should be of `submit`
type.

_NOTE:_ Tried it with Rider, and we can debug Blazor (well at least this simple
project). So if we setup breakpoints in the `Submit` method, we should hit it
after pressing the submit button.

An interesting piece of behavior to highlight here is though that when we hit the
submit, as is, we will notice that the updated state from the view is not actually
being sent at the runtime of the `OnSubmit`. Well it _seems_ that way, but what's happening
is actually that `OnParametersSet()` overrides this value (so it runs before) the
`OnSubmit` gets triggered and we lose state. The easiest way to fix this is by
doing this:

````
protected override void OnParametersSet()
    {
        _server ??= ServersRepository.GetServerById(Id);
    }
````

By using this coalesce we will only try and hit the `ServersRepository` method if
`_server` is null, otherwise we will keep whatever value it had. This effectively
is a circuit-breaker so that we are not hitting always the repo in order to
get data.

A second interesting find, is that because we are doing this whole `SupplyParameterFromForm`,
the whole model will mapped to whatever the form has packaged, and one property
that we don't have right now available is `Id`. If we see the value of the `_server`
variable, we will see `Id = 0`. This is bad since it's not consistent, and if
we were to rely on this Id, it can easily become a bug.

And so, I remembered that in prod we also did this (which is bad), that is adding
a hidden field in the view so that the state is kept and bound correctly:

````
<InputNumber hidden="true" @bind-Value="@_server.Id"></InputNumber>
````

The `InputNumber` component is important since `Id` is an int property, if we
try and use a `TextInput` we will get compilation errors.

With this in mind, we can now code the submit logic.

[source, razor]
----
private void Submit()
    {
        if (_server is null) <.>
        {
            return;
        }
        
        ServersRepository.UpdateServer(_server.Id, _server); <.>
    }
----
<.> Don't forget about the return early principle. (else-less).
<.> And in here we simply update the respective server with its Id, and then
send the whole payload that will update the server.

In Blazor SSR a submission handler takes care of a form submission, there are
actually other types of submits for specific cases `OnValidSubmit`, `OnInvalidSubmit`.

Traditionally the "receive data of a form submission" is what we refer as **Model
Binding**. It's like a two-way data-binding. The moment the form is submitted
we bind all of the payload to a state variable.

==== Form Validations

When the form is submitted we need to validate data. We will use annotations to
add this behavior, not an actual Blazor feature but a plain C# Data Anotation.

[source, csharp]
----
using System.ComponentModel.DataAnnotations; <.>

namespace ServerManagement.Models;

public class Server
{
    public Server()
    {
        var random = new Random();
        var randomNumber = random.Next(0, 2);
        IsOnline = randomNumber % 2 == 0;
    }
    
    public int Id { get; set; }
    
    public bool IsOnline { get; set; } <.>
    
    [Required] <.>
    public string? Name { get; set; }
    
    [Required]
    public string? City { get; set; }
}
----
<.> In order to work with the respective data anotations, we need to import this
specific namespace.
<.> The `bool` type has a `false` default value so it will always have a value, no
need to mark it as `[Required]`
<.> In the model that will be bound to the form we can add all the respective data
anotations we want so that the form is fed this metadata and tries to run validations
automatically against these specific rules.

You can read further at https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations?view=net-9.0[MS Docs],
specifically the `RequiredAttribute` link.

We have tons of attributes that we can use, [Compare Attributes, Display Attribute
(play with the label and the actual underlying value), StringLengthAttribute].
All of them have their own respective use case.

In our case we will use the `[Required]` data anotation, once we have set up all
of our logic. Now, in order to start applying the respective data anotation validations
we need to use a couple of extra components:

[source, razor]
----
<EditForm Model="_server" FormName="formServer" OnValidSubmit="Submit"> <.>
    <DataAnnotationsValidator></DataAnnotationsValidator> <.>
    <ValidationSummary></ValidationSummary> <.>
    // ...etc
----
<.> We can directly hook our method to `OnValidSubmit` so that we run our update
logic only when the form submission is successful (meaning no errors popped up on
model vlaidation). We have the option to hook into `OnInvalidSubmit` also.
<.> In order for the `<EditForm>` to sort of **gain** the ability to start validating
through the model's possible data anotations we need to add this inner component
inside of it (this pattern is pretty interesting, might have to keep it stored for
self-built components or overall a new pattern for approaching these types of use
cases).
<.> And lastly we can simply use a built-in component that spits all the errors
that it might find within the model based on the rules that Data Anotations might
express.

We can test out if our code actually works as intended by going to the website,
deleting the city and name fields and trying to submit. We should be seeing
both a message on red and then the respective fields highlighted with red, Blazor
should have abstracted all of the things that make this work in the background,
(classic Microsoft). We can check that we didn't actually trigger an update by
going back to the server list, we should see that nothing changed. And if we update
something that is valid, we should see the change coming through.

[source, razor]
----
<div class="row mb-3">
        <InputNumber hidden="true" @bind-Value="@_server.Id"></InputNumber>
        <div class="col-2">
            <label class="col-form-label">
                Name
            </label>
        </div>
        <div class="col-6">
            <InputText class="form-control" @bind-Value="_server.Name"></InputText>
        </div>
        <div class="col">
            <ValidationMessage For="() => _server.Name"></ValidationMessage> <.>
        </div>
    </div>
----
<.> Another special component is `ValidationMessage`, we can literally put it next
to control element and then through a Lambda expression point to the specific model
property that should be wired to.

_This is really cute_. But I get the principle. Again, abstract, make things easier
for the devs and all. But we are losing vital knowledge and experience in the way.
Anyway, this component will show a message in red and will also respond based on
the errors that the wired-up field presents.

[NOTE]
====
For the `IsOnline` field we don't have to do the whole `<ValidationMessage>` bit
technically, however for good measure we can add it.

I also just came to the realization that this is all in the default SSR mode,
with no reactivity in mind. Hence we have to do things so cutely (I'm assuming).
It's pretty close to normal HTML, faster and all. So depending on your requirement
you might switch the mode and add/subtract/change the conventions, and patterns
you use.
====

We are free to chose which component to use based on the requirements, never forget
about that.

==== Navigation with NavigationManager & Dependency Injection

We will talk about DependencyInjection, why? Because it's necessary to learn how
to hookup a component to DI services/components.

In short, we are required to somehow "programatically" trigger router navigation,
(this is really interesting now, the languages, frameworks, things might change,
but core concepts that respond to universal programming problems are still there,
you just need to learn how to represent that in a different language most of the
time).

We want to trigger RouterNavigation when we do an update on a server, this has
to be done behind the scenes, take the user to the servers screen to see the server
with hopefully the updated field.

_Cute Blazor:_ By adding a dependency injection component hot reload just doesn't
really work well, I think Microsoft was just too stubborn to realize that the way
they built this didn't account for market standards (React, Angular, Vue, Svelte),
and now have a half-measure for hot reload, but you are forced to keep on reloading
everything. (The con you take for not learning javascript I guess?).

How should we get the `NavigationManager` in our component to start routing:

[source, razor]
----
@inject NavigationManager NavigationManager <.>

// Code

private void Submit()
    {
        if (_server is null)
        {
            return;
        }

        ServersRepository.UpdateServer(_server.Id, _server);
        NavigationManager.NavigateTo("/servers"); <.>
    }
----
<.> This is Blazors solution to DI in a built-in way. The components are under the
hood just classes, and we want to move away from bad patterns of the past. We
want to invert dependencies.
<.> And after we have injected the `NavigationManager` we use the same name to
then start consuming the instance.

We don't want to have classes depend on other classes e.g., `var nav = new NavigationManager()`,
and Microsoft's philosophy is to always abstract things for devs and users so that
they are "easier". To a detriment sometimes, but that's besides the point. In this
attempt, DI is also taken care of for us through the Blazor framework, we just need
to know how to consume it and forget about the details, (abstraction). By inverting
dependencies here, we avoid memory leaks, and forget about lifecycle management
of another class from another class.

[IMPORTANT]
====
This is how under the hood Dependency Injection works:

We want to keep components loosely coupled, not depending between each other.
In order for that to happen we need to decouple them with depency inversion.
Who takes care of this is decided on the framework and designer's minds, but for
ASP.NET Core, which Blazor is a part of, we have an internal component called
"DI Container". This is the _thing_ that helps us inject the required instance
of a component inside of another component, and he will take care of lifecycle
management and all. `NavigationManager` is pre-registered in the DI Container,
that way we can focus entirely on building what matters and not worry too much
about these _"technicalities"_.
====

If we take a look at the `Program.cs` file, we can easily pinpoint the location
of the Dependency Container:

[source, cs]
.Program.cs
----
builder.Services.AddRazorComponents();
----

Inside of the `Services` proprety of the `builder` we are referencing this oh-so-called
mythical dependency container. If we drill down into its code we can see how this
collection abstracts things such as `TryAddSingleton<>`, `AddScoped<>`. These are
all calls to add services into the containers. Tying into the `AddScoped` call and
SignalR (which is what powers Blazor), we should be aware of one key thing: **SCOPED
SERVICES ARE ALIVE AS LONG SIGNALR HAS AN OPEN CHANNEL, ONCE IT CLOSES THE SERVICE
ALSO GETS GARBAGE COLLECTED**.

Reading further into subsequent calls of the code, we can see `services.TryAddScoped<NavigationManager, HttpNavigationManager>();`,
which is actually the `NavigationManager` that we injected into our blazor component.
As you can see, this is abstracted and ready for us to use, but it's still **GOOD
TO KNOW HOW IT WORKS UNDER THE HOOD**.

And yeah, this is all the knowledge you need as a base line. _Remember it_.

The `NavigationManager` is an abstract class, its almost an interface, the concrete
implementation in Blazor is `HttpNavigationManager`. Due to this design decision,
the framework has properly used best practices and correct implementations of
theory, it has effectively removed the dependency in a **concrete implementation**

**BIG TAKEAWAY:** So there's a reason for all of this.


[NOTE]
====
If we need to inject extra services we can add into the DI container with
`builder.Services.AddScoped<>`, `builder.Services.AddSingleton<>`. And always
as a best practice is to add an abstract/interface and then its concrete implementation,
that's the best way to align with clean code.
====

Infrastructure helps, .NET Core, helps with everything. Thanks.

==== Assignment 3: Add Server

We want to add a server.

- Adding a routable component
- Using Forms
- Using NavigationManager

Pretty straightforward, instructions not really clear, but I can only assume that
the city images when pressed on the button it will route back to the Add Server
component and have the city pre-filled. For whatever reason I can't map the
navigation though. It's just not working. Maybe SSR has to play a part in here???
Don't know.

Will have to look at the Answer, _as much as it pains me to do so_.

==== Assignment 3: Answer

AddServer is another routable component: So `Pages > AddServer.razor`. In a
real project, we have the option of turning the `EditServer.razor` in a multiple-purpose
component. But our requirement is constraining us.

But one key takeaway here is that if we are going to get a "multiple-purpose"
type of component this should be placed inside of a reusable components folder,
such as `Controls`.

The course made a mistake, it's setting the `IsOnline` to `false` in the object
initialization. But that's redundant, booleans have a `false` value by default
on C#.

A good point to bring up here and it's worth remembering.

`AddServer.razor` and `EditServer.razor` have repeated code (which is bad but we
are not focusing on this for now). They have the same form name, this is **OKAY**.
Because when we submit a form and the whole page gets packaged alongside the form and
its state, we will have the url as another way of differentiating the requests in
the server, there is no risk of **clashes**.

A couple of additions to the code based on the answer:

- We don't need to add the hidden _id field_, since the ID doesn't exist and will
be calculated on the Repository side.
- We should use the `[SupplyParameterFromForm]` anotation on the model that we have,
don't forget that after a submit the form state will bind to the property that
has this anotation.
- Lastly we need to navigate back to the servers list page with the `NavigationManager`

And this is where the nebulous requirement really messed me up, we are apparently
going to add a button for Add Server at the bottom, none of the fancy stuff I
was trying to do, I'm realizing that the list of cities is probably for filtering
purposes.

So yeah, pretty straightforward, just add an anchor to trigger navigation to the
AddServer page:

````
<a href="/servers" class="btn btn-primary ">Go Back</a>
````

And also the `IsOnline = false` behavior now is clear, because the default constructor
of the `Server` class actually by default turns the server on. But on this specific
page, we don't want that type of behavior, is weird since we will get the checkbox
already checked for us, so we are overriding it to set to false.

The behavior that should be working is that after we try and save the new server,
we should be seeing how the list gets a new line item.

==== Use EditForm to delete data

We will use the `EditForm` to delete data. In our domain, we will delete a server,
and at a technical level we will have to use the `EditForm` because we are with
Blazor SSR.

If we try and _not use the EditForm_, with code like this:

````
<button class="btn btn-primary" @onclick="@(() => DeleteServer(server))">Delete</button>

private void DeleteServer(Server server)
{
}
````

It won't work. Still it's good to breakdown what's happening here. In short, we have
this specific property that Blazor adds to Html elements `@onclick`. In here we
can simply declare a method name as the callback, or use this explicit syntax so
that we can insert a lambda function in order to pass arguments to the method call.

The reason this code won't work in SSR is because we have **NO INTERACTIVITY** at
all. This is all server side, and the `@onclick` syntax is something that assumes
we are going to handle things with javascript/code.

**IMPORTANT:** This is why we need to use our form component to submit the action
back to the server and then trigger the logic on the server side to handle this
deletion.

So the way to properly deal with our requirement under SSR we would have to
do the following:

[source, razor]
----
<ul>
    @foreach (var server in servers)
    {
        <li>
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
            <a href="/servers/edit/@server.Id" class="btn btn-link">Edit</a>
            <EditForm
                Model="server"
                FormName="@($"server-{server.Id}-form")" <.>
                OnValidSubmit="@(() => DeleteServer(server))"> <.>
                <button type="submit" class="btn btn-primary">
                    Delete
                </button>
            </EditForm>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
    private List<string> cities = CitiesRepository.Cities;

    private void DeleteServer(Server server)
    {
        if (server.Id <= 0)
        {
            return;
        }

        ServersRepository.DeleteServer(server.Id);
        servers = ServersRepository.GetServersByCity("Toronto"); <.>
    }

}
----
<.> This is an `<EditForm>` nested within another `<EditForm>`. And because this
is a multiple render piece of code, we would in theory be creating n forms per
line item, if the name is the same it would easily clash. Hence we are applying
explicit syntax on top of string interpolation to compose a _unique enough_ identifier
for the form.
<.> Hooking into `OnValidSubmit` we can then apply the lambda trick to call our
method with respective arguments.
<.> And in here the course varies with my choice, I say we simply update the state
with another retrieval of servers. The course actually injects the `NavigationManager`
and triggers a redirect to the same page. This should be more costly, wouldn't it?

In the end is the same result, but there's nuance to be taken here. We delete
a line item and somehow trigger an update to the page so that the new state is
reflected.

[NOTE]
====
Well, the course actually introduces `NavigationManager.Refresh()` which is good
to know it exists. Maybe it isn't as costly as a full-on navigation? Anywho, at
the time of the tutorial apparently Blazor had a bug and trying to call this method
resulted in an exception. Which is _interesting_. And so, as a workaround, it
actually uses `NavigationManager.NavigateTo("/servers")`.
====

[IMPORTANT]
====
Another piece of "good practices", it's explained that in theory we could literally
code a page that is just in charge of sending a delete signal to the server.
`@page /servers/delete`. Or something like that. But this is really bad because
it can easily be tampered with. Say we call it with an anchor link by passing a
server Id as a route parameter, this will be caught by the browser and a malicious
actor can literally start using it to delete all the data in the server. The form
submit is more secure, since it packages all the data under a `POST`, and the
URL and payload are not really visible. Therefore for deleting data this approach
is the recommended one.
====

With interactivity, this principle and good practices are kinda invalid though.

==== Stream Rendering

We have been using Blazor SSR. Each time we ask for something from the server
we get a response in return. One of the biggest issues of traditional web applications
and Blazor SSR as well is that if the server is under stress, then the response
from the server to the clients slows down. The UX is just waiting.

If we analyze the scaffolded `@attribute [StreamRendering]` from the `Weather.razor`
component. And remove it for testing purposes (because this attribute is specifically
there to solve this issue) we can start putting Blazor SSR to the test.

If we play around with the `NavBar` by clicking on `Home` and then on `Weather`
we will immediately pick up on a specific behavior. Even though we clicked on
the respective menu item, the screen kinda _freezes_ and it seems as though it's
stuck. (We also added a delay of 3 seconds to the code in the component that simulates
a delay responsed from the server). **This is the issue**, the UX ends up affected
negatively. We are waiting for data to come back from the server side so that
the browser renders the respective page.

Because everything renders statically, everything is retrieved from the page request.
Your hands are tied until the response comes back from the server.

[IMPORTANT]
====
However, Blazor SSR has a QoL. This is in the form of a javascript file that you can
easily point towards at `App.razor`. In there there's a line: `<script src="_framework/blazor.web.js"></script>`,
this adds a specific set of behaviors that help us get around this issue of traditional
static sites.
====

With this script, we can then add the attribute that we deleted before to test out
the "stuck" problem. And we see that even though the same delay might be there,
we get a UX that involves going into the page, and seeing some content but also a
`Loading...` message, and after the data is "available" the content gets rendered
accordingly. This is easily solvable by this sole attribute. And also the code
that takes care of showing the loading messages and then further content:

[source, razor]
----
@if (forecasts == null) <.>
{
    <p>
        <em>Loading...</em> <.>
    </p>
}
else
{
    // And in here is logic to show the Weather Forecast table
}
----
<.> As you can seem this is simple conditional rendering in case the state variable
is null, we will display some form of content and if not another form of content.
<.> This stock message of "Loading..." is displayed in case we don't have the list
of forecasts loaded just yet.

"If the data is loaded, it will show "Loading"". So for the use case of using
Blazor SSR, yet a requirement requires for you to run a long running process that
retrieves data or takes time to compute the data and you don't want that bad UX,
you should leverage this `StreamRendering` attribute and display these stock pieces
of content to feedback the user with "Loading".

=== Add Server Interactivity

==== What is interactivity

We need to answer another question first in order to answer "What is interactivity?"

_What is not interactive?_

In traditional static sites, you will send a request to the server and the server
will then respond and the whole page will be reloaded. And in certain use cases
it might feel as though you lost connection to the server for a bit. And this is
because the whole page gets packaged, gets sent, we get it back and re-render.

_The browser is doing something, and the process hangs_ **This is not smooth**.

One could argue that there **is** interactivity, between the user and the web
browser. But, when Microsoft refers to _interactivity_ in Blazor docs, it is
referencing to this idea of the UX not being _as smooth_, and this being qualified
as "not interactive".

An **interactive application** should work like a desktop application, it won't
get the whole page to get refreshed. In order to solve this issue, we can come
to one possible conclusion and that is that we should trigger a partial reload
of the page, update specific parts only. **Partial Page Rendering**, this is what
we call **_interactive_**.

_What is interactive?_

When we try to achieve partial rendering, we use Javascript. This leverages something
called the **DOM** (Document object model). The DOM is part of an HTML page, when
a user interacts with it, it is done by default, however this paradigm/idea takes
the premise that we should intercept the DOM interaction (between the user), and
once that interaction is captured, we will send a request to the backend server.

_Typically_ The Javascript would call a Restful API, wait for a response, get the
response, parse it, maybe process it a little bit and then use that data to **patch**
the DOM. When the patch is finished, we do a **partial re-rendering**, and the data
that the user expects is visualized.

_Traditionally:_ When wanting to add interactivity, a developer has to write
Javascript. However **Microsoft** provides a stock javascript that allows for the
developers to forget about writing javascript.

==== Use Enhanced Navigation in Blazor SSR for interactivity

This is the first step towards making a web app **interactive**.

We have to come clean about something though, this Enhanced Navigation is already
turned on by default on Blazor SSR, hence we are not seeing full page reloads even
when working with this stock, "simple" version of Blazor.

We can test this easily by just looking closely to how the page behaves, when trying
to press the nav bar buttons, we see that the navbar itself stays in place, we
don't get intermitent cuts that make apparent the whole page is being reloaded.

The page by default is **partially rendered**.

If we were to go to `App.razor` and delete the blazor javascript line, and then
reload the website, we can test with Dev Tools how the Network actually triggers
multiple calls, and even some interactions just break (look at the weather component).

If we analyze the Dev Tools again after adding back the blazor script. We will see
how one call is made and no other network call is detected. Another way to put this
thesis to the test is opening up the _Inspect_ section of the Dev Tools, in here
after navigating we can see how some HTML elements are re-rendered, not the whole
DOM.

**How does this work**

Whenever a user interacts with the DOM, an http request is supposed to go to the
server, but the Blazor javascript file intercepts this default behavior and then
sends a fetch to the server on its own. Once it gets back, then the Blazor script
smartly patches the DOM. (The DOM is partially rendered). With this model we reach
**interactivity**.

Blazor SSR by default with the _Enhanced Navigation_ is an **interactive application**
thanks to Blazor's javascript file in `App.razor`.

==== Use Enhanced form handling in Blazor SSR for interactivity

With the help of Enhanced Navigation, even on Blazor SSR devs can easily create
"interactive" web applications. However, this covers the navigation part of it solely.
The user can go from page to page, yet load static pages only in the end. What
if the user wants to do something _dynamic_?

I.e., If we click on the "Montreal" button on the servers page, we want to filter
all the servers in that city. This is an interaction that the user triggers on the
page, and in theory should then trigger a partial-reload of another part of the page.

With the help of **Enhanced Form Handling** even Blazor SSR can make a page dynamic.

We don't need anything fancy (no need of Web Assembly, no SignalR channel). We
can just use the `EditForm` component to achieve dynamic behaviors.

And so, first of all we are going to now start leveraging the `ServerComponent.razor`
component we created way back.

First render it in `Servers.razor`. And we will modify its code like this:

[source, razor]
.ServerComponent.razor
----
@if (server is null)
{
    return; <.>
}

<EditForm Model="server" FormName="serverComponentForm" OnSubmit="ChangeServerStatus"> <.>

    <div style="@($"color: {(server.IsOnline ? "green" : "red")}")" data-name="@server.Name"
         data-status="@(server.IsOnline ? "online" : "offline")">
        @server.Name is in @server.City that is @(server.IsOnline ? "online" : "offline")
        <button type="submit" class="btn btn-primary">Turn On/Off</button> <.>
    </div>
</EditForm>

@code {

    [SupplyParameterFromForm] private Server? server { get; set; } <.>

    private void ChangeServerStatus() <.>
    {
        if (server is null)
        {
            return;
        }

        server.IsOnline = !server.IsOnline;
    }

    protected override void OnParametersSet()
    {
        server ??= new Server <.>
        {
            Name = "Server1",
            City = "Toronto"
        };
    }

}
----
<.> Smart clean code to short circuit renders.
<.> We will leverage EditForm to submit but will add the smart/enhanced variation
for interactivity
<.> We want to bind all the form state to this model, so the respective parameter
should be set as well.
<.> And we will bind to the submisison of the form with a callback method.
<.> Lastly, we should leverage `OnParametersSet` as the hook to go into to initialize
our server, and that is because when we add the anotation for the model binding
of the form, this will be turned into a parameter, so a submission will trigger
this hook.

Now, if we try and run this as is, it won't work, because there are no fields whatsoever
inside of the form that hold values and that can then be bound to the model. We
have to imperatively add some sort of form fields, _this is hacky_.

````
<EditForm Model="server" FormName="serverComponentForm" OnSubmit="ChangeServerStatus">
    <InputNumber @bind-Value="server.Id" hidden></InputNumber>
    <InputText @bind-Value="server.City" hidden></InputText>
    <InputText @bind-Value="server.Name" hidden></InputText>
    <InputCheckbox @bind-Value="server.IsOnline" hidden></InputCheckbox>

    <div style="@($"color: {(server.IsOnline ? "green" : "red")}")" data-name="@server.Name"
         data-status="@(server.IsOnline ? "online" : "offline")">
        @server.Name is in @server.City that is @(server.IsOnline ? "online" : "offline")
        <button type="submit" class="btn btn-primary">Turn On/Off</button>
    </div>
</EditForm>
````

As you can see we are literally putting all the state fields under hidden fields,
(it's good to know that we can put a more concise type of attribute with just `hidden`).

And once we hit the submit, all these values will be bound to the respective model
properties. And after that, we will have the `OnSubmit` callback run its logic
to then modify the state variable accordingly. (And this will trigger a full page
re-render btw). Even the scroll position is lost. Logic works though.

_How do we make the page interactive?_

This is crazy dude:

````
<EditForm Enhance Model="server" FormName="serverComponentForm" OnSubmit="ChangeServerStatus">
````

Literally, one attribute `Enhance`. This could be `Enhance="true"`, but you know
how I like to be as concise as possible.

After adding this, then interactivity is figured out by Blazor without us having
to do anything fancy. Page is partially reloaded.

Again, this is all thanks to `blazor.web.js`, the script at `App.razor`.

These two features were added in `.NET 8` which is actually crazy. This is pretty
new. It's through SSR that we can achieve almost everything we want to achieve.

_But there's something even better:_ **Server Interactivity**

==== What is server interactivity?

In the previous sections we have talked about Enhanced Navigation and Enhanced
Form Handling. We have seen how interactivity is achieved.

But Server Interactivity, Server Interactive is something besides just a javascript
file that works with the DOM and backend server.

On this second paradigm, we still use the javascrip file, but the request and
responses are different. We don't work with HTTP, we work with Web Sockets, we
establish a SignalR channel.

The moment the application is loaded in the browser, the blazor javascript file
establishes this channel between the website and the server. A memory representation
of the web site on the server is created, and said memory representation will receive
all the requests coming from the website and process them respectively. One the
process is finished, a binary message will be returned to the **client**. The
JS script interprets the message, and **patches the DOM**.

The communication is different, and **THE BACKEND AS WELL BEHAVES DIFFERENTLY**.

The messages are binary, so fast, and very minimal, the whole process has been
optimized to its fullest extent (to date). Performance is not bad.

**_Render Tree:_** In the DOM (on the web browser) we have all elements grouped
together, nested and forming what it looks like a **tree**. In the backend when
the in-memory representation of the page, there's also a render tree **held in the
memory.**

The way the algorithm (really simply put) is that in-memory we will always hold a
"previous state render tree" and after processing a "new state render tree", Blazor
will calculate the difference between these two trees and package all that needs
to be updated on the web browser side so that a **smart patch** takes place. It will
only understand "one new component has been added". This has a term, "render tree
difference". The blazor javascript file understands this binary encoded difference
and acts accordingly. (Hence the user sees an update visually).

==== Enable Server Interactivity how to make a component interactive

How do we enable server interactivity?

We are going to make the `ServerComponent.razor` component interactive. (Whilst
it technically is already interactive with Enhanced Form submit, we want the actual
thing).

If we were to change the code a bit:

[source, razor]
----
@if (server is null)
{
    return;
}

<div style="@($"color: {(server.IsOnline ? "green" : "red")}")" data-name="@server.Name"
     data-status="@(server.IsOnline ? "online" : "offline")">
    @server.Name is in @server.City that is @(server.IsOnline ? "online" : "offline")
    <button type="button" class="btn btn-primary" @onclick="ChangeStatus">Turn On/Off</button> <.>
</div>

@code {

    [SupplyParameterFromForm]
    private Server? server { get; set; } = new()
    {
        Name = "Server1",
        City = "Toronto"
    };

    private void ChangeStatus() <.>
    {
        if (server is null)
        {
            return;
        }

        server.IsOnline = !server.IsOnline;
    }

}
----
<.> The `@onclick` syntax is something we use with Server interactivity.
<.> However there's an issue here, and that's that nothing will happen if we
press the button. And that is because we need to turn on Server Interactivity. Even
if you run the app in debug, breakpoints will never be hit.

How do you enable it? Just go to `Program.cs` and add these lines:

````
builder.Services.AddRazorComponents().AddInteractiveServerComponents();
// More code

app.MapRazorComponents<App>().AddInteractiveServerRenderMode();
````
**IMPORTANT:** We have to chain in a fluent way, otherwise we won't have access
to these methods.

With these two lines, we still won't get the button working. We actually have to
add this specific property:

````
<ServerComponent @rendermode="InteractiveServer"></ServerComponent>
````

The render mode will turn on or off the specific SignalR channel type of communication.

If you load the page, the button should work **and** if we analyze http requests
through the Dev Tools, no request should be getting registered. In order to see
the SignalR channel.

If we reload the web page and have a look at the _Network_ we will actually be
able to see how the website downloads the `blazor.web.js` file, and then a request
looking something like this: `ws://localhost:5116/_blazor?id=qfAbJP7iDGSOd4SIdlu6vA`
is registered. **This is the websocket handshake between the component and the
server.**

If you click on the web socket registered connection and click multiple times on the
button, you can see how the messages get logged. And even further you can see
the _byte size_ they have. These messages are the render tree differences that are
getting exchanged.

Again, in short.

. The `blazor.web.js` files negotiaties a SignalR channel between the browser
and the server. This is for the different components that work with server interactivity.
. This channel is used back and forth to send and receive information that updates
the view with interactivity.

==== Interactivity Location

After making a component interactive, by adding on `Program.cs` specific behaviors,
and by marking the component as `@rendermode="InteractiveServer", we manage to
achieve interactivity. This is what's called _Interactivity Location_.

We can add this interactivity location in different places:

- On the parent component
- On the mention of the component on the parent's code
- On the actual component itself

_If we take away the interactivity location and try and test the button, we should
prove the idea that this is what adds interactivity, and hence the workflow works_.

````
@page "/servers"

@rendermode InteractiveServer
````
This is how interactivity location at the parent level would look like. This
cascades interactivity down to all children and their own sublevels.

If not, we can go down to the actual child component and apply **the same notation**,
after that the component and any subsequent children components will have the
interactivity mode setting cascaded down the tree.

This is the **First Type of Interactivity Location**.

1. Page or component level
2. Global

The _Global level_ can be added by going into `App.razor` and then adding the interactivity
mode at the `Routes` component level that is what renders everything on our SPA.

````
<Routes @rendermode="InteractiveServer"/>
````

And here you can switch between different modes, may it be **WebAssembly, Server**.

These are the two type of locations for interactivity leveraging.

**What is recommended?**

We should specify the location at the parent level but on the explicit component
render syntax:

[source, razor]
.Servers.razor
----
<ServerComponent @rendermode="InteractiveServer"></ServerComponent>
----
This is the way. If you add it to the explicit component at its top, you can easily
clash with switching for other render mode, since it will take precedence and your code
will become _HARDER TO EDIT LATER_.

[IMPORTANT]
====
So Microsoft themselves enforce _this specific pattern of specifiying the interactivity
mode where you call the component.
====

==== Server Interactivity in Visual Studio project template

We started with a Blazor SSR template, however what happens if we start with another
mode? (_NOTE:_ The `Blazor Web App` template is the recommended one to use after
.NET 8).

You can select as a template setting to use Server Interactivity, and even set the
Interactivity location "Per Page/Component". This will start a project with the
two lines at `Program.cs` that we saw, plus all components that are pages with
the _cascading interactivity mode_. at the top of each of them. `Routes` does not
have the interactivity location, nor static pages, since they don't require interactivity
at all. Only the `Counter` page has interactivity set on, and that is because it
is required by it. So a rule of thumb is to ask yourself if the component
**really needs to be interactive**. Otherwise a static website will work just
fine.

_Extra:_ What if we select Server render mode and with Global?

Same things, but if we look at `Counter.razor`, we see no interactivity location.
That is because we will have it at the `App.razor`'s `<Routes>`' component level.
This is how the template can be used to set everything up from the start, but the
most important thing: **You know now how this works**.

==== .NET 9 Updates: Include SSR in Global Server Interactivity location


====

====

====

====

====
