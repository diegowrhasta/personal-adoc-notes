= Introduction

These are notes for different things found in the Blazor (.NET) component frontend
framework. As a starter, we will have notes on a https://www.udemy.com/course/blazor-deep-dive-from-beginner-to-advanced/[Udemy]
course.

== Blazor Deep Dive - From Beginner to Advanced in .NET 8

=== Course Content

==== NET 9 Updates

.NET 9 introduced a few changes to Blazor. These changes are minor however. One
thing worth of note though is that you should include **SSR (Server Side Rendering)**
in a Blazor app configured to use server interactivity with global location.

==== What is Blazor

TL;DR: Blazor is a **component based** SPA web application framework that achieves
interactivity with C#.

_Component based SPA web application framework:_ This differs from the traditional
web application paradigm (which is also the first one that was invented). In the
sense that we are not responding to individual pages that a server requests, and
then spits back to the client.

The user will send requests to the web server as well, however the web server will
route all requests to **ONE PAGE**. This is in theory called _the root component_,
but you can still define it as this _root page_. No matter how many requests are
sent, they will always go to one single page. The Blazor Framework will look for
different components, and it will then **place the component** inside the root
component.

A simple workflow would be:

1. A first request will go to the server, the server will then request for the
necessary components to render that path.
2. A second request will come and the server will "erase" the previous components
and render others that respond to that specific request. And so on.

Components are a powerful paradigm because you can nest components inside of other
components, effectively turning this structure as a **component tree**, the levels
and children will be mandated by requirements.

The main idea is that you should **think in components**. Blazor uses C# in order
to reach interactivity. React, Angular, Vue, etc all use **javascript**.

==== Choices of interactivity

What is _interactivity_?

E.g., If we have a page, and on this page we have a list, we want to allow users
to search on that list based on a filter, only matching results to the filter
should show up in the list. We would have a search bar, a button. In order to
add _reactivity_ or _interactivity_ normally you would start using javascript.
But in Blazor we achieve that with C#, and C# only. The main idea behind the
framework's design is to unify code as much as possible and not rely on Javascript,
(although you will be still using it in really specific edge cases).

There are different ways to implement interactivity with Blazor, the types of
interactivity are:

No interactivity (base):: This is one type, in case you don't need any sort of reactivity,
this is also called SSR (Static Server Side Rendering). In most use cases, you will
create a project with this default interactivity setting. You would only need to
add interactivity based on **requirements**.
Server Interactivity:: This will make the application to establish a SignalR channel
from server to client (this is a WebSocket implementation). This is like a P2P
communication and it needs to be sustained. In order for this channel to work,
a javascript file is created inside of the page that is being rendered on the
browser, **this is not created by a developer** but by the framework. Whenever the
user does something, the event will be handled by said javascript server and sent
to the backend server, to then make a decision. It will compare the previous state
of the page and then a newly calculated state, that difference is then sent back
to the client so that it can attach it and re-render the page on the fly. (No
reload of the whole page)
WebAssembly Interactivity:: This is based on Blazor SSR, the components that require
WASM will then get packaged with tons of extra DLLs and WASM files and sent back
to the browser. This is then leveraged by the browser in order to run the interactions.
A good point here is that WASM is way faster than javascript since it runs at almost
native speeds. There's another approach in which the whole component gets compiled
into WASM and that gets sent to the browser to then be interpreted and run. But
either way, **some kind of files will be downloaded from the server to the browser**
and these files will then be executed by the browser.

Blazor SSR = **BASE OF EVERYTHING** When Web Interactivity is required, you can
choose WASM, Server Interactivity or a hybrid model in which some "pages" and components
run on server and others on WASM.

==== Blazor SSR Project Structure

In order to start getting familiar with Blazor SSR, we will create some dummy project
and describe its components.

First of all, when creating a Blazor Web Application, starting on .NET 8 the recommended
template is simple **Blazor Web App**. There are other variations however that might
apply to specific use cases.

[IMPORTANT]
====
We will select the "Interactivity Mode" as `None`, this is the stock Server Side
Static Rendering (SSR). And it's recommended to start your project with this setting,
the other ones are _Server, WebAssembly, Auto (Hybrid)_. Many pages that you create
you will see that require no interactivity, meaning that by selecting `None` you
can add interactivity to components that actually need it.
====

After we create the project with a "Interactivity" set, it will not matter later.

**NOTE:** Just to get things straight, the entry point is `Program.cs`. The paradigm
is simple, we do a `app.Run()` and the app stays alive as if in a "for-loop" and
will pick up on any Http Request that comes in. Once a request comes in, it goes
through different functions, which are called _Middlewares_.

[source, csharp]
----
using ServerManagement.Components;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddRazorComponents();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error", createScopeForErrors: true);
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}

app.UseHttpsRedirection(); <.>


app.UseAntiforgery();

app.MapStaticAssets();
app.MapRazorComponents<App>(); <.>

app.Run();
----
<.> Something like this is a Middleware, a request that comes will pass through the
logic that's stated here and maybe get something added to it, or extracted, middlewares
are multi-purpose in nature.
<.> This is a pretty important line of code, this will map all the Http requests
to the `App` class.

If we go and analyze the `App.razor` file that should be under `Components`. We
should find something like this:

[source, razor]
----
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <base href="/"/>
    <link rel="stylesheet" href="@Assets["lib/bootstrap/dist/css/bootstrap.min.css"]"/>
    <link rel="stylesheet" href="@Assets["app.css"]"/>
    <link rel="stylesheet" href="@Assets["ServerManagement.styles.css"]"/>
    <ImportMap/>
    <link rel="icon" type="image/png" href="favicon.png"/>
    <HeadOutlet/> <.>
</head>

<body>
<Routes/> <.>
<script src="_framework/blazor.web.js"></script>
</body>

</html>
----
This isn't the only place that will have `html` code declared inside of it. The
specific notations such as `HeadOutlet` and `Routes` will later come into play
when dealing with the framework's functionalities.

[IMPORTANT]
====
The `App.cs` component/razor file, is actually the _ROOT COMPONENT_. In here we
will be rendering all the components, hence it's configured in a way such that
all Http requests are mapped to this very specific component. This is the **one page** 
of the SPA.
====

It's through `<Routes />` that then the root component can resolve/render corresponding
components that respond to different routes.

Now this component can also be read, it should be right next to the `App.razor`
file.

[source, razor]
====
<Router AppAssembly="typeof(Program).Assembly">
    <Found Context="routeData">
        <RouteView RouteData="routeData" DefaultLayout="typeof(Layout.MainLayout)"/> <.>
        <FocusOnNavigate RouteData="routeData" Selector="h1"/>
    </Found>
</Router> <.>
====
<.> A key concept here is `DefaultLayout="typeof(Layout.MainLayout)"` this notation
specifically makes it so that the component will be spat out as HTML to the browser.

And so, in short, all the routes here will respond to a specific set of components
or "screens". Depending on the route that the server got, then all the respective
**content** will be displayed/replaced on the place that holds the `<Routes />`
tag.

The `MainLayout`, so the actual code that will render HTML can also be visualized
under `Components > Layout > MainLayout.razor`. Technically all blazor components
are under `.razor` files.

[source, razor]
.MainLayout.razor
====
@inherits LayoutComponentBase

<div class="page">
    <div class="sidebar">
        <NavMenu/>
    </div>

    <main>
        <div class="top-row px-4">
            <a href="https://learn.microsoft.com/aspnet/core/" target="_blank">About</a>
        </div>

        <article class="content px-4">
            @Body <.>
        </article>
    </main>
</div>
====
<.> The `@Body` annotation/tag is a really important piece of notation to keep in
mind, it's a placeholder for **any component**, no matter what type of component
is required by the user, it will come in here and replace the placeholder.

This is the _basic, theoretical flow_:

. Request comes into `Program.cs`
. Request goes to `App.razor`
. Goes to the `Routes.razor`
. Goes to `MainLayout.razor`

And through it all, it will render and swap out placeholders and places on each
layer respectively.

If you run the application, we should see both a terminal session and a web site
on our Default Browser.

The terminal holds some bits of info that's great:

. It will tell us at which ports the Blazor App is running
. It will also tell us which is the Root Page (component)

In short, the `MainLayout.razor` site renders a side bar, and then has content
that will change based on the route. This is how it all works, if you inspect
the HTML you will see how this rings true, how the sidebar is effectively **static**.

It's however Blazor that under the scenes takes care of replacing content based
on the routes.

This is the basic SSR setup, if we want WASM interactivity we will need to add a
second project, but overall it will remain the same. Hence it's said that
`SSR is the base of everything else`.

=== Blazor SSR

==== Two Types of Components

There are two types:

Routable Components:: Also called _Page Components_. This will respond directly
to a route.
Non-Routable Components:: Also called _Reusable Components_. These are used inside
routable components, and also inside of other non-routable components.

So, let's start playing around with the components and features. Say, we want to
create a Page that will respond to a new route. We should then create a `.razor`
file inside of `Pages`. Something like `Servers.razor`. You should _technically_
always create a _Razor Component_. But it's through anotations and other things
that we establish a routable and non-routable component and so on.

If we create with the scaffold:

[source, razor]
====
@page "/Servers" <.>
<h3>Servers</h3>

@code {
    
}
====
<.> This is the single most important thing that marks a component as a `routable
component`.

After adding this new component, and reloading the web site, we can manually type
`/servers` at the URL bar, if we get something rendered (in this case a simple heading
with `Servers`), then everything is working as expected.

We will now create a non-routable component, the course's convention is creating
a folder called `Controls`. And inside adding a `.razor` file. All of the components
inside should be _non-routable_. Another convention is to always suffix these components
with `Component` e.g., `ServerComponent.razor`

Once we create this component we can add some code to it to see if it renders, and
after that we can then use this component inside of any of our pages. In this case
if we were to put it into `Servers.razor`:

[source, razor]
====
@page "/servers"
@using ServerManagement.Components.Controls <.>

<h3>Servers</h3>
<br/>
<br/>
<ServerComponent/> <.>

@code {

}
====
<.> You could just import the namespace like this, but there's a more clean and
recommended way.
<> And here you can just write the component name with this syntax (that's really
close to how React would do it, or even Angular for that matter)

The better and cleaner approach to imports is to put the namespace import under the
`_Imports.razor` component that should be at the root of the `Components` folder.
In here you woul see things such as:

[source, razor]
====
@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using static Microsoft.AspNetCore.Components.Web.RenderMode
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.JSInterop
@using ServerManagement
@using ServerManagement.Components

@using ServerManagement.Components.Controls <.>
====
<.> This import can indeed be powerful, because, if by convention we create
all re-usable components under this namespace, next time, when trying to call them
from other components or pages, we won't have to always be importing them, this
centralized the import and makes things leaner.
====

If you were to declare `<ServerComponent />` twice, then its content should be
replicated normally. This is a reusability example, _don't forget about that_.

==== Razor Syntax Implicit Razor Expression

Blazor achieves interactivity with C#, this is at the frontend level. However
at the backend we also use C#, how will that work?

So that we can start using C# code we have to leverage **Razor Syntax**

[source, razor]
====
<p>
    @status <.>
</p>

@code {
    private string status = "Server is offline"; <.>
}
====
<.> This is called _implicit syntax_ we can reference variables that are written
in C# directly on the `HTML` part.
<2> As you can see we are using C# code here to assign a value to then be rendered.

We can then concatenate both HTML and "evaluation code". `@status at @DateTime.Now`.
Whenever there's an `@` then this is actually syntax that tells Blazor that something
from C# needs to come here (and be evaluated).

[NOTE]
====
Okay, thank god that Hot Reload is a _thing_. Hopefully it's stable now in .NET
9. https://learn.microsoft.com/en-us/aspnet/core/test/hot-reload?view=aspnetcore-9.0[hopefully].
====

The course leans heavily on this process of "Apply a change, restart the server",
and that is _so slow_. The industry standard should be hot reload (React, Angular
had over Blazor a long time ago). The way to _enable_ hot reload is to simply run
the application with `dotnet watch` this will keep a demon checking for changes
on the source code files, and if it's detected then it will auto reload itself,
in case something really critical is updated it will prompt the user to please
reload manually (better than wasting time).
====

What if we wanted to leverage some class? We can then create a model (POCO) under
something like `Models`. A typical POCO with `ServerId, City, Name` perhaps.
Nothing out of the ordinary.

And then we can reference it in our component like so:

[source, csharp]
.ServerComponent.razor
----
<p>
    @server.Name is in @server.City
</p>

@code {
    private Server server = new()
    {
        Name = "Server 1",
        City = "Toronto"
    };
}
----
As you can see, we are using **implicit syntax**, and after spaces then the evaluation
stops, hence always before spaces we should reference expressions that are C#
code related. We can use the **implicit syntax** under any HTML by the way, not
just paragraphs (`<p>`). This can even be evaluated on HTML properties.

And again, we should add its namespace to the `_Imports.razor` component so that
globally any model we add we can seamlessly consume from anywhere and removing
the need to import it always.

==== Razor syntax Explicit Razor Expression

The Razor expression would be limited if we only had the implicit type, since we
can't really do anything with logic or concatenation since a **space** literally
marks it as finished. And it's due to this that an _explicit expression is necessary_.

[source, razor]
====
<p>
    @server.Name is in @server.City that is @(server.IsOnline ? "online" : "offline") <.>
</p>

@code {
    private Server server = new()
    {
        Name = "Server 1",
        City = "Toronto"
    };
}
====
<.> With the `@()` syntax you can easily write more explicit code and logic so that
some rendering is applied based on pre-existing conditions. We can use the explicit
syntax even on attributes for an html element. Any C# expression can be used inside the
`@()`.

See how explicit syntax can be so powerful that it can literally be used for conditional
rendering and styling:

[source, razor]
====
<div style="color: @(server.IsOnline ? "green" : "red")" data-name="@server.Name" data-status="@(server.IsOnline ? "online" : "offline")"> <.>
    @server.Name is in @server.City that is @(server.IsOnline ? "online" : "offline")
</div>

@code {
    private Server server = new()
    {
        Name = "Server 1",
        City = "Toronto"
    };
}
====
<.> In here under a `style` we can literally conditionally apply a color or something
alike. It's extremely powerful.

_NOTE:_ We can also use a direct object for style: `style="@($"color: {(server.IsOnline ? "green" : "red")}")"`,
the thing with this syntax though is that we can nest another "evaluation expressions"
inside of the existing @() part. So this is a great way to keep adding more complex
condition paths in the same structure.

The Razor expression syntax has tons of power when it comes to rendering things
with C# code and bound objects.

==== Create a static data repository

In order to keep exploring Blazor's capabilities we can now create a mode for
mocking data. In our case we'll use the Repository pattern to create a `ServersRepository.cs`
class.

There's nothing worth of note here, more than a simple CRUD but that's managing
a static list in memory. We won't connect to some backing service since the focus
of the whole course is Blazor, we just need a source of data.

==== Razor Syntax Output list with looping

We are going to use looping to output a list inside of a Razor component.

[source, razor]
----
@page "/servers"

<h3>Servers</h3>
<br/>
<br/>
<ul>
    @foreach (var server in servers) <.>
    {
        <li>
            @server.Name in @server.City is <.>
            <span style="color: @(server.IsOnline ? "green" : "red")"> <.>
                @(server.IsOnline ? "online" : "offline")
            </span>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
}
----
<.> Se use the `@foreach` control directive to then loop over a list and render
_repeatedly_ HTML elements as we see fit (per entry of the list).
<.> We will then have code that can easily resemble what we already saw previously
but now applied to this new "iterative logic".

==== Assignment 1: Output city buttons list

We are going to output city buttons.

The idea is to practice the `@foreach` loop syntax, the rules are as follows:

. We are going to create a city model
. We will create a city repository
. We will output the cities as lists

We will work with static lists, so under `Models > CitiesRepository.cs` we will
simply have a string list with city names.

==== Assignment 1: Answer

Under the `Servers.razor` file:

[source, razor]
----
@page "/servers"

<h3>Servers</h3>
<br/>
<br/>
<ul>
    @foreach (var city in cities)
    {
        <button type="button">@city</button> <.>
    }
</ul>
<ul>
    @foreach (var server in servers)
    {
        <li>
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
    private List<string> cities = CitiesRepository.Cities;
}
----
<.> This is something that works just fine, BUT, Blazor by default comes with
bootstrap already installed, so we can style this with `class="btn btn-primary"`.

Now, the course does really hacky stuff, in order to add a space between the buttons
it uses this interesting syntax called `<text></text>` that you can use to enclose
some special characters, I guess that's, cool? Don't really know. But we can style
components as we would without issue by creating a file like:

````
|-- Servers.razor
|-- Servers.razor.css
````

And in there we can start adding as much styling as we want to, by default Blazor
will then compile this into isolated CSS so we shouldn't class with other styles
and we will keep things lean.

[NOTE]
====
IF YOU CAN'T SEE THE STYLES GETTING APPLIED/LOADED THAT'S PROBABLY BECAUSE YOU HAVE
TO RELOAD THE WHOLE APP. This is dumb, tbh, the hot reload doesn't pick up on
styles apparently, so it's not that "scoping is not working", it's more so that
we have to work with manual restarts
====

This is how the component code would look like:

[source, razor]
----
@page "/servers"

<h3>Servers</h3>
<br/>
<br/>
<ul class="button-list">
    @foreach (var city in cities)
    {
        <li> <.>
            <button type="button" class="btn btn-primary">@city</button> <.>
        </li>
    }
</ul>
<br/>
<br/>
<ul>
    @foreach (var server in servers)
    {
        <li>
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
    private List<string> cities = CitiesRepository.Cities;
}
----
<.> By convention, and to avoid errors, you should only have direct children of
a <ul>, <li> elements, inside of those elements you can then do whatever you want.

And the css that would make the buttons look nice and also use good css practices:

[source, css]
----
.button-list {
    display: flex;
    gap: 1rem;
    list-style: none;
    padding: 0;
}

.button-list li {
    display: flex; /* ensures buttons align neatly */
}
----
Since we have to work our way around the list elements, the default css will
add bullet points so we have to get rid of them with `list-style: none`, plus
no default padding: `0`. And so that the buttons, or the children elements align
neatly we will also apply a `display: flex` property to all of them. And the
different with a simple `<button>` is that the content will not have a padded
button at the beginning, this will neatly fit into the whole container.


**NOTE:** So, an interesting thing and piece of info in general is that the course
uses a bootstrap property to literally make the buttons change their layout as the
screen gets smaller, this is with a bootstrap class `container-fluid` apparently,
and it doesn't use a list it uses a div and inside of it buttons, then the buttons
stack up as the screen gets smaller, which is cool, I guess.

[source, razor]
----
@page "/servers"

<h3>Servers</h3>
<br/>
<br/>
<div class="container-fluid text-center"> <.>
    <div class="row w-50"> <.>
        @foreach (var city in cities)
        {
            <div class="col"> <.>
                <button type="button" class="btn btn-primary">@city</button>
            </div>
        }
    </div>
</div>
<br/>
<br/>
<ul>
    @foreach (var server in servers)
    {
        <li>
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
    private List<string> cities = CitiesRepository.Cities;
}
----
<.> So `container-fluid` simply makes a full-width content wrapper with padding.
<.> After that we are creating another `div` that I think could be simplified into
one div. But anyway, this has the `row` class with something that lets it grow
only until half the view port (width: 50%).
<.> Inside of this parent we have `class="col"` which are containers that help
everything stack as the screen grows larger or smaller. It's a bit magical since
you get these behaviors by applying bootstraps built-in classes, but... yeah. Trying
to replicate the same behavior and styling requires more in raw css, but again,
you can simplify so much and not be as bloated.

==== Working with Static Resources

Before going further into development, we need to learn another convention established
by Blazor. And that's a folder for static resources that the server can resolve
automatically, for that we need to have a look at the `Program.cs` file again:

[source, cs]
----
using ServerManagement.Components;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddRazorComponents();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error", createScopeForErrors: true);
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}

app.UseHttpsRedirection();


app.UseAntiforgery();

app.MapStaticAssets(); <.>
app.MapRazorComponents<App>(); <.>

app.Run();
----
<.> Just like the razor components middleware this takes care of configuring the app
so that all files under `wwwroot` are served by the server automatically (it can
resolve the static resources correctly). Without this middleware we wouldn't be
able to reference a resource and have that being retrieved by the server just fine.
<.> Remember, this line is a middleware that takes care of hooking up all requests
to the server to some specific razor page. Something to bear in mind though,
this had a different name before, it was `UseStaticFiles()`.

Under `wwwroot` we can nest many folders to keep things organized, but it's not
a hard requirement. For example, the scaffolded project has bootstrap in here,
as well as the root `css` file.

The course already provides for some images, these images are of the cities that
we have under `CitiesRepository.cs`. In order to style really good the buttons alongside
the city photos, we can use a bootstrap component called `Card`, by googling this
we can copy the boilerplate code straight from Bootstrap's page:

[source, razor]
----
@foreach (var city in cities)
        {
            <div class="col">
                <div class="card">
                    <img class="card-img-top" src="@($"/images/{city}.png")" alt="Card image cap"> <.>
                    <div class="card-body">
                        <button type="button" class="btn btn-primary">@city</button>
                    </div>
                </div>
            </div>
        }
----
<.> All of the other HTML code is redundant to explain, the meat of everything is here,
this is how we can access static resources, at the beginning we have `/` which means
we start from the `root`. The folder were we should place the images is `wwwroot`,
you can make the connection that way. And once we are there we can start building the
paths to the static resources depending on if things are nested or not. Pretty
neat. String interpolation comes back in its **explicit syntax** so that we can
evaluate a specific variable value but have it be interpolated accordingly.

==== Assignment 2: Create a routable component

We have to create a routable component that we can redirect through the different
elements on the list of servers. Use Bootstrap LinkButton, click and then replace
the content with a new dummy "Add Server" button.

I chose a "badge". The issue is that the course is definitely with an Old Bootstrap
version, (3 - 4), and the newest version (5) has differences in class names.

https://getbootstrap.com/docs/4.0/components/badge/#links[Links Bootstrap 4]

https://getbootstrap.com/docs/5.3/components/badge/#pill-badges[Links Bootstrap 5]

In the currrent project if trying to use `<a href="#" class="badge badge-primary">Primary</a>`
then the styling wouldn't work at all. And so had to go into the Bootstrap 5 docs
to see the valid class name: `<a href="/add-server" class="badge bg-primary">Add Server</a>`

==== Assignment 2: Answer

. Create a Page component under `Pages` (Remember that by convention these components
don't have the `Component` suffix)
. So the course was unclear, it was an `Edit` page.

The files would look like something like this:

[source, razor]
.Pages/EditServer.razor
----
@page "/servers/edit" <.>
<h3>AddServer</h3>

@code {
    
}
----
<.> This marks this component as to something that will respond to a server call
to /servers/edit.

[source, razor]
.Servers.razor
----
@foreach (var server in servers)
    {
        <li>
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
            <a href="/servers/edit" class="btn btn-link">Edit</a> <.>
        </li>
    }
----
<.> This is a bit "unconventional" in the sense that it could be an actual button
and not an anchor link, but I guess that due to web standard's defaults we will
trigger a call to the server that will then route to our created component. The
`btn btn-link` styles work just fine in Bootstrap 5. Another thing worthy of note
is that in order for us to build the different routes that will then map to
pages, is to start at root always `/`, and then build the respective route.

[NOTE]
====
The course uses this hack way of adding artificial spaces with `&nbsp;`. Again, this
is not a good practice for web dev in any shape or form.
====

Besides that, the instructor expands on adding a link in the navbar at the left
so that we can actually see the list of servers that up until now we have simply
accessed by writing manually the route on the browser.

Now, the way to build your way to the respective file that we need to edit. You
have to start at the root `App.razor`. Remember that in there there's a `<Routes/>`
component.

The routes component has this code:

[source, razor]
.Routes.razor
----
<Router AppAssembly="typeof(Program).Assembly">
    <Found Context="routeData">
        <RouteView RouteData="routeData" DefaultLayout="typeof(Layout.MainLayout)"/> <.>
        <FocusOnNavigate RouteData="routeData" Selector="h1"/>
    </Found>
</Router>
----
<.> For now, the only important part of the code is this `Layout.MainLayout` line,
this is what will be rendered in place of `<Routes />`, this component is under
`Components > Layout > MainLayout.razor`.

And under here by reading the razor code you can notice a component with styling
such as `sidebar` and this pointing to a `<NavMenu />`, component that conveniently
is under the same `Layout` folder. This is the code with a plus entry for accessing
the `/servers` route:

[source, razor]
.NavMenu.razor
----
<div class="top-row ps-3 navbar navbar-dark">
    <div class="container-fluid">
        <a class="navbar-brand" href="">ServerManagement</a>
    </div>
</div>

<input type="checkbox" title="Navigation menu" class="navbar-toggler"/>

<div class="nav-scrollable" onclick="document.querySelector('.navbar-toggler').click()">
    <nav class="nav flex-column">
        <div class="nav-item px-3">
            <NavLink class="nav-link" href="" Match="NavLinkMatch.All">
                <span class="bi bi-house-door-fill-nav-menu" aria-hidden="true"></span> Home
            </NavLink>
        </div>

        <div class="nav-item px-3">
            <NavLink class="nav-link" href="weather">
                <span class="bi bi-list-nested-nav-menu" aria-hidden="true"></span> Weather
            </NavLink>
        </div>
        
        <div class="nav-item px-3">
            <NavLink class="nav-link" href="servers"> <.>
                <span class="bi bi-list-nested-nav-menu" aria-hidden="true"></span> Manage Servers <.>
            </NavLink>
        </div>
    </nav>
</div>
----
<.> The route resolve works both for `/servers` or `servers`.
<.> And under here we can add the new entry that should redirect us to the server
list page, this has a label of `Manage Servers`.

==== Route Parameters and Route Constraints

We have created the routable component, we can navigate to it, but we don't have
any idea of how to know what server are we editing.

The way to pass information from one page to the next one (one of the ways) is
through the url (a route parameter). So we want to be able to put `/servers/edit/1`
and then be on a routed component that has now the information of server 1 to
edit.

The way to prepare our triggering page to then go into the respective url we would
do something like this:

````
<a href="/servers/edit/@server.Id" class="btn btn-link">Edit</a>
````

This is at `Servers.razor`, as you can see we are using implicit syntax to then
be able to dynamically retrieve the `Id` of the server so that it then routes back
to the routable component with that specific server state loaded.

If we hover over the link we would see the link ending with `1, 2, 3, etc...`.
Now of course, if we click the link we would get hit with a 404. But wiring this
up is pretty easy.

On the receiving page you should mark one of the resource levels with a specific
syntax:

[source, razor]
.AddServer.razor
----
@page "/servers/edit/{id}" <.>
<h3>AddServer</h3>
<br/>
@Id <.>

@code {
    [Parameter] <.>
    public string Id { get; set; } = string.Empty;
}
----
<.> In here between curly braces you can give a name to whatever route parameter
you are setting the page to accept.
<.> And with implicit syntax we can then test and print the receiving value that
should be bound to the url's route parameter.
<.> And lastly so that we bind everything correctly, we have to decorate a property
with `[Parameter]`, in this case we are binding to a `string` since that will take
whatever.

After setting this, we should be able to access the respective server's edit page,
and we should be rendering the respective ID that comes from the route parameter.

There's something odd here though, if we try and hit `/servers/edit` we will get
rendered `edit` which is odd, we are expecting only numbers here, luckily there
is a feature to apply constraints to the route parameters. (We want only an integer).

These are called **Route Constraints**.

The way to add constraints is by appending a type:

````
@page "/servers/edit/{id:int}"
<h3>AddServer</h3>
<br/>
@Id

@code {
    [Parameter]
    public int Id { get; set; }
}
````
After a colon, you can add tons of constraints, in our case we are simply saying
that the route should be an `int` and of course the state variable should also
be of the respective type.

After this (probably restart the server, hot reload doesn't really work), and we
should be able to still navigate just fine, on top of getting a 404, or error
if trying to set the route to something like `edit/edit`. This makes it so that
our route constraint works.

The Microsoft Docs points to the different constraints that are supported at
its https://learn.microsoft.com/en-us/aspnet/core/blazor/fundamentals/routing?view=aspnetcore-9.0#route-constraints[website].
But they are not that complex, a route parameter should be akin to a primitive type
by convention and security.

An extra piece of info that is good to know is optional parameters:

[source, razor]
----
@page "/route-parameter-2/{text?}" <.>

<PageTitle>Route Parameter 2</PageTitle>

<h1>Route Parameter Example 2</h1>

<p>Blazor is @Text!</p>

@code {
    [Parameter]
    public string? Text { get; set; } <.>

    protected override void OnParametersSet() => Text = Text ?? "fantastic"; <.>
}
----
<.> If you want a route to take a possible null value as a route parameter, just
suffix it with a `?` mark.
<.> And of course, make the state variable match the route parameter with a nullable
type.
<.> Lastly, this might be a good recipe for further use cases down the line, we can
hook into the `OnParametersSet` method so that in case the route doesn't have
the respective parameter we coalesce its value to some default, this seems pretty
handy.

==== Use OnParametersSet to receive parameter value

Blazor has the concept of **Lifecycle events**, in this lesson we will leverage
`OnParametersSet` specifically to retrieve route parameter values.

_NOTE:_ There's a `OnParametersSetAsync` method.

Our Use Case requires for us to get the route parameter value and then load information
based on the `Id`, this info can be used for further logic and/or display purposes.

[source, razor]
----
@page "/servers/edit/{id:int}"
<h3>AddServer</h3>
<br/>
<p> <.>
    @_server?.Name
</p>
<p>
    @_server?.City
</p>
<p>
    @_server?.IsOnline
</p>

@code {
    [Parameter]
    public int Id { get; set; }
    
    private Server? _server { get; set; }

    protected override void OnParametersSet() <.>
    {
        _server = ServersRepository.GetServerById(Id); <.>
    }

}
----
<.> We could add a `if (server is not null)` but that's a bit Ugly I think, unless
there's a bigger render reason to not show a whole chunk of html, so using coalesce
like this is classier.
<.> The lifecycle hooks should always be overriden (and are protected), we shouldn't
have to call the base method since it's redundant.
<.> It is on the body of the lifecycle hook that we can then be sure that we have
the variable with the correct piece of data to then retrieve a server Id and save
the instance into a private member (a field).

This component should now display the server info as we expect it. We can even
add a `Go Back` button after that will throw us into the `/servers` page again.
And we can even style an anchor as if it were a button with `btn btn-primary`.

==== Use Form and Input components to display and collect data

Traditionally in Web Systems, an extremely important piece of interactivity are
**Forms**. And so these are built with native tags such as `<form>`, `<input>`,
`<button type="submit">`.

Because Blazor is a component-based web framework, Microsoft has already out-of-
the-box built-in componnets. Instead of plain html, we can use <EditForm>. This is
a built-in component that has tons of functionality already ready to be consumed
so we don't have to implement things from zero.

And for controls we have:

`<InputText>`
`<InputNumber>`
`<InputCheckbox>`

We can use these components inside of the form. We will display data, collect data
and everything.

By using the built-in form we save a lot of time specially for things such as
validation.

[source, razor]
----
@if (_server is null)
{
    return; <.>
}

<EditForm Model="_server"> <.>
    <InputText @bind-Value="_server.Name"></InputText> <.>
    <InputText @bind-Value="_server.City"></InputText>
    <InputCheckbox @bind-Value="_server.IsOnline"></InputCheckbox>
</EditForm>
----
<.> Learned this in prod :). A clean way of returning early and avoiding unnecessary
rendering.
<.> So there are different ways of binding models to the form, one of them is
with this `Model` attribute that we can bind to a state field, in this case is the
`_server` that we received from the repository.
<.> Lastly, we can then add inside different components for different controls
and the specific field they match to.

Now, if we wanted to make it look pretty, we can leverage Bootstraps form control
styles and other utilities:

[source, razor]
----
<EditForm Model="_server">
    <div class="row mb-3"> <.>
        <div class="col-2"> <.>
            <label class="col-form-label"> <.>
                Name
            </label>
        </div>
        <div class="col-6"> <.>
            <InputText class="form-control" @bind-Value="_server.Name"></InputText> <.>
        </div>
    </div>
    <div class="row mb-3">
        <div class="col-2">
            <label class="col-form-label">
                City
            </label>
        </div>
            <div class="col-6">
                <InputText class="form-control" @bind-Value="_server.City"></InputText>
            </div>
    </div>
    <div class="row mb-3">
        <div class="col-2">
            <label class="col-form-label">
                Online
            </label>
        </div>
        <div class="col-6">
            <InputCheckbox class="form-check-input" @bind-Value="_server.IsOnline"></InputCheckbox> <.>
        </div>
    </div>
</EditForm>
<a href="/servers" class="btn btn-primary ">Go Back</a>
----
<.> The layout calls for different rows for a control that holds both a `label` and
a `control`, so we would have 3 controls. The `row` style of boostrap simply states:
"The things inside should be on the same line (row), all of them will be referred
to as columns". `mb-3` simply adds 3 units of margin at the bottom.
<.> `col-2` simply states that this container will take 2-parts (cols) of the
12-part grid.
<.> `col-form-label` styles the `<label>` element so that it aligns properly
with the control (input)
<.> `col-6` simply states that this container will take 6-parts (cols) of the 12-part
grid.
<.> `form-control` Simply styles the control with Bootstrap's stuff
<.> `form-check-input` styles the control specifically for a checkbox with Bootstrap

[NOTE]
====
Overall, this is so cute, because it's really beginner code, we can definitely
abstract this even further so that we don't duplicate as much code. It's harder
to edit later.
====

**EXTRA:** This `12-grid` concept is a core concept special to **Bootstrap**. By
default Bootstrap divides every row into 12 equal parts horizontally. Every row
is 12 units wide, and the way you style child components will make them take more
or less space of that 12 unit space. _Why 12?_ It's flexible, you can divide it
evenly in many ways (apparently).

You can definitely check the code for Bootstrap's controls and other utility
classes at its https://getbootstrap.com/docs/5.3/forms/form-control/#example[docs].

Just remember that depending on your need, you can use different built-in control
components from Microsoft's Blazor Library and not have to worry of reinventing
the wheel.

==== Form submission and model binding

We are going to learn how to submit data, this is specifically for Blazor SSR,
with interactivity the process is quite different.

SSR = Is really similar to traditional web applications, a form submission is just
a traditional form submission.

A form is in the browser, when the user clicks a `submit` then the url, form values
are packed and sent to the server. When the server receives the HTTP request it
will process it.

Blazor SSR works the same, we should code a function and its paremeters so that
the logic gets triggered depending on the request that's coming into the server.

[source, razor]
----
@page "/servers/edit/{id:int}"
<h3>Edit Server</h3>
<br/>

@if (_server is null)
{
    return;
}

<EditForm Model="_server" FormName="formServer" OnSubmit="Submit"> <.>
    <div class="row mb-3">
        <div class="col-2">
            <label class="col-form-label">
                Name
            </label>
        </div>
        <div class="col-6">
            <InputText class="form-control" @bind-Value="_server.Name"></InputText>
        </div>
    </div>
    <div class="row mb-3">
        <div class="col-2">
            <label class="col-form-label">
                City
            </label>
        </div>
        <div class="col-6">
            <InputText class="form-control" @bind-Value="_server.City"></InputText>
        </div>
    </div>
    <div class="row mb-3">
        <div class="col-2">
            <label class="col-form-label">
                Online
            </label>
        </div>
        <div class="col-6">
            <InputCheckbox class="form-check-input" @bind-Value="_server.IsOnline"></InputCheckbox>
        </div>
    </div>
</EditForm>
<a href="/servers" class="btn btn-primary ">Go Back</a>

@code {
    [Parameter]
    public int Id { get; set; }

    [SupplyParameterFromForm(FormName = "formServer")] <.>
    private Server? _server { get; set; }

    private void Submit() <.>
    {
    }

    protected override void OnParametersSet()
    {
        _server = ServersRepository.GetServerById(Id);
    }

}
----
<.> So the `<EditForm>` component can receive two properties: `FormName` and `OnSubmit`.
One will help us identify the form in case there are multiple forms and this is a
unique identifier, on the other hand we have to supply a callback that will respond
when the form triggers a submit.
<.> We can leverage `SupplyParameterFromForm` and even specify the specific form name,
this is so that when a submission is triggered, and we need to map-out (bind) all the
form's state we can automatically bind it to a state property.
<.> Lastly we need to create the callback method that will be triggered on form
submission.

This way Blazor will have effectively wire everything so that the form submission
works as expected (as per convention).

The last component we need to but is a submit button actually: `<button class="btn btn-primary" type="submit">Update</button>`.
This is typical stuff, with the only difference is that it should be of `submit`
type.

_NOTE:_ Tried it with Rider, and we can debug Blazor (well at least this simple
project). So if we setup breakpoints in the `Submit` method, we should hit it
after pressing the submit button.

An interesting piece of behavior to highlight here is though that when we hit the
submit, as is, we will notice that the updated state from the view is not actually
being sent at the runtime of the `OnSubmit`. Well it _seems_ that way, but what's happening
is actually that `OnParametersSet()` overrides this value (so it runs before) the
`OnSubmit` gets triggered and we lose state. The easiest way to fix this is by
doing this:

````
protected override void OnParametersSet()
    {
        _server ??= ServersRepository.GetServerById(Id);
    }
````

By using this coalesce we will only try and hit the `ServersRepository` method if
`_server` is null, otherwise we will keep whatever value it had. This effectively
is a circuit-breaker so that we are not hitting always the repo in order to
get data.

A second interesting find, is that because we are doing this whole `SupplyParameterFromForm`,
the whole model will mapped to whatever the form has packaged, and one property
that we don't have right now available is `Id`. If we see the value of the `_server`
variable, we will see `Id = 0`. This is bad since it's not consistent, and if
we were to rely on this Id, it can easily become a bug.

And so, I remembered that in prod we also did this (which is bad), that is adding
a hidden field in the view so that the state is kept and bound correctly:

````
<InputNumber hidden="true" @bind-Value="@_server.Id"></InputNumber>
````

The `InputNumber` component is important since `Id` is an int property, if we
try and use a `TextInput` we will get compilation errors.

With this in mind, we can now code the submit logic.

[source, razor]
----
private void Submit()
    {
        if (_server is null) <.>
        {
            return;
        }
        
        ServersRepository.UpdateServer(_server.Id, _server); <.>
    }
----
<.> Don't forget about the return early principle. (else-less).
<.> And in here we simply update the respective server with its Id, and then
send the whole payload that will update the server.

In Blazor SSR a submission handler takes care of a form submission, there are
actually other types of submits for specific cases `OnValidSubmit`, `OnInvalidSubmit`.

Traditionally the "receive data of a form submission" is what we refer as **Model
Binding**. It's like a two-way data-binding. The moment the form is submitted
we bind all of the payload to a state variable.

==== Form Validations

When the form is submitted we need to validate data. We will use annotations to
add this behavior, not an actual Blazor feature but a plain C# Data Anotation.

[source, csharp]
----
using System.ComponentModel.DataAnnotations; <.>

namespace ServerManagement.Models;

public class Server
{
    public Server()
    {
        var random = new Random();
        var randomNumber = random.Next(0, 2);
        IsOnline = randomNumber % 2 == 0;
    }
    
    public int Id { get; set; }
    
    public bool IsOnline { get; set; } <.>
    
    [Required] <.>
    public string? Name { get; set; }
    
    [Required]
    public string? City { get; set; }
}
----
<.> In order to work with the respective data anotations, we need to import this
specific namespace.
<.> The `bool` type has a `false` default value so it will always have a value, no
need to mark it as `[Required]`
<.> In the model that will be bound to the form we can add all the respective data
anotations we want so that the form is fed this metadata and tries to run validations
automatically against these specific rules.

You can read further at https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations?view=net-9.0[MS Docs],
specifically the `RequiredAttribute` link.

We have tons of attributes that we can use, [Compare Attributes, Display Attribute
(play with the label and the actual underlying value), StringLengthAttribute].
All of them have their own respective use case.

In our case we will use the `[Required]` data anotation, once we have set up all
of our logic. Now, in order to start applying the respective data anotation validations
we need to use a couple of extra components:

[source, razor]
----
<EditForm Model="_server" FormName="formServer" OnValidSubmit="Submit"> <.>
    <DataAnnotationsValidator></DataAnnotationsValidator> <.>
    <ValidationSummary></ValidationSummary> <.>
    // ...etc
----
<.> We can directly hook our method to `OnValidSubmit` so that we run our update
logic only when the form submission is successful (meaning no errors popped up on
model vlaidation). We have the option to hook into `OnInvalidSubmit` also.
<.> In order for the `<EditForm>` to sort of **gain** the ability to start validating
through the model's possible data anotations we need to add this inner component
inside of it (this pattern is pretty interesting, might have to keep it stored for
self-built components or overall a new pattern for approaching these types of use
cases).
<.> And lastly we can simply use a built-in component that spits all the errors
that it might find within the model based on the rules that Data Anotations might
express.

We can test out if our code actually works as intended by going to the website,
deleting the city and name fields and trying to submit. We should be seeing
both a message on red and then the respective fields highlighted with red, Blazor
should have abstracted all of the things that make this work in the background,
(classic Microsoft). We can check that we didn't actually trigger an update by
going back to the server list, we should see that nothing changed. And if we update
something that is valid, we should see the change coming through.

[source, razor]
----
<div class="row mb-3">
        <InputNumber hidden="true" @bind-Value="@_server.Id"></InputNumber>
        <div class="col-2">
            <label class="col-form-label">
                Name
            </label>
        </div>
        <div class="col-6">
            <InputText class="form-control" @bind-Value="_server.Name"></InputText>
        </div>
        <div class="col">
            <ValidationMessage For="() => _server.Name"></ValidationMessage> <.>
        </div>
    </div>
----
<.> Another special component is `ValidationMessage`, we can literally put it next
to control element and then through a Lambda expression point to the specific model
property that should be wired to.

_This is really cute_. But I get the principle. Again, abstract, make things easier
for the devs and all. But we are losing vital knowledge and experience in the way.
Anyway, this component will show a message in red and will also respond based on
the errors that the wired-up field presents.

[NOTE]
====
For the `IsOnline` field we don't have to do the whole `<ValidationMessage>` bit
technically, however for good measure we can add it.

I also just came to the realization that this is all in the default SSR mode,
with no reactivity in mind. Hence we have to do things so cutely (I'm assuming).
It's pretty close to normal HTML, faster and all. So depending on your requirement
you might switch the mode and add/subtract/change the conventions, and patterns
you use.
====

We are free to chose which component to use based on the requirements, never forget
about that.

==== Navigation with NavigationManager & Dependency Injection

We will talk about DependencyInjection, why? Because it's necessary to learn how
to hookup a component to DI services/components.

In short, we are required to somehow "programatically" trigger router navigation,
(this is really interesting now, the languages, frameworks, things might change,
but core concepts that respond to universal programming problems are still there,
you just need to learn how to represent that in a different language most of the
time).

We want to trigger RouterNavigation when we do an update on a server, this has
to be done behind the scenes, take the user to the servers screen to see the server
with hopefully the updated field.

_Cute Blazor:_ By adding a dependency injection component hot reload just doesn't
really work well, I think Microsoft was just too stubborn to realize that the way
they built this didn't account for market standards (React, Angular, Vue, Svelte),
and now have a half-measure for hot reload, but you are forced to keep on reloading
everything. (The con you take for not learning javascript I guess?).

How should we get the `NavigationManager` in our component to start routing:

[source, razor]
----
@inject NavigationManager NavigationManager <.>

// Code

private void Submit()
    {
        if (_server is null)
        {
            return;
        }

        ServersRepository.UpdateServer(_server.Id, _server);
        NavigationManager.NavigateTo("/servers"); <.>
    }
----
<.> This is Blazors solution to DI in a built-in way. The components are under the
hood just classes, and we want to move away from bad patterns of the past. We
want to invert dependencies.
<.> And after we have injected the `NavigationManager` we use the same name to
then start consuming the instance.

We don't want to have classes depend on other classes e.g., `var nav = new NavigationManager()`,
and Microsoft's philosophy is to always abstract things for devs and users so that
they are "easier". To a detriment sometimes, but that's besides the point. In this
attempt, DI is also taken care of for us through the Blazor framework, we just need
to know how to consume it and forget about the details, (abstraction). By inverting
dependencies here, we avoid memory leaks, and forget about lifecycle management
of another class from another class.

[IMPORTANT]
====
This is how under the hood Dependency Injection works:

We want to keep components loosely coupled, not depending between each other.
In order for that to happen we need to decouple them with depency inversion.
Who takes care of this is decided on the framework and designer's minds, but for
ASP.NET Core, which Blazor is a part of, we have an internal component called
"DI Container". This is the _thing_ that helps us inject the required instance
of a component inside of another component, and he will take care of lifecycle
management and all. `NavigationManager` is pre-registered in the DI Container,
that way we can focus entirely on building what matters and not worry too much
about these _"technicalities"_.
====

If we take a look at the `Program.cs` file, we can easily pinpoint the location
of the Dependency Container:

[source, cs]
.Program.cs
----
builder.Services.AddRazorComponents();
----

Inside of the `Services` proprety of the `builder` we are referencing this oh-so-called
mythical dependency container. If we drill down into its code we can see how this
collection abstracts things such as `TryAddSingleton<>`, `AddScoped<>`. These are
all calls to add services into the containers. Tying into the `AddScoped` call and
SignalR (which is what powers Blazor), we should be aware of one key thing: **SCOPED
SERVICES ARE ALIVE AS LONG SIGNALR HAS AN OPEN CHANNEL, ONCE IT CLOSES THE SERVICE
ALSO GETS GARBAGE COLLECTED**.

Reading further into subsequent calls of the code, we can see `services.TryAddScoped<NavigationManager, HttpNavigationManager>();`,
which is actually the `NavigationManager` that we injected into our blazor component.
As you can see, this is abstracted and ready for us to use, but it's still **GOOD
TO KNOW HOW IT WORKS UNDER THE HOOD**.

And yeah, this is all the knowledge you need as a base line. _Remember it_.

The `NavigationManager` is an abstract class, its almost an interface, the concrete
implementation in Blazor is `HttpNavigationManager`. Due to this design decision,
the framework has properly used best practices and correct implementations of
theory, it has effectively removed the dependency in a **concrete implementation**

**BIG TAKEAWAY:** So there's a reason for all of this.


[NOTE]
====
If we need to inject extra services we can add into the DI container with
`builder.Services.AddScoped<>`, `builder.Services.AddSingleton<>`. And always
as a best practice is to add an abstract/interface and then its concrete implementation,
that's the best way to align with clean code.
====

Infrastructure helps, .NET Core, helps with everything. Thanks.

==== Assignment 3: Add Server

We want to add a server.

- Adding a routable component
- Using Forms
- Using NavigationManager

Pretty straightforward, instructions not really clear, but I can only assume that
the city images when pressed on the button it will route back to the Add Server
component and have the city pre-filled. For whatever reason I can't map the
navigation though. It's just not working. Maybe SSR has to play a part in here???
Don't know.

Will have to look at the Answer, _as much as it pains me to do so_.

==== Assignment 3: Answer

AddServer is another routable component: So `Pages > AddServer.razor`. In a
real project, we have the option of turning the `EditServer.razor` in a multiple-purpose
component. But our requirement is constraining us.

But one key takeaway here is that if we are going to get a "multiple-purpose"
type of component this should be placed inside of a reusable components folder,
such as `Controls`.

The course made a mistake, it's setting the `IsOnline` to `false` in the object
initialization. But that's redundant, booleans have a `false` value by default
on C#.

A good point to bring up here and it's worth remembering.

`AddServer.razor` and `EditServer.razor` have repeated code (which is bad but we
are not focusing on this for now). They have the same form name, this is **OKAY**.
Because when we submit a form and the whole page gets packaged alongside the form and
its state, we will have the url as another way of differentiating the requests in
the server, there is no risk of **clashes**.

A couple of additions to the code based on the answer:

- We don't need to add the hidden _id field_, since the ID doesn't exist and will
be calculated on the Repository side.
- We should use the `[SupplyParameterFromForm]` anotation on the model that we have,
don't forget that after a submit the form state will bind to the property that
has this anotation.
- Lastly we need to navigate back to the servers list page with the `NavigationManager`

And this is where the nebulous requirement really messed me up, we are apparently
going to add a button for Add Server at the bottom, none of the fancy stuff I
was trying to do, I'm realizing that the list of cities is probably for filtering
purposes.

So yeah, pretty straightforward, just add an anchor to trigger navigation to the
AddServer page:

````
<a href="/servers" class="btn btn-primary ">Go Back</a>
````

And also the `IsOnline = false` behavior now is clear, because the default constructor
of the `Server` class actually by default turns the server on. But on this specific
page, we don't want that type of behavior, is weird since we will get the checkbox
already checked for us, so we are overriding it to set to false.

The behavior that should be working is that after we try and save the new server,
we should be seeing how the list gets a new line item.

==== Use EditForm to delete data

We will use the `EditForm` to delete data. In our domain, we will delete a server,
and at a technical level we will have to use the `EditForm` because we are with
Blazor SSR.

If we try and _not use the EditForm_, with code like this:

````
<button class="btn btn-primary" @onclick="@(() => DeleteServer(server))">Delete</button>

private void DeleteServer(Server server)
{
}
````

It won't work. Still it's good to breakdown what's happening here. In short, we have
this specific property that Blazor adds to Html elements `@onclick`. In here we
can simply declare a method name as the callback, or use this explicit syntax so
that we can insert a lambda function in order to pass arguments to the method call.

The reason this code won't work in SSR is because we have **NO INTERACTIVITY** at
all. This is all server side, and the `@onclick` syntax is something that assumes
we are going to handle things with javascript/code.

**IMPORTANT:** This is why we need to use our form component to submit the action
back to the server and then trigger the logic on the server side to handle this
deletion.

So the way to properly deal with our requirement under SSR we would have to
do the following:

[source, razor]
----
<ul>
    @foreach (var server in servers)
    {
        <li>
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
            <a href="/servers/edit/@server.Id" class="btn btn-link">Edit</a>
            <EditForm
                Model="server"
                FormName="@($"server-{server.Id}-form")" <.>
                OnValidSubmit="@(() => DeleteServer(server))"> <.>
                <button type="submit" class="btn btn-primary">
                    Delete
                </button>
            </EditForm>
        </li>
    }
</ul>

@code {
    private List<Server> servers = ServersRepository.GetServersByCity("Toronto");
    private List<string> cities = CitiesRepository.Cities;

    private void DeleteServer(Server server)
    {
        if (server.Id <= 0)
        {
            return;
        }

        ServersRepository.DeleteServer(server.Id);
        servers = ServersRepository.GetServersByCity("Toronto"); <.>
    }

}
----
<.> This is an `<EditForm>` nested within another `<EditForm>`. And because this
is a multiple render piece of code, we would in theory be creating n forms per
line item, if the name is the same it would easily clash. Hence we are applying
explicit syntax on top of string interpolation to compose a _unique enough_ identifier
for the form.
<.> Hooking into `OnValidSubmit` we can then apply the lambda trick to call our
method with respective arguments.
<.> And in here the course varies with my choice, I say we simply update the state
with another retrieval of servers. The course actually injects the `NavigationManager`
and triggers a redirect to the same page. This should be more costly, wouldn't it?

In the end is the same result, but there's nuance to be taken here. We delete
a line item and somehow trigger an update to the page so that the new state is
reflected.

[NOTE]
====
Well, the course actually introduces `NavigationManager.Refresh()` which is good
to know it exists. Maybe it isn't as costly as a full-on navigation? Anywho, at
the time of the tutorial apparently Blazor had a bug and trying to call this method
resulted in an exception. Which is _interesting_. And so, as a workaround, it
actually uses `NavigationManager.NavigateTo("/servers")`.
====

[IMPORTANT]
====
Another piece of "good practices", it's explained that in theory we could literally
code a page that is just in charge of sending a delete signal to the server.
`@page /servers/delete`. Or something like that. But this is really bad because
it can easily be tampered with. Say we call it with an anchor link by passing a
server Id as a route parameter, this will be caught by the browser and a malicious
actor can literally start using it to delete all the data in the server. The form
submit is more secure, since it packages all the data under a `POST`, and the
URL and payload are not really visible. Therefore for deleting data this approach
is the recommended one.
====

With interactivity, this principle and good practices are kinda invalid though.

==== Stream Rendering

We have been using Blazor SSR. Each time we ask for something from the server
we get a response in return. One of the biggest issues of traditional web applications
and Blazor SSR as well is that if the server is under stress, then the response
from the server to the clients slows down. The UX is just waiting.

If we analyze the scaffolded `@attribute [StreamRendering]` from the `Weather.razor`
component. And remove it for testing purposes (because this attribute is specifically
there to solve this issue) we can start putting Blazor SSR to the test.

If we play around with the `NavBar` by clicking on `Home` and then on `Weather`
we will immediately pick up on a specific behavior. Even though we clicked on
the respective menu item, the screen kinda _freezes_ and it seems as though it's
stuck. (We also added a delay of 3 seconds to the code in the component that simulates
a delay responsed from the server). **This is the issue**, the UX ends up affected
negatively. We are waiting for data to come back from the server side so that
the browser renders the respective page.

Because everything renders statically, everything is retrieved from the page request.
Your hands are tied until the response comes back from the server.

[IMPORTANT]
====
However, Blazor SSR has a QoL. This is in the form of a javascript file that you can
easily point towards at `App.razor`. In there there's a line: `<script src="_framework/blazor.web.js"></script>`,
this adds a specific set of behaviors that help us get around this issue of traditional
static sites.
====

With this script, we can then add the attribute that we deleted before to test out
the "stuck" problem. And we see that even though the same delay might be there,
we get a UX that involves going into the page, and seeing some content but also a
`Loading...` message, and after the data is "available" the content gets rendered
accordingly. This is easily solvable by this sole attribute. And also the code
that takes care of showing the loading messages and then further content:

[source, razor]
----
@if (forecasts == null) <.>
{
    <p>
        <em>Loading...</em> <.>
    </p>
}
else
{
    // And in here is logic to show the Weather Forecast table
}
----
<.> As you can seem this is simple conditional rendering in case the state variable
is null, we will display some form of content and if not another form of content.
<.> This stock message of "Loading..." is displayed in case we don't have the list
of forecasts loaded just yet.

"If the data is loaded, it will show "Loading"". So for the use case of using
Blazor SSR, yet a requirement requires for you to run a long running process that
retrieves data or takes time to compute the data and you don't want that bad UX,
you should leverage this `StreamRendering` attribute and display these stock pieces
of content to feedback the user with "Loading".

=== Add Server Interactivity

==== What is interactivity

We need to answer another question first in order to answer "What is interactivity?"

_What is not interactive?_

In traditional static sites, you will send a request to the server and the server
will then respond and the whole page will be reloaded. And in certain use cases
it might feel as though you lost connection to the server for a bit. And this is
because the whole page gets packaged, gets sent, we get it back and re-render.

_The browser is doing something, and the process hangs_ **This is not smooth**.

One could argue that there **is** interactivity, between the user and the web
browser. But, when Microsoft refers to _interactivity_ in Blazor docs, it is
referencing to this idea of the UX not being _as smooth_, and this being qualified
as "not interactive".

An **interactive application** should work like a desktop application, it won't
get the whole page to get refreshed. In order to solve this issue, we can come
to one possible conclusion and that is that we should trigger a partial reload
of the page, update specific parts only. **Partial Page Rendering**, this is what
we call **_interactive_**.

_What is interactive?_

When we try to achieve partial rendering, we use Javascript. This leverages something
called the **DOM** (Document object model). The DOM is part of an HTML page, when
a user interacts with it, it is done by default, however this paradigm/idea takes
the premise that we should intercept the DOM interaction (between the user), and
once that interaction is captured, we will send a request to the backend server.

_Typically_ The Javascript would call a Restful API, wait for a response, get the
response, parse it, maybe process it a little bit and then use that data to **patch**
the DOM. When the patch is finished, we do a **partial re-rendering**, and the data
that the user expects is visualized.

_Traditionally:_ When wanting to add interactivity, a developer has to write
Javascript. However **Microsoft** provides a stock javascript that allows for the
developers to forget about writing javascript.

==== Use Enhanced Navigation in Blazor SSR for interactivity

This is the first step towards making a web app **interactive**.

We have to come clean about something though, this Enhanced Navigation is already
turned on by default on Blazor SSR, hence we are not seeing full page reloads even
when working with this stock, "simple" version of Blazor.

We can test this easily by just looking closely to how the page behaves, when trying
to press the nav bar buttons, we see that the navbar itself stays in place, we
don't get intermitent cuts that make apparent the whole page is being reloaded.

The page by default is **partially rendered**.

If we were to go to `App.razor` and delete the blazor javascript line, and then
reload the website, we can test with Dev Tools how the Network actually triggers
multiple calls, and even some interactions just break (look at the weather component).

If we analyze the Dev Tools again after adding back the blazor script. We will see
how one call is made and no other network call is detected. Another way to put this
thesis to the test is opening up the _Inspect_ section of the Dev Tools, in here
after navigating we can see how some HTML elements are re-rendered, not the whole
DOM.

**How does this work**

Whenever a user interacts with the DOM, an http request is supposed to go to the
server, but the Blazor javascript file intercepts this default behavior and then
sends a fetch to the server on its own. Once it gets back, then the Blazor script
smartly patches the DOM. (The DOM is partially rendered). With this model we reach
**interactivity**.

Blazor SSR by default with the _Enhanced Navigation_ is an **interactive application**
thanks to Blazor's javascript file in `App.razor`.

==== Use Enhanced form handling in Blazor SSR for interactivity

With the help of Enhanced Navigation, even on Blazor SSR devs can easily create
"interactive" web applications. However, this covers the navigation part of it solely.
The user can go from page to page, yet load static pages only in the end. What
if the user wants to do something _dynamic_?

I.e., If we click on the "Montreal" button on the servers page, we want to filter
all the servers in that city. This is an interaction that the user triggers on the
page, and in theory should then trigger a partial-reload of another part of the page.

With the help of **Enhanced Form Handling** even Blazor SSR can make a page dynamic.

We don't need anything fancy (no need of Web Assembly, no SignalR channel). We
can just use the `EditForm` component to achieve dynamic behaviors.

And so, first of all we are going to now start leveraging the `ServerComponent.razor`
component we created way back.

First render it in `Servers.razor`. And we will modify its code like this:

[source, razor]
.ServerComponent.razor
----
@if (server is null)
{
    return; <.>
}

<EditForm Model="server" FormName="serverComponentForm" OnSubmit="ChangeServerStatus"> <.>

    <div style="@($"color: {(server.IsOnline ? "green" : "red")}")" data-name="@server.Name"
         data-status="@(server.IsOnline ? "online" : "offline")">
        @server.Name is in @server.City that is @(server.IsOnline ? "online" : "offline")
        <button type="submit" class="btn btn-primary">Turn On/Off</button> <.>
    </div>
</EditForm>

@code {

    [SupplyParameterFromForm] private Server? server { get; set; } <.>

    private void ChangeServerStatus() <.>
    {
        if (server is null)
        {
            return;
        }

        server.IsOnline = !server.IsOnline;
    }

    protected override void OnParametersSet()
    {
        server ??= new Server <.>
        {
            Name = "Server1",
            City = "Toronto"
        };
    }

}
----
<.> Smart clean code to short circuit renders.
<.> We will leverage EditForm to submit but will add the smart/enhanced variation
for interactivity
<.> We want to bind all the form state to this model, so the respective parameter
should be set as well.
<.> And we will bind to the submisison of the form with a callback method.
<.> Lastly, we should leverage `OnParametersSet` as the hook to go into to initialize
our server, and that is because when we add the anotation for the model binding
of the form, this will be turned into a parameter, so a submission will trigger
this hook.

Now, if we try and run this as is, it won't work, because there are no fields whatsoever
inside of the form that hold values and that can then be bound to the model. We
have to imperatively add some sort of form fields, _this is hacky_.

````
<EditForm Model="server" FormName="serverComponentForm" OnSubmit="ChangeServerStatus">
    <InputNumber @bind-Value="server.Id" hidden></InputNumber>
    <InputText @bind-Value="server.City" hidden></InputText>
    <InputText @bind-Value="server.Name" hidden></InputText>
    <InputCheckbox @bind-Value="server.IsOnline" hidden></InputCheckbox>

    <div style="@($"color: {(server.IsOnline ? "green" : "red")}")" data-name="@server.Name"
         data-status="@(server.IsOnline ? "online" : "offline")">
        @server.Name is in @server.City that is @(server.IsOnline ? "online" : "offline")
        <button type="submit" class="btn btn-primary">Turn On/Off</button>
    </div>
</EditForm>
````

As you can see we are literally putting all the state fields under hidden fields,
(it's good to know that we can put a more concise type of attribute with just `hidden`).

And once we hit the submit, all these values will be bound to the respective model
properties. And after that, we will have the `OnSubmit` callback run its logic
to then modify the state variable accordingly. (And this will trigger a full page
re-render btw). Even the scroll position is lost. Logic works though.

_How do we make the page interactive?_

This is crazy dude:

````
<EditForm Enhance Model="server" FormName="serverComponentForm" OnSubmit="ChangeServerStatus">
````

Literally, one attribute `Enhance`. This could be `Enhance="true"`, but you know
how I like to be as concise as possible.

After adding this, then interactivity is figured out by Blazor without us having
to do anything fancy. Page is partially reloaded.

Again, this is all thanks to `blazor.web.js`, the script at `App.razor`.

These two features were added in `.NET 8` which is actually crazy. This is pretty
new. It's through SSR that we can achieve almost everything we want to achieve.

_But there's something even better:_ **Server Interactivity**

==== What is server interactivity?

In the previous sections we have talked about Enhanced Navigation and Enhanced
Form Handling. We have seen how interactivity is achieved.

But Server Interactivity, Server Interactive is something besides just a javascript
file that works with the DOM and backend server.

On this second paradigm, we still use the javascrip file, but the request and
responses are different. We don't work with HTTP, we work with Web Sockets, we
establish a SignalR channel.

The moment the application is loaded in the browser, the blazor javascript file
establishes this channel between the website and the server. A memory representation
of the web site on the server is created, and said memory representation will receive
all the requests coming from the website and process them respectively. One the
process is finished, a binary message will be returned to the **client**. The
JS script interprets the message, and **patches the DOM**.

The communication is different, and **THE BACKEND AS WELL BEHAVES DIFFERENTLY**.

The messages are binary, so fast, and very minimal, the whole process has been
optimized to its fullest extent (to date). Performance is not bad.

**_Render Tree:_** In the DOM (on the web browser) we have all elements grouped
together, nested and forming what it looks like a **tree**. In the backend when
the in-memory representation of the page, there's also a render tree **held in the
memory.**

The way the algorithm (really simply put) is that in-memory we will always hold a
"previous state render tree" and after processing a "new state render tree", Blazor
will calculate the difference between these two trees and package all that needs
to be updated on the web browser side so that a **smart patch** takes place. It will
only understand "one new component has been added". This has a term, "render tree
difference". The blazor javascript file understands this binary encoded difference
and acts accordingly. (Hence the user sees an update visually).

==== Enable Server Interactivity how to make a component interactive

How do we enable server interactivity?

We are going to make the `ServerComponent.razor` component interactive. (Whilst
it technically is already interactive with Enhanced Form submit, we want the actual
thing).

If we were to change the code a bit:

[source, razor]
----
@if (server is null)
{
    return;
}

<div style="@($"color: {(server.IsOnline ? "green" : "red")}")" data-name="@server.Name"
     data-status="@(server.IsOnline ? "online" : "offline")">
    @server.Name is in @server.City that is @(server.IsOnline ? "online" : "offline")
    <button type="button" class="btn btn-primary" @onclick="ChangeStatus">Turn On/Off</button> <.>
</div>

@code {

    [SupplyParameterFromForm]
    private Server? server { get; set; } = new()
    {
        Name = "Server1",
        City = "Toronto"
    };

    private void ChangeStatus() <.>
    {
        if (server is null)
        {
            return;
        }

        server.IsOnline = !server.IsOnline;
    }

}
----
<.> The `@onclick` syntax is something we use with Server interactivity.
<.> However there's an issue here, and that's that nothing will happen if we
press the button. And that is because we need to turn on Server Interactivity. Even
if you run the app in debug, breakpoints will never be hit.

How do you enable it? Just go to `Program.cs` and add these lines:

````
builder.Services.AddRazorComponents().AddInteractiveServerComponents();
// More code

app.MapRazorComponents<App>().AddInteractiveServerRenderMode();
````
**IMPORTANT:** We have to chain in a fluent way, otherwise we won't have access
to these methods.

With these two lines, we still won't get the button working. We actually have to
add this specific property:

````
<ServerComponent @rendermode="InteractiveServer"></ServerComponent>
````

The render mode will turn on or off the specific SignalR channel type of communication.

If you load the page, the button should work **and** if we analyze http requests
through the Dev Tools, no request should be getting registered. In order to see
the SignalR channel.

If we reload the web page and have a look at the _Network_ we will actually be
able to see how the website downloads the `blazor.web.js` file, and then a request
looking something like this: `ws://localhost:5116/_blazor?id=qfAbJP7iDGSOd4SIdlu6vA`
is registered. **This is the websocket handshake between the component and the
server.**

If you click on the web socket registered connection and click multiple times on the
button, you can see how the messages get logged. And even further you can see
the _byte size_ they have. These messages are the render tree differences that are
getting exchanged.

Again, in short.

. The `blazor.web.js` files negotiaties a SignalR channel between the browser
and the server. This is for the different components that work with server interactivity.
. This channel is used back and forth to send and receive information that updates
the view with interactivity.

==== Interactivity Location

After making a component interactive, by adding on `Program.cs` specific behaviors,
and by marking the component as `@rendermode="InteractiveServer", we manage to
achieve interactivity. This is what's called _Interactivity Location_.

We can add this interactivity location in different places:

- On the parent component
- On the mention of the component on the parent's code
- On the actual component itself

_If we take away the interactivity location and try and test the button, we should
prove the idea that this is what adds interactivity, and hence the workflow works_.

````
@page "/servers"

@rendermode InteractiveServer
````
This is how interactivity location at the parent level would look like. This
cascades interactivity down to all children and their own sublevels.

If not, we can go down to the actual child component and apply **the same notation**,
after that the component and any subsequent children components will have the
interactivity mode setting cascaded down the tree.

This is the **First Type of Interactivity Location**.

1. Page or component level
2. Global

The _Global level_ can be added by going into `App.razor` and then adding the interactivity
mode at the `Routes` component level that is what renders everything on our SPA.

````
<Routes @rendermode="InteractiveServer"/>
````

And here you can switch between different modes, may it be **WebAssembly, Server**.

These are the two type of locations for interactivity leveraging.

**What is recommended?**

We should specify the location at the parent level but on the explicit component
render syntax:

[source, razor]
.Servers.razor
----
<ServerComponent @rendermode="InteractiveServer"></ServerComponent>
----
This is the way. If you add it to the explicit component at its top, you can easily
clash with switching for other render mode, since it will take precedence and your code
will become _HARDER TO EDIT LATER_.

[IMPORTANT]
====
So Microsoft themselves enforce _this specific pattern of specifiying the interactivity
mode where you call the component.
====

==== Server Interactivity in Visual Studio project template

We started with a Blazor SSR template, however what happens if we start with another
mode? (_NOTE:_ The `Blazor Web App` template is the recommended one to use after
.NET 8).

You can select as a template setting to use Server Interactivity, and even set the
Interactivity location "Per Page/Component". This will start a project with the
two lines at `Program.cs` that we saw, plus all components that are pages with
the _cascading interactivity mode_. at the top of each of them. `Routes` does not
have the interactivity location, nor static pages, since they don't require interactivity
at all. Only the `Counter` page has interactivity set on, and that is because it
is required by it. So a rule of thumb is to ask yourself if the component
**really needs to be interactive**. Otherwise a static website will work just
fine.

_Extra:_ What if we select Server render mode and with Global?

Same things, but if we look at `Counter.razor`, we see no interactivity location.
That is because we will have it at the `App.razor`'s `<Routes>`' component level.
This is how the template can be used to set everything up from the start, but the
most important thing: **You know now how this works**.

==== .NET 9 Updates: Include SSR in Global Server Interactivity location

November 4th 2024 - There are a few features that have been introduced in .NET 9,
many minor with this exception:

We will use SSR, but on a Global Server Interactivity Location.

[source, razor]
----
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <base href="/"/>
    <link rel="stylesheet" href="@Assets["lib/bootstrap/dist/css/bootstrap.min.css"]"/>
    <link rel="stylesheet" href="@Assets["app.css"]"/>
    <link rel="stylesheet" href="@Assets["ServerManagement.styles.css"]"/>
    <ImportMap/>
    <link rel="icon" type="image/png" href="favicon.png"/>
    <HeadOutlet @rendermode="InteractiveServer"/> <.>
</head>

<body>
<Routes @rendermode="InteractiveServer"/> <.>
<script src="_framework/blazor.web.js"></script>
</body>

</html>
----
<.> This is another component that should get the Global Interactivity Location.
<.> And this is the Routes component with the Interactivity Location set there so
that all components get it applied.

But there could be exceptions, we could have components that are coded to work
with SSR, not interactivity, hence we want to mark them to keep using SSR. Or
perhaps we just want a couple of specific components to use it. Whilst being
under Global Interactivity Location already. (e.g., A particular component has
to be dependent on cookies. With interactivity, things are done through a SignalR
channel, this, for example, makes it impossible to rely on cookies. So we would
be forced to make the component SSR compatible and use it). 

Microsoft has thought of this use case, and has added a feature to make it easy
to do it:

https://learn.microsoft.com/en-us/aspnet/core/release-notes/aspnetcore-9.0?view=aspnetcore-9.0#add-static-server-side-rendering-ssr-pages-to-a-globally-interactive-blazor-web-app[DOCS]

We must use this attribute in the component, e.g., `AddServerComponent.razor`.
Remember that this should be done in a **ROUTABLE COMPONENT**.

[source, razor]
.AddServerComponent.razor
----
@page "/servers/add"

@attribute [ExcludeFromInteractiveRouting]
----

And lastly we should change the `App.razor` component:

[source, razor]
.App.razor
----
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <base href="/"/>
    <link rel="stylesheet" href="@Assets["lib/bootstrap/dist/css/bootstrap.min.css"]"/>
    <link rel="stylesheet" href="@Assets["app.css"]"/>
    <link rel="stylesheet" href="@Assets["ServerManagement.styles.css"]"/>
    <ImportMap/>
    <link rel="icon" type="image/png" href="favicon.png"/>
    <HeadOutlet @rendermode="@PageRenderMode"/> <.>
</head>

<body>
<Routes @rendermode="@PageRenderMode"/> <.>
<script src="_framework/blazor.web.js"></script>
</body>

</html>

@code {
    [CascadingParameter] private HttpContext HttpContext { get; set; } = default!;

    private IComponentRenderMode? PageRenderMode => HttpContext.AcceptsInteractiveRouting() ? InteractiveServer : null; <.>
}
----
<.> See how we no longer set this to `ServerInteractivity` but to a custom render mode.
<.> Likewise for `Routes`
<.> This is advanced code, we won't break it down for now, this is just copying
things from the Microsoft Docs to enable this specific feature.

At a high level, this `@PageRenderMode` is a switch under a property that will attempt
to run the `AcceptsInteractiveRouting()` extension method that will try and detect
the attribute of exclusion. If it detects it will not try and set the component
with interactivity and keep it as SSR.

==== Three main aspects of interactive components

A brief reiteration:

- The user interacts with the DOM, and the blazor javascript intercepts that
interaction.
- Because a SignalR channel has been setup from the beginning, and we now work
with in-memory representations of components on the server, this makes the application
a **stateful application**.

Once you use interactive components in Blazor, this becomes **stateful**. _At least
for that component_. The component is a stateful component.

An unstateful application is the traditional app. After a request and response,
roundtrip, the server doesn't remember the state of the application. None of
the states are remembered.

**But with interactivity**, the app becomes _stateful_. For stateful applications
there are three main aspects.

And this is in general, not specific to Blazor.

. View = User interacts with the View. The user doesn't care about components. Only
what he sees
. Event = The action on the view triggers a type of event, as developers we do
something with the information the user provided in that interaction that triggered
the event. Maybe we calculate something, get data from the database. This changes the
internal **state variables**.
. States = The handling of the events changes the state variables, the states of
the component. And when the state gets updated, the view gets updated accordingly,
hence these three concepts are closely related to each other.

Any interactive component/application. All SPA applications are stateful.

*8Remember this, it will apply to WebAssembly as well.** This is a key concept that
we should interiorize to then have a framework as to how code properly in Blazor.

==== Event Handling (Passing Data)

When you pass data inside of a event, we need to learn how to leverage Blazor.

The use case that will launch us into learning this concept is as follows:

_We want to be able to press the city buttons on the server list screen and then
filter out the list of servers in that city, move away from the hard coded "Toronto"
list_

The syntax to achieve this is pretty simple:

[source, razor]
====
<div class="card-body">
                        <button type="button" class="btn btn-primary"
                                @onclick="@(() => SelectCity(city))">@city</button> <.>
                    </div>

@code {
    private void SelectCity(string cityName)
    {
        servers = ServersRepository.GetServersByCity(cityName); <.>
    }
}
====
<.> We leverage `@onclick` and we use the explicit syntax in order to wrap a
method call under a lambda that will have the call of the method with an argument.
<.> And then the actual logic of the method will have the received parameter as
a passdown to the `ServersRepository`.

The course makes a point about interactivity not working but this is because it didn't
have the _global_ setting we applied with `.NET 9`'s update lesson before. So we
can kind skip it, however, it's mentioned again the concept of interactivity location,
and how a good practice is to have it in the page that then renders a component.

Understanding the different "settings" or "modes" of interactivity in Blazor is
key to understand and then leverage appropriately based on the use case. `(View -> Event -> State)`

Every time you work with a stateful component, we have the _three aspects_

[IMPORTANT]
====
The whole concept of stateful application and the **in-memory representation** of
a component in the server is key to remember one optimization that Blazor accounts
for. If we have loaded the state in the server, we won't be re-rendering, fetching
data all the time, the server **remembers that component's state**. It's only after
disposal that we might have to reload a component's data. Now, in **Blazor SSR**
the whole state is indeed reconstructed, but it's due to the Enhanced Form and
Enhanced Navigation that we don't see the page reloading every time.
====

InteractiveServer is technically _simpler_ than SSR. However state is kept and
optimizations take place. It looks a bit like javascript. _Simplicity is key_.

==== Assignment 4: Highlight current City

. We want to have the selected city by a click to show visually it's currently
selected
. We should leverage Bootstrap for it apparently

No idea about styling, I will leave that to the course, but the core logic is pretty
simple, and something I didn't catch on before is _why we were adding a field for
the selected city_. That is because we can leverage that to calculate which
city item is selected:

[source, razor]
====
<div class="card">
                    <img style="max-width: 150px; max-height: 150px"
                         src="@($"/images/{city}.png")"
                         class="@($"card-img-top{IsActive(selectedCity, city)}")" <.>
                         alt="Card image cap">
                    <div class="card-body">
                        <button type="button" class="btn btn-primary"
                                @onclick="@(() => SelectCity(city))">@city</button>
                    </div>
                </div>

@code {
    private string selectedCity = "Toronto"; <.>

    private void SelectCity(string cityName)
    {
        selectedCity = cityName; <.>
        servers = ServersRepository.GetServersByCity(cityName);
    }

    private static string IsActive(string currentCity, string cityName) =>
        currentCity.Equals(cityName, StringComparison.InvariantCultureIgnoreCase) ? " active" : string.Empty; <.>
}
====
<.> As you can see on the fly, per rendered item we will calculate if the specific
item corresponds to the selected city, if it does then we will add the `active`
class name, otherwise it will be empty.
<.> And it now makes sense why we have to keep the state of the selected city like
this.
<.> And of course we have to update the state based on the event.
<.> A good way to abstract code and keep the view tight, is by putting calculation
logic behind functions, _this is a good practice_. Hence this takes care of just that,
and that's also another reason as to why we leverage string interpolation so that
we can chain together text and possible calculation method calls.

==== Assignment 4: Answer

When it comes to styling, the course leverages "border primary":

````
<div class="@($"card{IsActive(selectedCity, city)}")">

private static string IsActive(string currentCity, string cityName) =>
        currentCity.Equals(cityName, StringComparison.InvariantCultureIgnoreCase) ? " border-primary" : string.Empty;
````

I actually had to change the function's position, since we are adding the border
to the whole line item, and that was on a superior level not the card image. But
yeah, pretty cool that it's simply by adding `border-primary` that we get what
we want. But it also solidifies my theory of making things easier to edit and add
later. Because this was abstracted behind a method, we simply had to change
one small line of code from `active` to `border-primary`, move around the view code
but it still kept the behavior and it was way easier to read.

[NOTE]
====
The course uses `StringComparison.OrdinalIgnoreCase`, is this better? is this worse?
The answer is not as cookie cutter:

Avoid `CurrentCultureIgnoreCase` in most library/business logic code — it depends
on the user’s local culture and can introduce subtle bugs. Save it for UI-facing
string handling only. So in this specific use case it should be fine, you can argue
that `OrdinalIgnoreCase` is slightly faster and catered towards `identifiers`,
`technical data`, `keys`, `performance-critical paths`.
====

==== Update, state variables with Onchange event

_Remember of the 3 aspects_ **AGAIN**

We will study `onchange` another event handler that we can leverage, it's a bit
similar to `onclick` but with its specific quirks. It's also a window into data
binding.

We will use another requirement to introduce this concept: `we want a search bar
so that we can search for servers`.

[source, razor]
====
<div class="input-group mb-3">
    <input type="text" class="form-control" placeholder="Search Servers" @onchange="HandleServerFilterChange" /> <.>
    <button class="btn btn-outline-secondary" type="button" id="search-button">Search</button> <.>
</div>
@serverFilter

@code {
    private void HandleServerFilterChange(ChangeEventArgs e) => serverFilter = e.Value?.ToString() ?? string.Empty; <.>
}
====
<.> We will hook the `@onchange` to a control directly, and we will have to pass a
callback to it that we also declare.
<.> The button itself has just different styling, but also the fact that it's not
of `submit` type.
<.> This is the callback function, when we hook it up to something like `@onchange`
it will automatically gain the `ChangeEventArgs` argument attached to it, and we
can leverage this object to then run logic, this function is pretty simple, if there's a
value captured it will assign that to a new state variable we declare if not it will
default to an empty string.

It's worth noting that the way `@onchange` triggers is when the control loses
focus, it's only then that our callback will get invoked.

[source, razor]
====
<button class="btn btn-outline-secondary" type="button" id="search-button" @onclick="HandleSearch">Search</button> <.>

@code {
    private void HandleSearch()
    {
        servers = ServersRepository.SearchServers(serverFilter);
        selectedCity = string.Empty; <.>
    }
}
====
<.> We want to stay consistent on naming so the `@onclick` callback should be
prefixed with `HandleSearch`.
<.> And lastly we will extend the requirements and functionality a bit, in the sense
that if we search for a server name we will stop marking an active selected city
and we will also filter the state variable so that only the specific server comes
up.

[NOTE]
====
A nice way of grouping together controls and labels is with bootstrap's `input-group`.
It's good to keep that in mind.
====

The way that the filter works is actually by partial string comparison, hence if we
search for something like `Server1` we will get all servers that have that partial
string at the beginning.

The click on the city name should still work fine, we shouldn't have to worry
about breaking anything.

_Small comment:_ Leveraging `@onchange` hits me as performant heavy, but I don't
know just yet. We'll see.

==== Two way data binding

Previously, we handled an event, and with that event we updated state. This is
how it works normally, but there's something better "data binding".

The value comes from the view to the state: Any change in the view will come back
to the state automatically, _this is called two-way databinding_.

The way to setup this is pretty simple with a really specific thing to keep in mind:

````
<input type="text" class="form-control" placeholder="Search Servers" @bind-value="serverFilter">
````

This syntax looks similar to the SSR Form syntax with one key difference the `value`'s
`v` is actually **lowercase**. In this specific way, this can enable us to bind to
a whole model.

And just like that we can delete the event handler that we created before, and test
out the same workflow and it should still work flawlessly.

_What happens behind the scenes?_

Blazor actually is leveraging the same event we hooked into. But Blazor is doing
that for us. With a `bind-value` it creates the `OnChange` event handler behind
the scenes.

**NOTE:** Sometimes you want to do something when the server filter is set, you
may want to intercept when a value is about to be added to state, in a event handler
setup we can easily intercept and apply custom logic, however with two way databinding
this is no longer possible, unless we use a property:

[source, csharp]
====
private string _serverFilter = string.Empty;
private string serverFilter
{
    get => _serverFilter;
    set
    {
        // Logic before or after
        _serverFilter = value;
    }
}
====
This requires for a backing field and this specific type of setup, but in the end
you will be binding directly to a state variable. The only caveat here might happen
with async use cases, but there are workarounds even there.

**NOTE 2: ** You might want to add more feedback for the user to see as he types
the filtered item, this can be done with a variation of the property:

````
@bind-value:event="oninput"
````
With this setup, then the property will be invoked on every key stroke that is pressed
on the control.

The app will react to every single input and we get instant feedback, so this is
a pretty interesting feature, but I think we should debounce this, performance
heavy. (The premise overall is that MS wants to make your life easier).

==== Interactive EditForm

We used the `EditForm` for SSR. With interactivity this changes a bit.

If we head down to the `AddServer.razor` file, depending on if it has interactivity
location or not, the `<EditForm>` component can now have its `FormName` removed.
It can still have it, but it's not necessary. Secondly, we don't need to specify
the `[SupplyParameterFromForm]`. Why is that? Simply put, because the form will now
be wired as interactive, it won't submit a POST to the server, it will follow
the SPA approach which is to send SignalR signals to the server. The attribute itself
implies that there's a form submission of some kind. But here with interactivity there's
no form submission anymore.

So basically, in case you coded something with SSR and want to move into interactivity
the process is not as painful, you don't have to change `bind-Value` because the
controls will be under `<EditForm>` and the wiring behind the scenes accounts for it
and we don't have to worry about anything.`

==== Use @key to improve list-rendering performance

We want to use the `@key` directive to improve list rendering performance.

Basically, as things stand right now, we have the `Servers.razor` page with a
`@foreach` directive that creates DOM elements based on a collection. But if we
actually test out with the Dev Tools of the browser, say an ad-hoc test workflow
that adds a new server to this collection. (Under the assumption that we are in
a page with interactivity), we can easily see how the DOM updates **all elements**,
Blazor apparently can't really patch only a specific item and re-renders the whole
list.

[NOTE]
====
Depending on the use case, on performance critical applications, this will tank
the UX without a doubt. Luckily we can leverage the `@key` directive to sort of
give Blazor more meta-data so that its difference calculation algorithm is smarter
and patches surgically the elements into the DOM.
====

````
@foreach (var server in servers)
    {
        <li @key="server.Id">
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
            <a href="/servers/edit/@server.Id" class="btn btn-link">Edit</a>
            <EditForm
                Model="server"
                FormName="@($"server-{server.Id}-form")"
                OnValidSubmit="@(() => DeleteServer(server))">
                <button type="submit" class="btn btn-primary">
                    Delete
                </button>
            </EditForm>
        </li>
    }
````
With this specific `@key` attribute, and we try to add a new element, the DOM
will be patched smartly. Be sure to use some form of data that is unique so that
Blazor doesn't clash between values and we lose the performance gain we are
aiming for. That's why this is a **best practice**.

**IMPORTANT:** This directive can be used in list elements `<li>` and table elements
as well. That is because these HTML elements are the one-to-one mapping of collection
line items.

==== Use Virtualization to improve list-rendering performance

Let's expose another possible issue in a specific scenario and a way to deal
with it.

_What if we have a lot of line items, in the thousands or ten thousands?_

When rendering a piece of DOM and the elements are a ton, the browser stalls
(regardless of how fast the PC is). You can easily run into this UX affecting
issue.

_How to solve this?_

Blazor has **virtualization**. This will replace a `@foreach` loop. But only if
three conditions are met:

. You have too many items.
. You are analyzing a foreach loop structure
. The rendered items are of the same height

If you only have hundreds of items, `@foreach` is better. Try to use virtualization
for big collections.

[source, razor]
----
<ul>
    <Virtualize Items="servers" Context="server"> <.>
        <li @key="server.Id">
            @server.Name in @server.City is
            <span style="color: @(server.IsOnline ? "green" : "red")">
                @(server.IsOnline ? "online" : "offline")
            </span>
            <a href="/servers/edit/@server.Id" class="btn btn-link">Edit</a>
            <EditForm
                Model="server"
                FormName="@($"server-{server.Id}-form")"
                OnValidSubmit="@(() => DeleteServer(server))">
                <button type="submit" class="btn btn-primary">
                    Delete
                </button>
            </EditForm>
        </li>
    </Virtualize>
</ul>
----
<.> `Virtualize` is a built-in component that Blazor exposes. By leveraging its
attributes you can easily map it to work with the collection that might have been
expanded with a `@foreach`. And just like that, painlessly, you get a way faster
render time for the collection. (No more stalls). 

[NOTE]
=====
What is actually happening? Behind the scenes Blazor takes care of a lot here.
It knows the height of each item and it knows the viewport, and it knows how many
items need to be rendered and it only renders those items. It won't render all of
the collection items. The more the user scrolls further, it will then start replacing
the items that are not rendered with new items, it's smoke and mirrors overall,
but abstracted and ready to consume. We don't have to re-invent the wheel. It
also knows about the `@key` principle and it auto adds it respectively we don't
even have to worry about that.
=====

=== Course Project (Part 1): To-Do List App Basics

==== Requirement of To do list app

We will put all of our knowledge to the test by building a simple app and applying
all the concepts we got introduced. This is a To-do list app, and it has the
following requirements:

. Display a list of tasks (we need to take ordering into account, completed tasks
are higher priority)
. Add Task (click event)
. Input task (two-way data binding)
. Mark task as completed (we can't edit the task further, and we should mark the
completed date)

Advice:

. Think of each use case, one at a time
. Have a framework that simplifies development (Bootstrap)

==== Display a list of tasks use case

Will use the same project, don't wanna create a new repository and all the hassle.

The requirements ask for:

- A text with the to do item
- State of completed or not
- Completed date

[IMPORTANT]
====
If you have issues, you can turn on a debug flag by changing the `appsettings.json`
file: `"DetailedErrors": true,`. Just add that at as a first class property and you
will get more info inside of the browser that helps with debugging way easier.
====

[NOTE]
====
Hot reload doesn't really work. Not really, a simple page add, and render foreach
content on it, just doesn't work. It literally forces you to go and reload things
manually. Don't really like that at all. (Apparently Visual Studio _of course_
has the better hot reload support).
====

Possible solution: `dotnet watch run --no-hot-reload` run this.

_Reconciling course and own solution_

The requirement wants to use a list item, I chose to override defaults so that
we don't get bullet points:

````
ul,
ol {
    list-style: none;   /* remove bullets/numbers */
    margin: 0;          /* reset default margins */
    padding: 0;         /* reset default padding */
}
````
And this was under: `ToDoList.razor.css`.

We have a model, a repository, the razor page for the to-do-list. The course copies
the repository, I implemented a more lean approach.

The course also reminds us of `_Imports.razor`.

**NOTE:** A good point in the course, it controls if the list is actually populated,
if not, we should just skip over rendering code:

````
@if (!_todoItems.Any())
{
    return;
}
````

The course doesn't even go further into actually implementing the Form Control yet
it just focuses on a list of the To-Do items. That's fair, but this is code that
actually does two-way binding and also ripped out of Bootstrap docs, it's literally
the exact UI that was presented as the final result:

https://getbootstrap.com/docs/5.3/forms/input-group/#basic-example[Docs]

[source, razor]
----
<ul class="todo-list">
    @foreach (var item in _todoItems)
    {
        <li @key="item.Id">
            <div class="input-group mb-3">
                <div class="input-group-text">
                    <input @bind-value="item.IsComplete" class="form-check-input mt-0" type="checkbox" <.>
                           aria-label="Checkbox for following text input">
                </div>
                <input @bind-value="item.Text" type="text" class="form-control" aria-label="Text input with checkbox"> <.>
            </div>
        </li>
    }
</ul>
----
<.> As you can see we bind the `bool` property of the line item directly to its respective
rendered control.
<.> And the `Text` property is also bound to the respective control.

==== Add Task use case

- Add a button by the top of the list. When clicking, we will be able to add a new
task.

(My choice): Add a dummy, somehow add for this newly added element a placeholder
text stating (Add the text here...) or something like that.

This is the code:

[source, razor]
----
<button @onclick="AddTodo" class="btn btn-primary mb-3">
    Add Task
</button>

<input @bind-value="item.Text" placeholder="@(CalculatePlaceholder(item.FreshAdd))" type="text" <.>
                       class="form-control" aria-label="Text input with checkbox">

@code {
    private string CalculatePlaceholder(bool freshAdd) => freshAdd ? "What do you want to do?" : string.Empty; <.>

    private void AddTodo()
    {
        TodoItemsRepository.Add(new TodoItem
        {
            FreshAdd = true, <.>
        });
    }
}
----
<.> Focus on `placeholder`, we are abstracting away code to calculate this text
since depending on state it should display a placeholder for better UX.
<.> We basically added a new property to the line item's class, this is something
that will help us display a placeholder for newly added tasks with the button to
add new items to the list.
<.> And we set this flag property to `true` only when they are coming from the
button click event.


_Course content_

- Course makes note of adding the Render Mode.
- It also already shows how the repo takes care of ordering, the priority is "IsCompleted"
and **then** "Id". So, not completed tasks will actually be displayed at the top,
_newly added tasks will be at the top_.

==== Input task name use case

This is something we already implemented I'm pretty sure. Still, it's interesting
to see how there are different ways to tackling the problem.

_Course content_

The course definitely deviates, but we can attribute that to unclear requirements.
It takes away border with a `border-0` class, and it also doesn't get rid of the
bullet points.

==== Mark task as completed use case

This is probably the most complicated use case.

. Dislay the checkbox, and allow the user to check and not check.
. We need to populate the completed date. And if unchecked this needs to be
also cleaned and not displayed anymore.
. The control should also be disabled since it's completed

This is the code to achieve the requirements:

[source, razor]
----
<input @bind-value="item.Text" disabled="@item.IsComplete" <.>
       placeholder="@(CalculatePlaceholder(item.FreshAdd))" type="text"
       class="form-control" aria-label="Text input with checkbox">
@if (item.IsComplete)
{
    <div class="p-3">
        <text>
            Completed Date: @($"{item.CompletedDate:D}") <.>
        </text>
    </div>
}
----
<.> We are actually leveraging `disabled` and implicit syntax to then turn on
or off the input field with concise code.
<.> This is another cool pattern to use. Besides the conditional rendering just in
case the line item is completed, we are also applying `format specifiers`, that on
string literals can help format dates with a pretty concise and clean syntax. The
`D` code is for a human readable "long date". Exactly what the course applies with
not so clean code.

_Note:_ It's also worth mentioning that we did apply fields and properties to
to intercept the change of the two-way bound `IsComplete` property. So that we
can add on the fly the completed date (that is set to that precise moment `DateTime.Now`).

It's nice that two-way data binding integrates with these other patterns nicely
without the need to learn even further.

=== Non-Routable Razor Component Deep-Dive

This is now introducing the idea of **thinking in components**.

This means that we are going to break a monolithic view into multiple components,
all of this in the spirit of _separation of concerns_. Meaning that it's easier
to maintain the code, easier to extend. (Makes editing in the future easy).

There are different principles to provide guidance:

- SRP (Single Responsibility Principle). If a component needs to change for
multiple reasons, then that component might be responsible for too many things.
If we make to many changes within the component, we might start looking at
refactoring.

Theory and its application can get messy, and its most of the time up to interpretation,
but we will follow for our project the idea of: "We will try and aim for our components
to do one specific task"

**The List of Cities**: Currently it's doing **two things**. One is displaying a
list of cities, and then displaying each city component.

**Search servers**: One component to search

**List of servers**: Has a list of servers, the add button, the actual line items.

**Thinking in components:** Is this ability to look at a screen and know what components
should be built, how to break down a screen in short.

This is an ability that should be trained, and is required to be proficient at.

==== Thinking in Components

The server management page will be broken down into multiple components. For the
first broken down component we will do a `ServerListComponent.razor` file addition
and literally carve out all the `ul` view code to it, and comment out things that
end up broken due to us moving away highly coupled pieces of code.

==== Extract the ServerList Component

Something the course focuses on is the fact that our custom components that we
create will also need the interactivity mode set to them, don't forget the syntax
that allows for interactivity to work and for us to leverage its capabilities:

````
<ServerListComponent @rendermode="InteractiveServer"></ServerListComponent>
````

The benefits of separating the code like this is simply to make it easier to
edit in the future. Less code for HTML and backend in the parent component, and
if an issue arises we know where specifically to go to debug.

````
private void DeleteServer(Server server)
{
    if (server.Id <= 0)
    {
        return;
    }

    ServersRepository.DeleteServer(server.Id);
    // servers = ServersRepository.GetServersByCity("Toronto");
    NavigationManager.Refresh(forceReload: true); <.>
}
````
<.> When trying to use the `NavigationManager` on the separated component this
line of code will look as if it doesn't work, we will later discuss how to fix this
properly, but for now, we will simply make it so that the router actually triggers
a full-on browser reload. This is bad, we are losing the SPA benefits and we can
easily introduce bugs due to state ending up lost. But for know, we will live
like this.

==== Use Component Parameters to communicate from parent to child components

Now that we have components, we need to think about how we communicate data across
them. _One way is **component parameters**_.

Looking at a workflow such as:

- Parent Component
- Child Component

We have components that will hold inside of them (orchestrate) child components.
And this parent component will need to somehow send this data from one component
to the other. Based on events, signals will have to be wired.

If we go to `ServerListComponent.razor`, we can add a property with a specific
decorator so that we allow for it to take a property from a parent component:

````
[Parameter]
public string? CityName { get; set; }

private readonly string FALLBACK_CITY = "Toronto";
private List<Server> servers = [];

protected override void OnParametersSet()
{
    servers = ServersRepository.GetServersByCity(CityName ?? FALLBACK_CITY);
}
````
This is using best practices, we have a fallback city name in case we don't get
a paremeter back from a parent. Otherwise we will use the hook in which we are
sure a parent has fed us (or we at least should have an actual value coming from
the parent). `OnParametersSet()`. And there we can run logic with the parameter's
value.

And on the parent:

````
<ServerListComponent CityName="@selectedCity"></ServerListComponent>
````

In short, we should be able to go to the screen and check if the switching of
the servers by city is now working as it was before.

How does this work?

. At the parent we have a `selectedCity` property that we update on each click on
one of the cities.
. This same value is now hooked into the child component, and each time a new value
is fed to it we run the logic to change the line items based on the parameter's
value

And so in short, we pass data from a parent to a Child so that the Child then
gets to run its own logic, effectively abstracting and separating by concern,
really cool, really simple, **simple**. _Don't forget about this type of pattern_.

==== Assignment 5: Extract the Server Component

We established at the beginning that we will have a second component extracted and
that is for one line item of the list. Further abstraction, and better approach.
Our task is to have the logic that lives in `ServerListComponent.razor` for the
line item rendering be in its own component. This of course has to leverage
Parameters.

We created at the very beginning a `ServerComponent.razor` component, at the time
it was only for testing purposes. But now we will replace its content with the
logic of an actual line item.

[source, razor]
.ServerListComponent.razor
----
<ul>
    <Virtualize Items="servers" Context="server"> <.>
        <ItemContent>
            <ServerComponent Server="@server"></ServerComponent> <.>
        </ItemContent>
        <Placeholder>
            <text>Loading...</text> <.>
        </Placeholder>
    </Virtualize>
</ul>

@code {
    [Parameter] public string? CityName { get; set; }

    private readonly string FALLBACK_CITY = "Toronto";
    private List<Server> servers = [];

    protected override async Task OnParametersSetAsync()
    {
        servers = ServersRepository.GetServersByCity(CityName ?? FALLBACK_CITY);
    }

}
----
<.> The Virtualize smart component from Blazor has extra features that we can
leverage.
<.> We can put on the rendered line item piece of code under an `<ItemContent>`
our code for each item that will be rendered smartly.
<.> And then _in theory_ we can put under `<Placeholder>` code that will be rendered
as items are fetched on the list for `Virtualize`. Alas, this doesn't seem to work....

It's on the line item component that things should be rendered as so:

[source, razor]
.ServerComponent.razor
----
@inject NavigationManager NavigationManager

@if (Server is null)
{
    return; <.>
}

<li @key="Server.Id">
    @Server.Name in @Server.City is
    <span style="color: @(Server.IsOnline ? "green" : "red")">
        @(Server.IsOnline ? "online" : "offline")
    </span>
    <a href="/Servers/edit/@Server.Id" class="btn btn-link">Edit</a>
    <EditForm
        Model="Server"
        FormName="@($"Server-{Server.Id}-form")"
        OnValidSubmit="@(() => DeleteServer(Server))">
        <button type="submit" class="btn btn-primary">
            Delete
        </button>
    </EditForm>
</li>

@code {
    [Parameter]
    public Server? Server { get; set; } <.>
    
    private void DeleteServer(Server Server) <.>
    {
        if (Server.Id <= 0)
        {
            return;
        }

        ServersRepository.DeleteServer(Server.Id);
        // Servers = ServersRepository.GetServersByCity("Toronto");
        NavigationManager.Refresh(forceReload: true);
    }
}
----
<.> Never forget good practices
<.> We will get one line item object back so that the component can then render
its respective content
<.> And we will also bring in the deletion method that used to live at the parent
level.

After this surgical extraction and componetization, this should be _easier to
maintain_. As well as adhere to best practices.

==== Assignment 5: Answer

[IMPORTANT]
====
If you place inside of a parent with interactivity configured to it a child component,
**The Child also inherits interactivity**. Hence we don't have to specify at all
the `@rendermode` property again.
====

Basically, what I implemented. So, cool. There's still that `Loading...` issue.
We are not hitting this placeholder text condition at all.

==== Extract city components

After extracting the list of servers and the line item, we are now going to apply
the same principle to the Cities side.

So, on the parent component (page) we will basically start cutting out the code
that renders the list of cities and each line item:

[source, razor]
----
<h3>Servers</h3>
<br/>
<br/>
<CityListComponent></CityListComponent> <.>
<br/>
----
<.> In the end all the logic should be abstracted behind one specific component.

The list component will also have its own child components (line items):

[source, razor]
----
<div class="container-fluid text-center">
    <div class="row w-50">
        @foreach (var city in cities)
        {
            <CityComponent City="@city" SelectedCity="@SelectedCity"></CityComponent> <.>
        }
    </div>
</div>

@code {
    private string SelectedCity { get; set; } = "Toronto"; <.>
    private List<string> cities = CitiesRepository.Cities;
}
----
<.> As you can see we are passing down from the list component (a sort of second-class
parent component), one name for the respective iteration render alongside a state
variable that keeps in check which option has been selected in the UI.

Lastly the line item component:

[source, razor]
----
<div class="col">
    <div class="@($"card{IsActive(SelectedCity, City)}")">
        <img style="max-width: 150px; max-height: 150px"
             class="card-img-top"
             src="@($"/images/{City}.png")"
             alt="Card image cap">
        <div class="card-body">
            <button type="button" class="btn btn-primary"
                    @onclick="@(() => SelectCity(City))">@City</button>
        </div>
    </div>
</div>

@code {
    [Parameter] public string SelectedCity { get; set; } = string.Empty; <.>
    [Parameter] public string City { get; set; } = string.Empty;
    
    private void SelectCity(string cityName)
    {
        SelectedCity = cityName; <.>
    }

    private static string IsActive(string currentCity, string cityName) =>
        currentCity.Equals(cityName, StringComparison.InvariantCultureIgnoreCase) ? " border-primary" : string.Empty;
}
----
<.> Notice how we have as a parameter property the `SelectedCity` property.
<.> And in here we have a callback that updates the respective property. This however
fails to meet the requirements (it breaks the previous working behavior), and that
is because we should notify the parent of a change in the selected city and then
the parent should take care of sending down to the respective childs the updated
information so that the workflow works again.

With this in mind we will tune the `SelectCity` event callback so that we can
notify the parent from the respective child so that the state is changed and the
parent replicates that info to all other children so that the UI behaves correctly.
(i.e., We have the border for the corresponding city).

==== Use EventCallback to pass info from a child to parent components

We have to solve two broken behaviors:

. The listing of respective servers per city is broken
. The highlighting of a selected city is also broken

We need to highlight that we have 2 levels of nesting here, a grandparent, parent
and child chain of component interactions, and it's within this section that we
will see how to communicate information across all these levels effectively.

**Event Callback:** This is supposed to be used by the child component of a component
tree. At the `CityComponent.razor` file we have to create an event callback to notify
the parent.

To fix the first issue we need to introduce the usage of the `EventCallback`

````
[Parameter] public EventCallback<string> SelectCityCallback { get; set; } <.>

private async Task SelectCityAsync(string city)
{
    await SelectCityCallback.InvokeAsync(city); <.>
}
````
<.> We basically stick to the concept of `Parameter` but the kicker here is this
special _Blazor_ type called `EventCallback`. In this instance it encapsulates a
delegate that takes one string parameter.
<.> We are coding the granson's component code to catch the selection event all
the way down the component tree to then invoke the passed down callback from the
parent. The parent should have this method registered under its own state, and
so the moment we run the method in a child, the parent component's code will get
executed under his own context. This trick is a really powerful concept to keep in mind.

````
<CityComponent City="@city" SelectedCity="@SelectedCity"
                           SelectCityCallback="HandleCitySelection"></CityComponent> <.>

@code {
    private void HandleCitySelection(string cityName)
    {
        SelectedCity = cityName;
    }
}
````
<.> Notice how we are passing the method as its signature, no execution of the
method. It is with this that we establish this link/resource that can be passed
from a parent to a child and the child get a way to send a signal back to him.

This fixes the highlighting for sure, since the parent gets back a signal to
update the selected city and that trickles down to the children components.

[NOTE]
====
EventCallbacks have by default only an async `InvokeAsync`, hence we delve into
async programming, however one key element here for cancellation is `CancellationToken`.
Blazor components don't seem to get this injected by default, so we have to manually
create them and then pass them down in every possible call so that we cancel async
calls if the component is destroyed and things alike. Also, this is a **Blazor
thing**. We don't have to apply the usual C# safe-guards checking for a null.
====

The way to solve the second broken behavior will be solved with _double bubbling_,
meaning from a grandson to a parent, a parent to a grandparent. (_This is a really
bad practice, but for now let's keep it this way).

.CityListComponent.razor
````
[Parameter] public EventCallback<string> SelectCityCallback { get; set; }

private async Task HandleCitySelectionAsync(string cityName)
{
    SelectedCity = cityName;

    await SelectCityCallback.InvokeAsync(SelectedCity);
}
````

.Servers.razor
````
<CityListComponent SelectCityCallback="HandleSelectedCity"></CityListComponent>

private void HandleSelectedCity(string cityName)
{
    CityName = cityName;
}
````

As you can see, it's just the same concept applied but twice, when the parent
component gets the signal from the child, it then sends a signal to the grandparent
with the same info that he got from the **child**.

==== Assignment 6: Componentize the search bar

We will work on componetizing the search bar.

. The search bar is inside `Servers.razor` we need to make it its own component.

This is a bit... weird. In the sense that the current architecture is making us
add different things that are not easier to clean later. I think a good guiding
principle for separating logic for components is:

[IMPORTANT]
====
We need an Orchestrator. Someone who takes signals from all sorts of places and
sort of makes sense of them and puts them together, of course this can lead
towards child components executing their own logic based on that idea, but we
shouldn't be making one child component _over-listen_ to events from others, he
should only care about the specific functions it provides to the greater whole.
====

And so the search bar component would be something like this:

[source, razor]
----
<div class="input-group mb-3">
    <input
        type="text" class="form-control"
        placeholder="Search Servers"
        @bind-value="SearchFilter"
        @bind-value:event="oninput">
    <button class="btn btn-outline-secondary" type="button" id="search-button" @onclick="HandleSearchAsync">Search</button>
</div>

@code {
    [Parameter] public EventCallback<string> OnSearchCallback { get; set; } <.>

    private string SearchFilter { get; set; } = string.Empty;

    private async Task HandleSearchAsync()
    {
        await OnSearchCallback.InvokeAsync(SearchFilter); <.>
    }
}
----
<.> The previous code that was in `Servers.razor` has been tuned to fit within the
idea that this is now its own component and state is leveraged through EventCallbacks
alongside `[Parameter]`.
<.> Notice how this is an async variation and the `@onclick` integrates just fine.

The code at the grandparent component will take the signal and then send back
another in the form of special flag values in the `ServerListComponent.razor`:

````
<SearchBarComponent OnSearchCallback="HandleSearch"></SearchBarComponent>

private void HandleSearch(string searchName)
{
    CityName = string.Empty;
    SearchName = searchName;
}
````
Notice how this is making the `CityName` an empty string and then `SearchName`
receiving the value from the `SearchBarComponent`.

These two parameters are being sent down, and then some logic is run so that based
on their values we run normal servers by city logic or other type of logic that
will search based on a search term:

[source, razor]
----
protected override void OnParametersSet()
{
    if (CityName?.Equals(string.Empty) ?? false)
    {
        servers = ServersRepository.SearchServers(SearchCity!);
        return;
    }

    servers = ServersRepository.GetServersByCity(CityName ?? FALLBACK_CITY);
}
----
If the `CityName` is empty, then this means that we are on the search workflow,
hence we run a different code path, otherwise, this is a default city name
workflow. We are applying else-less and return-early as good practice.

==== Assignment 6: Answer

Yeah, what I did, with two additions

- Don't forget we can check for a string with `string.IsNullOrEmpty()` and `string.
IsNullOrWhiteSpace`. That's cleaner.
- A slight bug was introduced, if we search by a filter name, and then try to switch
again to a city's server list it won't switch, and that is because we have to
reset the search filter in order for the code path to go back to the default
city name list workflow.

But yeah, the course also makes usage of this _slightly convoluted way_ of dealing
with two different workflows through the usage of extra parameters and flag values.

==== Reference a child component

Currently everything works, but there are some issues we can iron out. One of them
is the fact that when we filter out servers by city and then try and search by a
filter, the previously selected city _stays marked as selected_. That type of feedback
is confusing, so we'll try and fix that. **Also**, we should clear the search filter
if we select a city.

Since these states/behaviors belong to child components. We need a way to sort of
grab hold of them and make them update their status. Luckily parents have a way
of referencing child components and executing methods inside of them.

And so, we need to modify two places:

[source, razor]
.CityListComponent.razor
----
public void ClearSelection()
{
    SelectedCity = string.Empty;
}
----
A simple method that will be added to the component so that we can clear the
selected city and the border disappears as a result.

And in the grandparent:

[source, razor]
.Servers.razor
----
<CityListComponent @ref="CityListComponent" SelectCityCallback="HandleSelectedCity"></CityListComponent> <.>

@code {
    private CityListComponent CityListComponent = null!; <.>

    private void HandleSearch(string searchName)
    {
        CityListComponent.ClearSelection(); <.>
        CityName = string.Empty;
        SearchName = searchName;
    }
}
----
<.> The way to tie a component to a reference is with `@ref`.
<.> Of course, the reference needs to be stored in a reference variable/state
variable, hence this will be of the respective type (don't forget these components
are in the end classes). And we apply this specific syntax so that we state that the
component will not be null, the reference will be attached once the child component
gets rendered correctly.
<.> And as a simple class method call we can invoke the method we created at the
child component so that we trigger the desired logic.

And with this, the selected border will disappear since we are now sending a signal
from the parent to the child so that it updates its own state (and in turn its own
visuals).

As a mini-assignment we can now apply this same concept but now to clear the
search bar filter based on a city selection:

````
<SearchBarComponent @ref="SearchBarComponent" OnSearchCallback="HandleSearch"></SearchBarComponent>

@code {
    private SearchBarComponent SearchBarComponent = null!;

    private void HandleSelectedCity(string cityName)
    {
        SearchBarComponent.ClearSearchFilter();
        SearchName = string.Empty;
        CityName = cityName;
    }
}
````
As you can see, this is the same principle, yet with the `SearchBarComponent`
now being referenced and then having a method called from its parent.

This is yet **another way to communicate with your child component from a
parent's perspective**.

==== Reuse routable component as non-routable component

Let's learn about re-usage of components (pages).

Our requirement is pretty straightforward:

At the `ServerComponent.razor` level, we have a button that triggers a navigation
to an edit page, but we want to actually render that very same page on the same
screen of this component. You can do something like this:

[source, razor]
.Servers.razor
----
<button type="button" @onclick="@(() => EditingServer = !EditingServer)" class="btn btn-link">Edit</button> <.>

@if (EditingServer)
{
    <br/>
    <ServerManagement.Components.Pages.EditServer Id="@Server.Id"></ServerManagement.Components.Pages.EditServer> <.>
}

@code {
    private bool EditingServer { get; set; }
}
----
<.> And so we can change the button that previously just did a full routing emission
to a simply `@onclick` handler.
<.> Based on a state variable we can then choose to render a specific component,
and this as you can see is a fully qualified name, and also receives and is consumed
as any regular component.

[NOTE]
====
The course makes a highlight here stating that this code won't be used, it was simply
to demonstrate how we can put routable components inside simple components. I should
add my own take here as well, _I don't think this is recommended nor clean_, specially
the visual clutter that is added by having to fully qualify the component.
====

==== Use if statement to output data conditionally

Currently the code that we implemented already has `@if`. However, let's take a
more in-depth look at it in order to really understand the potential it holds.

_Requirement_: We want a button to turn on/off the online status of a server on
the lits.

The course applies an `@if` so that we can render a button that's green or red
in essence depending on the status. And it then takes care of turning it off or
on with a callback. Code is a bit like this:

````
<span class="me-2" style="color: @(Server.IsOnline ? "green" : "red")">
        @(Server.IsOnline ? "online" : "offline")
</span>
@if (Server.IsOnline)
{
    <button class="btn btn-outline-danger">
        Turn Off
    </button>
}
else
{
    <button class="btn btn-outline-success">
        Turn On
    </button>
}
````
My issue with this code is that it's too verbose, we can definitely abstract away
so that we don't repeat so much.

[source, razor]
====
<button class="@($"btn btn-outline-{CalculateButtonType(Server.IsOnline)}")" @onclick="UpdateServerStatus"> <.>
    @(CalculateButtonText(Server.IsOnline))
</button>

@code {
    private static string CalculateButtonType(bool isOnline) => isOnline <.>
        ? "success"
        : "danger";

    private static string CalculateButtonText(bool isOnline) => isOnline <.>
        ? "Turn Off"
        : "Turn On";

    private void UpdateServerStatus()
    {
        if (Server is null)
        {
            return;
        }

        Server.IsOnline = !Server.IsOnline;
        ServersRepository.UpdateServer(Server.Id, Server); <.>
        NavigationManager.Refresh(forceReload: true);
    }
}
====
<.> As you can see we have one method to which we feed the `isOnline` data and
based on that we calculate a part of a string that will dictate if the button looks
green or red.
<.> This method follows the same principle as the previous method, but this calculates
the label text instead of a the class name.
<.> Lastly, we have a callback on the button that due to the binary nature of booleans
can respond to the same workflow (making the code more concise). In this we just
update the component's object state, and then send that to the actual _Repository_
and trigger a manual page reload (we are going to solve this later this is bad and
can lead to bugs since we are moving away from the SPA approach).

[IMPORTANT]
====
By playing around a bit with the code and stuffs came across an interesting behavior that
I should highlight. The code with `UpdateServer(Server.Id, Server)` and `NavigationManager.Refresh`, 
**is not necessary**. The reason being that we are working with a static list that
lives in memory. All the objects that are returned to the parent and then cascaded
to the children pass those same objects by reference. If a child modifies that same
object, then the state gets replicated automatically for all the application (since
everyone is looking at the same object). So that's cool, but the moment we switch
to a database this behavior will completely break and will result in tons of bugs.
This also leads me to the hypothesis that our "edit" is actually not necessary to
have a repo method called since the screen will be manipulating the same object
by reference.
====

==== Assignment 7: Display people online

Requirement: _Display the number of people online_

We should display a random number (only if the server is online), this number
should represent the amount of people that are currently being served by the
n-th server.

Solution is again, trying to write really senior code:

[source, razor]
====
@if (Server.IsOnline)
{
    <text>@(GetRandomPeopleNumber())</text> <.>
}

@code {
    private static string GetRandomPeopleNumber()
    {
        var randomInt = new Random().Next(minValue: 1, maxValue: 15); <.>

        return $" ({randomInt})"; <.>
    }
}
====
<.> Since the assignment says that we don't care about this number at all, then
the responsibility will be offloaded to a _ephemereal_ value that is calculated on
the fly.
<.> I don't really like this because we are creating a new object with every method
call, so performance wise this could tank. For demo, and test purposes though,
that's whatever. Also, adding limits so that the numbers are somewhat "realistic".
<.> And lastly we are just calculating the text to display based on the random number
and with a space so that the UI looks _"good"_.

It's also worth of note how I chose to put all the calculation logic behind a method
so that we keep the "html" side clean/abstract, and for further analysis we can
head down to the `@code` section in order to really drill down into what we might
care, and it also helps with edition being way faster and less cumbersome since we
aren't mixing in logic and render sides of the component.

It's with this that everytime a server is "Online" we will see a number between
parenthesis that is number, yet it gives the feedback to the user of the amount
of people that are currently using it.

==== Assignment 7: Answer

Okay course put the number next to the Turn On/Off button. It also used its weird
`;nbsp` weird space. It also applied something that's "possible", and I guess it's
good to know that, this is possible so that If I find code that does this I don't
get surprised:

````
@if (Server.IsOnline)
{
    var random = new Random();
    var randomInt = random.Next();
    <text>randomInt</text>
}
````
So you can literally just write C# code right there on the template. (But I would
advise against it).

==== CSS Isolation

We are going to take this requirement:

- The search bar and input fields on the "Edit Page" are too long, we want to
control that.

If we take a traditional approach, we would literally go to `wwwroot > app.css`.
And we would start styling things there.

[NOTE]
====
By the way, this `app.css` file gets imported in the `App.razor` hence all the styles
that are available can be consumed by the components.
====

If we add a class in `app.css`:

````
.input-width {
    width: 60%;
}
````

We can easily consume the class in any of our app components:

[source, razor]
.SearchBarComponent.razor
----
<div class="input-group mb-3 input-width"> <.>
    <input
        type="text" class="form-control"
        placeholder="Search Servers"
        @bind-value="SearchFilter"
        @bind-value:event="oninput">
    <button class="btn btn-outline-secondary" type="button" id="search-button" @onclick="HandleSearchAsync">Search</button>
</div>
----
<.> In here, the parent container the _input-group_ can have this other class
applied to it and if we head down to the website, we will see how we controlled
the width of the input.

We can go and do the same for the `EditServer.razor` component.

````
<div class="col-6 input-width">
    <InputText class="form-control" @bind-Value="_server.City"></InputText>
</div>
````
As you can see we apply the class to the outer container, not the component itself.
**REMEMBER THIS TRICK**.

So, we do all of this and we effectively have things working. We fulfill the
requirement. _HOWEVER_.

In real life applications, you tend to work in teams, and many people take care
of maintaining the application and adding changes. If you use the `app.css` together,
you might run into problems in which people will perhaps repeat classes, or some
class will override what you did or just plain merge conflicts plaguing you.
There are tons of ways in which keeping styles in this global `app.css` file, will
make things harder for the whole team in the long run.

The best way to solve this problem is `CSS Isolation`. If we can isolate the scope
of the CSS class we will never have problems, we will simply have a css for the
component itself, and all class names will be specific to a component, we won't
clash or bleed styles from other places without knowing.

_How To:_ Simply create a file that has the name of the component + `css`. Example:

- GoodComponent.razor > GoodComponent.razor.css

If you applied the naming convention correctly, you should see in the IDE how
the css file gets somewhat "grouped" under the component it will hold styles for.

Inside of these files you can have any style that you want.

So we will create two new files for css:

- `EditServer.razor.css`
- `SearchBarComponent.razor.css`

And we will add specific styles there (width: 50%, width: 30% respectively). And
if we reload the website, be sure to check that they get applied correctly. _Note: _
Since hot reload is bad, you might have to start the application again so that the
styles get loaded and applied correctly.

Once you have the isolated css file, you can use it all across the component.
**YOU CANNOT USE IT IN OTHER PARTS OF THE APP EVEN IF YOU WANT TO**. This is a
protection against name clashes.

[IMPORTANT]
====
I'm not sure if this will work in prod (published mode). **BUT**. Something cool
to keep in mind is that you can hit the "Inspect" of the browser's Dev Tools, take
a look at the `<head>` of the HTML and extract the name of the css stylesheet,
in the case of this project I got: `ServerManagement.je9262pioh.styles.css`. You
can take the server's URL, and then append as the second level this stylesheet,
and in the browser you should get the whole stylesheet that the app has in plain
text for you to see, e.g., `http://localhost:5116/ServerManagement.je9262pioh.styles.css`.
====

If we were to analyze the css stylesheet, we will immediately notice how our respective
component names are on comments and then their respective styles are also in there.
If you look up for `input-width`, you will notice there are two ocurrences of it.
However they have some extra values added to it, e.g:

- .input-width[b-yj1s9dz156]
- .input-width[b-w7uhgcqi6g]

These are hashed class names (scope identifier/limiter). This is the mechanism that Blazor applies under the
hood so that we don't clash between names across the different components and their
styles, making it easy for us to simply have same class names yet not running into
issues.

If we analyze each of the respective components (with the Inspect tool), we will
easily be able to see on their rendered HTML how they will reference the identifier
and these identifiers should match respectively to the ones we see on the stylesheet.
That's how isolation works.

[IMPORTANT]
====
Why didn't we apply the class names directly on the input components themselves?
Because the identifier doesn't get applied correctly. Hence the _best practice_ is
to have a container, and then put the class name there, that way the identifier
gets applied to it, and the style takes care of re-shaping an input's width or
other things which is inside of the container.
====

==== Cascading Parameter theory

We have learned about parent components and then how we can nest components, and
how to pass info between them. Parameters, EventCallback. But what if we have
multiple levels? Deep structures (3 levels or more deep).

It would be a hassle to make these webs and webs of Parameter passed down to the
next, and then the next passing down to the next. A solution to avoid writing so
much boilerplate is: **Cascading Parameters**.

As long as you define it in a Parent Component, then any child will be able to
access it.

There are two ways of consuming these cascading parameters:

- CascadingValue (This is a component that should be declared on the template part
of the parent).
- CascadingParameter (This is used inside of the child in order to receive the value
that is being cascaded)

==== Use cascading parameter to pass values down the component tree

Let's put a requirement up and then use a cascading parameter to get to it:

- With each city that we hit to filter the list of servers, we want different
background colors.

We have our base page component, the orchestrator. And we have applied before double
bubble up of event callbacks to get from the city component to the orchestrator.
Since that component knows which is the selected city and hence runs logic to change
the list of servers, we want to now also have him affect the look of each of the
server line items. We have **3 levels** of components, but we don't want to write
a lot of code. Hence we will use `CascadingParameters`.

The first part of this setup is to leverage at the parent level the `<CascadingValue>`
component:

[source, razor]
.Servers.razor
----
<CascadingValue Name="SelectedCity" Value="@CityName"> <.>
    <ServerListComponent CityName="@CityName" SearchCity="@SearchName"></ServerListComponent>
</CascadingValue>
----
<.> As you can see we have the ability to choose what child component(s) will get
the cascading value by leveraging this specific Blazor component. All it requires
is for the name to identify the parameter at the child level, and the actual value
to bind to it.

In order to receive the cascading value, we can head down to the child component
that **needs to receive it**, we don't have to declare it in other components that
might not have any use for it.

[source, razor]
.ServerComponent.razor
----
<li style="background-color: @GetBackgroundColor()" @key="Server.Id"> <.>

@code {
    [CascadingParameter(Name = "SelectedCity")] <.>
    public string? SelectedCity { get; set; }

    private string GetBackgroundColor() <.>
    {
        return SelectedCity switch
        {
            "Toronto" => "powderblue",
            "Montreal" => "lightgray",
            "Ottawa" => "palegreen",
            "Calgary" => "pink",
            _ => "white"
        };
    }
}
----
<.> The course now applies running a method in order to calculate things, this
is of course a much _cleaner approach_.
<.> Cascading Parameters can be multiple, not just one, meaning that we should
make it a habit to identify them and retrieve them by said identifier.
<.> This function is a simple calculation function that will take in whatever
the selected city is and then spit out a specific color to style the background
of the server component.

Lastly, we also want to get rid of the default list styles, luckily bootstrap
comes with a pre-built class to override this:

````
<ul class="list-unstyled">
````

This effectively gets rid of the bullet points of the list that we had rendering
at the `ServerListComponent.razor` component.

==== Cascading parameter crossing render mode boundary

**Render Mode Boundary:** Depending on the component and application, you can extrapolate
render boundaries (SSR Boundary - Outer Boundary), (Interactive Boundary - Inner Boundary).

SSR = Pages are rendered statically (no interactivity). But we have the option
to render components with interactivity switch on. (You can leverage both approaches
depending on your use case). **BUT,** if you want to cascade a parameter from an
SSR context into an interactive component, **you cannot**.

Once you have set a specific render boundary, any other component inside of it
(e.g., A parent that has `InteractiveServer` and then nests children inside),
will inherit this same render mode.

If you want to cascade from the outside to the inside, this means that you want
to _cascade values across render mode boundaries_. And this won't work.

_IMPORTANT:_ We have setup the app to have InteractiveServer mode globally, the
course assumes we are with SSR and then opening up specific components to this
render mode. So replicating the lesson's demo is going to be hard but the takeaway
is as follows.

- We have `App.razor` and inside of there we have `<Routes>`, this component takes
care of rendering all the pages that are shown to the user based on URL. If we
were to wrap a `<CascadingValue>` around the whole content, and try to retrieve
it in say `Servers.razor` we won't be able to get it, since at that level we are
simply with `SSR`.

So, how can we "solve" this? Just make the whole application `InteractiveServer`.
The inner boundary will no longer exist, and we will be cascading across a whole
interactive render mode boundary.

[IMPORTANT]
====
There is however another way of cascading a value regardless of boundaries, and
that is by going to `Program.cs` and using the DI Container to then register the
cascading value like so: `builder.Services.AddCascadingValue("SelectedCity", sp => "Toronto")`.
====

You can however see how this limits our options for leveraging the component's state,
this would be a hard-coded value in essence. But, I guess we can make it work with
services, or some static state object, yet depending on the use case, it could be
a good option or a really bad and risky take.

==== Use templated components to create generic components

We have created a lot of reusable components. And we are in the right track, but
we are still coupling together implementations almost too much. The `CityListComponent.razor`
and `ServerListComponent.razor` only renders a list of `CityComponent.razor` and
`ServerComponent.razor` respectively. It's kinda reusable yet at the same time
we have coupled these components together.

**Templated Component:** This is a higher level component, that expands on that
"reusability" concept. If we analyze our list components, at their core, they
are solely in charge of repeating an HTML plus a bit of logic. What if we created
an abstraction that can take any sort of data and repeat it? (A _repeater component_).

With such a repeater component, we can simplify our code base. These higher level
components are referred as `Templated Components`. An in nature are way more re-usable.

- When we look at the CityList component we see how it only requires for the data
in order to run its rendering logic.
- But a templated component will need both the dataset, **and** the UI element.
(e.g., We need to know what is going to be rendered).
- The "repeater" component will need for the UI to be provided to him so that
he repeats it and stays abstract, that UI element is called **Template**, or _Placeholder_.

Let's practice this new concept with the `EditServer.razor`. If we look at the code
of the input fields:

````
<div class="row mb-3">
     <InputNumber hidden="true" @bind-Value="@_server.Id"></InputNumber>
     <div class="col-2">
         <label class="col-form-label">
             Name
         </label>
     </div>
     <div class="col-6 input-width">
         <InputText class="form-control" @bind-Value="_server.Name"></InputText>
     </div>
     <div class="col">
         <ValidationMessage For="() => _server.Name"></ValidationMessage>
     </div>
 </div>
````
We can see how this structure is repeated all across the component. It has the
potential to be abstracted since the code is verbose and can be generalized with
the help of a Templated Component.

So, how about creating a `FieldComponent.razor` templated component? It would take
a label name and then two specific regions (UI) to render the specific control and
validation control: (We are creating this under `ServerManagement.Components.Controls.Generic`)

[source, razor]
.FieldComponent.razor
----
<div class="row mb-3">
    <div class="col-2">
        <label class="col-form-label">
            @Label <.>
        </label>
    </div>
    <div class="col-6 input-width">
        @Control <.>
    </div>
    <div class="col">
        @ValidationControl
    </div>
</div>

@code {
    [Parameter] public string? Label { get; set; }

    [Parameter] public RenderFragment? Control { get; set; } <.>
    [Parameter] public RenderFragment? ValidationControl { get; set; }
}
----
<.> As you can see we will receive dynamically a parameter from upstream and that
wil lbe rendered on this specific region.
<.> As you can see we are simply placing a state variable where the upstream UI
content should be fed onto.
<.> We will then receive as `Parameter` a `RenderFragment` which is the specific
type for a template that we will later see how it's consumed.

_NOTE:_ We have to add to the `_Imports.razor` our new namespace since we created
a new folder to hold these more _Generic_ components. `@using ServerManagement.Components.Controls.Generic`.

And if we were to go to `EditServer.razor`:

[source, razor]
====
<FieldComponent Label="Name"> <.>
    <Control> <.>
        <InputText class="form-control" @bind-Value="_server.Name"></InputText>
    </Control>
    <ValidationControl> <.>
        <ValidationMessage For="() => _server.Name"></ValidationMessage> <.>
    </ValidationControl>
</FieldComponent>
====
<.> As you can see we are using the previously created component and feeding the
parameter for `Label`.
<.> And this is were things change a bit, for the `RenderFragment` parameters we
have to declare them as components themselves, so the name will correspond to the
RenderFragment's name.
<.> You can see how we feed the first and second render fragments respectively.
<.> And inside of the render fragment, the template code is the UI that will be
passed down to the _templated component_. It's worth noting that all state, all
the wired up things that worked before, _STILL WORK_. State is shared, the
templated component simply takes what's being passed down by reference.

The code in the `EditServer.razor` component will end up looking like this:

````
<EditForm Model="_server" FormName="formServer" OnValidSubmit="Submit">
    <DataAnnotationsValidator></DataAnnotationsValidator>
    <ValidationSummary></ValidationSummary>

    <InputNumber hidden="true" @bind-Value="@_server.Id"></InputNumber>
    <FieldComponent Label="Name">
        <Control>
            <InputText class="form-control" @bind-Value="_server.Name"></InputText>
        </Control>
        <ValidationControl>
            <ValidationMessage For="() => _server.Name"></ValidationMessage>
        </ValidationControl>
    </FieldComponent>

    <FieldComponent Label="City">
        <Control>
            <InputText class="form-control" @bind-Value="_server.City"></InputText>
        </Control>
        <ValidationControl>
            <ValidationMessage For="() => _server.City"></ValidationMessage>
        </ValidationControl>
    </FieldComponent>

    <FieldComponent Label="Online">
        <Control>
            <InputCheckbox class="form-check-input" @bind-Value="_server.IsOnline"></InputCheckbox>
        </Control>
    </FieldComponent>

    <br/>
    <button class="btn btn-primary" type="submit">Update</button>
    <a href="/servers" class="btn btn-primary ">Go Back</a>
</EditForm>
````
As you can see instead of all the repeated HTML code we abstract it behind the
templated component, and simply consume it and feed some bit of parameters on
top of specific HTML content to render that responds to the specific use case.
This is cleaner, and more maintainable.

The web page should work the same as before, we simply refactored.

==== Typed Templated Component

At the theory section we explained how templated components require for UI
**AND** data. But if we analyze `FieldComponent` we can easily see how we have
no actual _data_ fed onto it. So we will now code an actual _full-on templated
component_. This requires for the component to take a **type** and also some
sort of **dataset**.

[IMPORTANT]
====
This doesn't mean that the previously coded templated component is _wrong_ or
doesn't adhere to what the _best practice_ says. It's simply an intermediate type
of templated component useful to fulfill the specific requirement.
====

The example we will implement is the `Repeater`.

Under the same `Generic` folder we will create:

[source, razor]
.RepeaterComponent.razor
====
@typeparam TItem <.>

@if (Items is null || !Items.Any() || Row is null)
{
    return;
}

@Header
<Virtualize Items="Items" Context="item"> <.>
    @Row(item) <.>
</Virtualize>
@Footer

@code {
    [Parameter] public List<TItem>? Items { get; set; } <.>
    [Parameter] public RenderFragment<TItem>? Row { get; set; } <.>
    [Parameter] public RenderFragment? Header { get; set; } <.>
    [Parameter] public RenderFragment? Footer { get; set; }
}
====
<.> In order for a templated component to take some sort of type, we need to declare
it like this. At the top, and marked as generic, we want it as reusable as possible,
not tied into a specific type.
<.> As you can see we are leveraging `Virtualize` again, but we are feeding into
it the dataset.
<.> This is a specific syntax when working with typed RenderFragments, if you need
to feed into it some sort of argument, you can call it as if it where a **method**.
<.> As you can see this is a list of items (dataset) but that's also generic, (paired
up with the same type param we had at <1>).
<.> This is a specific type of `RenderFragment` it's also tied with the <1> type
parameter.
<.> And we are then adding two extra render fragments that will render a static
content as a header and footer from upstream.

Lastly, the way to consume this component will be as follows:

[source, razor]
.ServerListComponent.razor
====
<ul class="list-unstyled"> <.>
    <RepeaterComponent Items="servers"> <.>
        <Row Context="server"> <.>
            <ServerComponent Server="server"></ServerComponent> <.>
        </Row>
    </RepeaterComponent>
</ul>
====
<.> We have to wrap our `Repeater` since the `ServerComponent` is actually a list
element `<li>` and if we don't have that inside of an `<ul>` the rendered content
will break.
<.> As you can see, we are feeding the list of items through the `Items` parameter,
and because we typed the templated component it will infer the type automatically
because of this.
<.> The special typed `RenderFragment` has will receive a specific iteration value
when being rendered at the templated component level, however, because we are working
with the render fragment itself, we have to feed it the actual UI to render inside.
The UI that will render the line item that will be repeated (really confusing at
first I know). In here we are basically stating that the `Context`, which is indeed
what the Repeater will feed as each line item renders, will be under a `server`
variable name, and we then take that reference to feed onto `<ServerComponent>`
to its `Server` parameter the specific object so that it renders accordingly.

This concept is pretty abstract and high level, but in short, we are allowing for
the upstream to control what gets rendered downstream, and through clever usage
of syntax and specific structuring of the components, we are managing to achieve
an extremely abstract-generic component, that takes care of a specific function,
and leaves other components to shape whatever he's going to render within certain
parameters (always a contract in between two interacting modules).

After applying all of this, the web page should still work the same _we have only
applied refactoring_.

==== Use html table in our RepeaterComponent

The current server list is rendered with a list (<ul>), however we should aim
at using a **table**, for better styling and support. This also lets us change to
`QuickGrid` which is a feature that comes bundled with .NET 8.

Code will have to change in two places:

[source, razor]
.ServerListComponent.razor
====
<table class="table table-striped"> <.>
    <RepeaterComponent Items="servers">
        <Header> <.>
            <thead>
            <tr>
                <th>
                    Name
                </th>
                <th>
                    City
                </th>
                <th>
                    Status
                </th>
                <th>
                    People Online
                </th>
                <th></th> <.>
                <th></th>
            </tr>
            </thead>
        </Header>
        <Row Context="server"> <.>
            <ServerComponent Server="server"></ServerComponent>
        </Row>
    </RepeaterComponent>
</table>
====
<.> In order to style the table with Bootstrap's "nice-looking" defaults, you can
apply these two classes.
<.> We added the specific `@Header` RenderFragment previously and in here it integrates
seamlessly into an HTML table structure.
<.> This is just HTML table syntax, if we want a header with labels we would add
that info under a `<thead>, and then under one sole row `<tr>`, we would then add
all the entries we want with `<th>`. The last two _"empty"_ columns are to house
the buttons of the line items.
<.> And under the `Row` RenderFragment we are sending in the code that will repeat
per line item the rendered `ServerComponent`

[source, razor]
.ServerComponent.razor
====
<tr style="background-color: @GetBackgroundColor()" @key="Server.Id"> <.>
    <td> <.>
        @Server.Name
    </td>
    <td>
        @Server.City
    </td>
    <td style="color: @(Server.IsOnline ? "green" : "red")"> <.>
        @(Server.IsOnline ? "online" : "offline")
    </td>
    <td>
        @if (Server.IsOnline)
        {
            <text>@(GetRandomPeopleNumber())</text>
        }
        else
        {
            <text>N/A</text> <.>
        }
    </td>
    <td>
        <button class="@($"ms-2 btn btn-outline-{CalculateButtonType(Server.IsOnline)}")" @onclick="UpdateServerStatus"> <.>
            @(CalculateButtonText(Server.IsOnline))
        </button>
        <a href="/Servers/edit/@Server.Id" class="btn btn-outline-primary">Edit</a>
    </td>
    <td>
        <EditForm
            style="@($"background-color: {GetBackgroundColor()}")" <.>
            Model="Server"
            FormName="@($"Server-{Server.Id}-form")"
            OnValidSubmit="@(() => DeleteServer(Server))">
            <button type="submit" class="btn btn-primary">
                Delete
            </button>
        </EditForm>
    </td>
</tr>
====
<.> Since we are switching to an HTML table, our `ServerComponent.razor` will now
in essence will render a full HTML table row. Hence we are now under a containing
`<tr>`
<.> If we want to add the differen columns for this row, we use `<td>` (HTML basics)
<.> Each column can be styled as you see fit (just use `style=`)
<.> Due to the nature of our table structure, we had to add this fallback piece of
logic. Otherwise we wouldn't get anything rendered into this column that will
become static.
<.> We are housing these buttons on their own columns, notice how we can simply
wrap them and they will be on the same row and fit in automatically.
<.> This is really **IMPORTANT**. The course doesn't seem to show a problem here,
but on this end the form messed up with styling, the background didn't seem to get
applied, and so we had to manually pass onto the component the style to align with
the table's background color. This syntax also is very important, if you don't pass
a explicit syntax here to render this whole string, Blazor will not compile.

[NOTE]
====
When it comes to marrying both HTML and the Blazor render mechanism, I think it's
key understanding how these things work at a base level. As base concepts. Otherwise
you will never truly understand what's going on. In the end, the framework is a just
a mechanism to auto-generate HTML, since that's what the browser understands. So
all the syntax is simply clever engineering to make the framework generate code
on the other end (repeated line items, tables, etc).
====

After all these changes, then everything should be working as before, but looking
even better since we refactored it to use a table.

==== Using QuickGrid to display our servers

This is a component that Microsoft offers developers to quickly and efficiently
display data in a tabular format.

Let's learn some basics of how to use it.

- _Install a NuGet package_
- Search for the package that's made by Microsoft (Microsoft.AspNetCore.Components.QuickGrid)
    - You can even integrate QuickGrid with EF Core, but we won't go there for now
- Install the package

In order to use it, we won't modify our `ServerListComponent.razor` file, but create
a separate `QuickGridDemo.razor`. This will be under `Controls`.

[IMPORTANT]
====
Be careful about the version of the Nuget that you install. I installed the "latest"
but this was a preview for .NET 10. I was in a .NET 9 project, with the previous installed
package the import of `QuickGrid` won't work at all. So be sure to line up the versions
correctly.
====

This is how we would initially attempt to use it:

[source, razor]
====
@page "/quickgrid"
@using Microsoft.AspNetCore.Components.QuickGrid

<h3>QuickGrid Demo</h3>
<br/>

@if (_servers is null)
{
    return;
}

<QuickGrid Items="_servers.AsQueryable()"></QuickGrid> <.>

@code {
    private List<Server>? _servers = ServersRepository.GetServers();
}
====
<.> A small comment here, we need our dataset to bet of `IQueryable` type.

This isn't as simple though, nothing will render like this. In addition to specifying
the component we need to specify each of the columns. The easiest way to render
them is by using the `<PropertyColumn>` render fragment and `<PropertyTemplate>`.

This is how the final template would look like:

[source, razor]
----
<QuickGrid Items="_servers.AsQueryable()">
    <PropertyColumn Property="s => s.Name"></PropertyColumn> <.>
    <PropertyColumn Property="s => s.City"></PropertyColumn>
    <TemplateColumn Title="Status"> <.>
        <div style="color: @(context.IsOnline ? "green" : "red")">
            @(context.IsOnline ? "online" : "offline") <.>
        </div>
    </TemplateColumn>
    <TemplateColumn Title="People Online">
        @if (context.IsOnline)
        {
            <text>@(GetRandomPeopleNumber())</text>
        }
        else
        {
            <text>N/A</text>
        }
    </TemplateColumn>
    <TemplateColumn>
        <button class="@($"ms-2 btn btn-outline-{CalculateButtonType(context.IsOnline)}")"
                @onclick="() => context.IsOnline = !context.IsOnline"> <.>
            @(CalculateButtonText(context.IsOnline))
        </button>
    </TemplateColumn>
    <TemplateColumn>
        <a href="/Servers/edit/@context.Id" class="btn btn-outline-primary">Edit</a>
    </TemplateColumn>
    <TemplateColumn>
        <ChildContent Context="server"> <.>
            <EditForm
                style="@("background-color: white")"
                Model="server"
                FormName="@($"Server-{server.Id}-form")"
                OnValidSubmit="@(() => DeleteServer(server))">
                <button type="submit" class="btn btn-primary">
                    Delete
                </button>
            </EditForm>
        </ChildContent>
    </TemplateColumn>
</QuickGrid>
----
<.> `PropertyColumn` is pretty straightforward, **_if you have to just display the
specific property's content, just use this syntax and point towards the specific
property you want rendered_**
<.> In case this isn't just a simple display of a value, and you want to insert
more complex content leverage `TemplateColumn`, in here you can insert any HTML
that you want and have control of the cell.
<.> By default, `QuickGrid` has a `context` property that implicitly is declared
and we can access from any of the column child components, hence in here we can
access the line item's `IsOnline` and use it for rendering logic.
<.> In here I had to rewrite the function since in the `ServerComponent` use-case
I simply sent a callback implicitly but that's because the setup accounts for a
property called `Server`, in here we are leveraging the lambda in order to access
the line item's object under the `context` name.
<.> A really important thing here is that `EditForm` also loads automatically a
`context` object, (but we can rename it with the `Context=Something` syntax). Still,
for these cases in which variable names might clash, we have `ChildContent` as a
component that can wrap the nested component with its own context, and in that
wrapper we can rename the parent's context to something else. In this instance
we renamed it to `server` and inside of the nested `EditForm` we can access the
parent context just fine by calling said `server` renamed context. (Clever I should
say).

This is but an option, you can use it, or not. Up to you and the requirements really.

Now, the course makes a note that Turn On/Off doesn't work, but that's because its
setup is following the "SSR by default, component's override that" normal setup.
We changed it to follow "everything is interactiveserver", hence for us the interactivity
bit of behavior works out the box. So to fix it you simply add at the beginning
`@rendermode InteractiveServer`.

==== QuickGrid Sorting and Pagination

We will now leverage some other features that are ready for consumption on
QuickGrid. If we want a column to be sortable, you can just add a property like
so:

````
<PropertyColumn Property="s => s.City" Sortable="true"></PropertyColumn>
````

This is cool, since by simply adding this property/flag, we can now head down to
the column's header, and click on it, and it will automatically sort the content
ASC or DESC. Any other columns will not have the clickable header enabled, you
have to mark them yourself.

What if you want to also make a `TemplateColumn` sortable? If you add the same
property by itself it won't work, Blazor will _try_ to sort it, but it won't really
work. So how do you configure it to work?

First of all, understand that a `TemplateColumn` doesn't even know what column you
are trying to map to, it's a free canvas basically. However there's a different
property `SortBy` it takes a specific type of object however:

````
<TemplateColumn Title="Status" SortBy="GridSort<Server>.ByAscending(s => s.IsOnline)">
````
As you can see you feed to the property this specific `GridSort` object, and you
have to specify if by default it will start ASC or DESC, and inside of the method's
parameter you feed a lambda to point to the actual property that will be taken into
account for the sorting logic.

What about Pagination? QuickGrid helps with us not having to implement pagination
from zero.

In order to leverage it you need first a `PaginationState` state variable:

````
private PaginationState _paginationState = new()
{
    ItemsPerPage = 5,
};
````

And you can then feed it into both `<QuickGrid>` and also a `<Paginator>` component
that comes bundled with the Nuget package we installed:

````
<QuickGrid Items="_servers.AsQueryable()" Pagination="_paginationState">

<Paginator State="_paginationState"></Paginator>
````

And with this, based on the object configuration you will get controls and pagination
logic straight out the box. (Pretty cool)

==== Use arbitrary attributes to provide flexibility

Reusable components could be higher level components that we create for others
to consume. In such scenarios, we might want to provide the consumers as much
flexibility as possible.

All the components we created in this section are reusable, yet they suffer from
the same issue, styling is locked in a way, the user can't really style them as
he would want.

Let's take the `SearchBarComponent.razor` component as an example, it has specific
styles locked into it. If the consumer where to try and add to the component something
like `style="width: 1000px"`. Then nothing would happen, he won't be able to control
the look and feel as much as he tries. (We wouldn't get a compilation error, however
when trying to render it such syntax would break the application).

This might prop us to just add a parameter with `style` as a name. But this is a
bit short-sigthed. If the user wants to provide other extra attributes that might
be "default" we can't be adding more and more parameters to cover all possible cases,
that's verbose, and not maintainable. (width, height, data-my-attribute).

Luckily, Blazor has a mechanism to sort of enable a component to take in **any**
sort of attribute and not break the render. These type of parameters are called
**arbitrary attributes**.

This is how you enable them:

````
<div class="input-group mb-3 input-width" @attributes="OtherAttributes">

@code {
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? OtherAttributes { get; set; }
}
````
Basically, yes add another parameter but with the specific `CaptureUnmatchedValues`
flag set to `true`. It should be a `Dictionary<string, object?>` type. And then
you can consume it on any sort of HTML you want by attaching it to a `@attributes`
directive.

After setting the reusable component with this, any consumer of the component can
now add default styles, data attributes without issue. This is **really powerful**,
just as an example, if we were to go to `Servers.razor`:

````
<SearchBarComponent @ref="SearchBarComponent" OnSearchCallback="HandleSearch" style="width: 1000px"
                    data-my-attribute="my data"></SearchBarComponent>
````
This code will work, and we will get to style the width of the searchbar as we
see fit, and we will have attached custom attributes effectively.

This pattern is useful and makes sense for really high level components, (i.e.,
in our case that would be the _Generic_ components such as `FieldComponent.razor`,
`RepeaterComponent.razor`)

It will be up to the developer to architect a component and add this special dictionary
in a place that makes sense to have it. (So be mindful of the requirements and how
you are designing both the high and low level components, on top of consumers).

=== Course Project (Part 2): Componetize our To-Do List App

==== Componetize the List of items

We will continue with the `To-do` list. Since we now learned how to break apart
into components we want to apply the same to our "one component for all" approach.

So my choice is as follows:

- ToDoListComponent.razor = Will have the button to add an item inside of it.
- ToDoListItemComponent.razor

[IMPORTANT]
====
Course _lieeeeeeed_. `@key` is useful to put in `Virtualize` and when bugs show up,
this might be the solution to them. As a rule of thumb: _If rows contain any
interactive inputs or stateful components, add `@key`. If rows are purely static
text, you can omit it for a bit more reuse/performance. Now the reason, our code
might still be working with the smart DOM patch, is more than likely because our `<li>`
elements have the actual `@key` attribute to them. It's not as if `Virtualize`
magically figures out what is being repeated and attaches it automatically.
====

Sources:

- https://learn.microsoft.com/en-us/aspnet/core/blazor/components/virtualization?view=aspnetcore-9.0[MS Docs]
- https://learn.microsoft.com/en-us/aspnet/core/blazor/components/element-component-model-relationships?view=aspnetcore-9.0[MS Docs 2]
- https://blazor-university.com/components/render-trees/optimising-using-key[Blazor University]
- https://www.meziantou.net/optimizing-blazor-performance-using-the-key-directive.htm[Blog]
- https://stackoverflow.com/questions/72581334/in-blazor-when-using-the-virtualize-component-with-multiple-items-per-row-is-th[Stack Overflow]

This is how our components would end up:

[source, razor]
.TodoList.razor
====
@page "/to-do"

@if (!_todoItems.Any())
{
    return;
}

<TodoListComponent TodoItems="_todoItems"></TodoListComponent> <.>

@code {
    private List<TodoItem> _todoItems = TodoItemsRepository.GetItems().ToList();
}
====
<.> As you can see, cleaner code, all abstracted under a list component.

[source, razor]
.TodoListComponent.razor
====
@inject NavigationManager NavigationManager <.>

<button @onclick="AddTodo" class="btn btn-primary mb-3">
    Add Task
</button>

<ul class="list-unstyled"> <.>
    <Virtualize Items="TodoItems" Context="todoItem">
        <ItemContent> <.>
            <TodoListItemComponent @key="todoItem.Id" Item="todoItem"></TodoListItemComponent> <.>
        </ItemContent>
    </Virtualize>
</ul>

@code {
    [Parameter] public List<TodoItem>? TodoItems { get; set; }

    private void AddTodo()
    {
        TodoItemsRepository.Add(new TodoItem
        {
            FreshAdd = true,
        });
        NavigationManager.Refresh(forceReload: true); <.>
    }

}
====
<.> We have to use the awful "reload the whole page to see the new UI with the
new hydrated data". Still don't know how to get around that.
<.> Instead of using a manual css class, using the bootstrap one.
<.> Don't forget to put the content that will be _repeated_ behind an `<ItemContent>`
tag.
<.> And again, we make the code much cleaner by abstracting all the row info behind
a second component.
<.> And yeah, after we have updated the repository's state, in order to see the
UI replicate this, we will have to trigger a manual webpage reload.

[source, razor]
.TodoListItemComponent.razor
====
@if (Item is null) <.>
{
    return;
}

<li @key="Item.Id"> <.>
    <div class="input-group mb-3">
        <div class="input-group-text">
            <input @bind-value="Item.IsComplete" class="form-check-input mt-0" type="checkbox"
                   aria-label="Checkbox for following text input">
        </div>
        <input @bind-value="Item.Text" disabled="@Item.IsComplete"
               placeholder="@(CalculatePlaceholder(Item.FreshAdd))" type="text"
               class="form-control" aria-label="Text input with checkbox">
        @if (Item.IsComplete)
        {
            <div class="p-2">
                <text>
                    Completed Date: @($"{Item.CompletedDate:D}")
                </text>
            </div>
        }
    </div>
</li>

@code {
    [Parameter] public TodoItem? Item { get; set; } <.>

    private readonly string FRESH_ADD = "What do you want to do?";

    private string CalculatePlaceholder(bool freshAdd) => freshAdd
        ? FRESH_ADD
        : string.Empty;

}
====
<.> Always check for the "impossible", ALWAYS.
<.> Nothing else changes in the component, it literally becomes a process of wiring
things up just about good enough and transferring methods and state variables.

And just like that, we have abstracted the previously monolithic code into two
separate components, wired them up, and in essence kept the same behavior as before,
yet on the backend gaining a lot in maintainability, extensibility and overall
easier reading for developers.

_Reconciling with course_

_(Oh, I jumped the gun, already did everything, this is just for the list)_

- Names are different. That's whatever.
- I chose `Virtualize` course sticks to using `@foreach`
- Course reminded me to **always check for the impossible**. So on the `TodoListComponent.razor`
we should check if the provided dataset is not null or if it has items.

==== Componetize the to do item

_Reconciling with course_

- Course mentions how sometimes intellisense and color coding doesn't work on a
Blazor component, closing the file and re-opening it might fix it.
- The course doesn't use `NavigationManager` and apparently the view updates
correctly with the new added element even if it goes all the way to the child
triggering the dataset change (weird)

The Add Button, is arguably someting that could go in the _Page_ or in the _List
Component_. My reasoning is that the list should only care about rendering the list
of elements, hence the Page is in charge of triggering the respective dataset
change. However, because of the separation into components, re-renders of the UI
based on dataset change gets iffy, _weird_. Hence we are doing the whole `forceReload()``,
**WHICH IS BAD**. We need a better approach.

[NOTE]
====
Found a mini-bug, and that's because on checkboxes, we should add another property:
`checked="@Item.IsComplete"`, (this is at `TodoListItemComponent.razor`), otherwise
once we reload the page, or navigate away and back, we will see the item marked
as complete but the checkbox won't be checked.
====

=== Component Lifecycle Deep-Dive

==== Component Lifecycle Overview

We will start from basic concepts in order to explain Blazor.

In a traditional web application the user interacts with the browser, that gets sent
to the web app, the web app processes the request, responds and the user sees newly
rendered content. (Traditional approach, we know this).

The lifecycle of things in this type of app is simple:

- We send a request
- Wait for a response
- When we get the response we then process it however we see fit, we perhaps transform
the data, _react_ to the response.

That's the extent of the events and lifecycle stages.

However **Blazor**, whether it's `InteractiveServer` or `InteractiveWebAssembly`.
All the page info an component info is held in the server, the browser respectively.

Regardless of where the component's are living and breathing, there's a lifespan
to all of them.

No matter, what component, where or how it is used, **IT WILL ALWAYS GO THROUGH
THESE STAGES:**

. Construct = Component goes _into the memory_.
. Initialize
. Receive Parameter = Can receive from a URL, from a parent component.
. Render = After the component has all the necessary inputs it will then start
rendering.
. Destruct = When the component is about to be put out of memory, then it will
Descruct.

Because we have these 5 stages, the developer might find useful to hook into each
one of them depending on the requirement.

Blazor offers us **event hooks**, in order to put ourselves in-between these stages:

- Construct
    - Instantiation = This is when the class is constructed.
    - SetParameterAsync = Name might be confusing, but this hook runs **BEFORE
    SETTING PARAMETERS**
- Initialize
    - OnInitialized(Async) = Initialize the component
- Receive Parameter
    - OnParametersSet(Async) = When we receive the parameter values, and we can
    leverage them.
- Render
    - OnAfterRender(Async)
    - Dispose = In here you might want to dispose of resources you created yourself.
    (Watch out for memory leaks).
- Destruct

[NOTE]
====
A concept not widely talked about online is **Instantiation**. A good way to separate
concepts for later use, is that whenever we declare a direct assignment of a value
to a state value e.g., `private string LABEL = "Label 1";`. In a component, it's
at **Instantiation** that the value gets hydrated.
====

**Note 2:** Instantiation and Dispose are not mentioned in the MS Docs, but they
are still there, they exist and you can leverage them. **BELIEVE THAT**.

A key concept to also keep in mind is that `Receive Parameter` and `Render` will
be constantly be triggered. Each user interaction will inevitably lead to a change
in a parameter, and after that change is detected the component will re-render.

Because this _repeatability_ of these two lifecycle events is so often, another subset
of hooks is also available to us:

- ShouldRender = Hook that runs before parameters are set, it will simply control
if the specific component should trigger a re-render or not.
- SetParameterAsync
-- Receive Parameter
- OnParametersSetAsync
-- Render
- OnAfterRenderAsync

This specific lifecycle is **further rendering**, whereas the first schema that
we presented is the **first time rendering**. It makes sense, we wouldn't want
to start building the component again from scratch, right? It will be allocated
in memory once and it will then be re-rendered based on user actions.

_Final thing:_ Most of the hooks have their `Sync` and `Async` versions. Depending
on your use case you should leverage the one that makes more sense. _Note:_ If
you tap into both versions, the **non-async version is triggered before**.

[NOTE]
====
It's important to understand these events, hooks, and their order since you might
easily run into issues when trying to consume data that might not be available **yet**.
Or other things alike, hence, take time to learn, interiorize these concepts. Watch out
specially with _async_ methods, they are sometimes unpredictable (order-wise).
====

==== Component Lifecycle events sequence Part 1

We are going to demo our `CityListComponent.razor` in order to put to the test all
the theory we saw.

We tried to cover all 6 main hooks:

- Construct
    - Instantiation = This is when the class is constructed.
    - SetParameterAsync = Name might be confusing, but this hook runs **BEFORE
    SETTING PARAMETERS**
- Initialize
    - OnInitialized(Async) = Initialize the component
- Receive Parameter
    - OnParametersSet(Async) = When we receive the parameter values, and we can
    leverage them.
- Render
    - OnAfterRender(Async)
    - Dispose = In here you might want to dispose of resources you created yourself.
    (Watch out for memory leaks).
- Destruct

- `Instantiation` is not a hook that we can hook into **BUT IT STILL HAPPENS**.
- We stated all the **sync** variations in the component
- For `Dispose` we have to go into the top of the blazor component and state
`@implements IDisposable`, so that we can later add a working method under
`public void Dispose()`. We do this, since it's not a built-in lifecycle event hook.
- `SetParametersAsync` is one hook that only has an async version, so you work
with `Task` there.

This is a model of how we are declaring the hooks and how we are going to print
some message for debugging and demo purposes:

````
protected override void OnInitialized()
{
    var guid = Guid.NewGuid();
    Console.WriteLine($"CityListComponent: {nameof(OnInitialized)} : {guid}");
}
````
In the case of things such as `ShouldRender` we return `true` directly, and for
`SetParametersAsync` we are actually returning a `Task.CompletedTask`.

This part of the demo is a bit tricky to reproduce since we are working with a
different setup, we have configured the server to be directly under InteractiveServer
and so trying to put it back to SSR actually breaks the app. Even though we saw
how we can mark places as just SSR with the `@attribute [ExcludeFromInteractiveRouting]`
by trying to do it at `Servers.razor` (because we have to mark **pages** with this).
Then the list no longer rendered, and what the course says is that in SSR we
execute 4 hooks:

- SetParametersSetAsync
- OnInitialized
- OnParametersSet
- Dispose

In practice, I only saw:

- SetParametersAsync
- Dispose

[IMPORTANT]
====
COURSE LIEEEEEED AGAINNNN. The reason I wasn't seeing the other lifecycle hook
messages is: `SetParametersAsync` is really important to call its **base implementation**
====

[source, razor]
====
public override async Task SetParametersAsync(ParameterView parameters)
{
    var guid = Guid.NewGuid();
    Console.WriteLine($"CityListComponent: {nameof(SetParametersAsync)} : {guid}");

    // Let the framework apply parameters and run the normal lifecycle
    await base.SetParametersAsync(parameters); <.>
}
====
<.> The base implementation applies the incoming parameters to the component and
takes care of calling the other lifecycle hooks. Without this call, we won't be actually
calling the other hooks correctly, hence we couldn't see _any of them_.

[NOTE]
====
The course does have a point of not needing to call base implementations but this
applies mostly to two hooks: `OnInitialized`, `OnParametersSet`. Any other hook
should have its base implementation called just to be safe. Only these two have
empty bases.
====

With this **_fix_**, we can now go back to explaining the course content:

With Server Interactivity On:

````
CityListComponent: SetParametersAsync : e48fccbb-013b-4d2a-956c-bc1e8e7e6f45
CityListComponent: OnInitialized : cf3cc6f8-37c0-431e-860d-c00be6663a2e
CityListComponent: OnParametersSet : 59b868f3-154a-4366-beae-bc8339fe7d84
CityListComponent: Dispose : e07a40eb-299f-43fe-9527-dd02dea9cb93
CityListComponent: SetParametersAsync : 57ac1dda-9afe-4300-b916-86a11bb37046
CityListComponent: OnInitialized : 82f012ac-2d29-4e77-95b2-a5bfd132baa6
CityListComponent: OnParametersSet : 00969e4f-a583-4787-bad4-4c94b07e897e
CityListComponent: OnAfterRender : 0dce5ed6-0913-4be2-ada9-0792a925a771
````

A lot of events will be triggered when interactivity is on. We have to separate
these logs in two sets:

````
CityListComponent: SetParametersAsync : e48fccbb-013b-4d2a-956c-bc1e8e7e6f45
CityListComponent: OnInitialized : cf3cc6f8-37c0-431e-860d-c00be6663a2e
CityListComponent: OnParametersSet : 59b868f3-154a-4366-beae-bc8339fe7d84
CityListComponent: Dispose : e07a40eb-299f-43fe-9527-dd02dea9cb93
````

````
CityListComponent: SetParametersAsync : 57ac1dda-9afe-4300-b916-86a11bb37046
CityListComponent: OnInitialized : 82f012ac-2d29-4e77-95b2-a5bfd132baa6
CityListComponent: OnParametersSet : 00969e4f-a583-4787-bad4-4c94b07e897e
CityListComponent: OnAfterRender : 0dce5ed6-0913-4be2-ada9-0792a925a771
````

Let's review the Server Interactivity workflow:

The browser sends the first request to the server. The server receives that and
tries to construct a page, it sends that page back to the browser, and **only after
that**, the SignalR channel is established. All the way up until that point the
events of the first _set_ are run. (These are the same events as if it were for
SSR). Since the memory is disposed there, we have to reconstruct the component
through the SignalR channel, hence we see how the _second set_ of hooks makes
sense. We are _re-initializing_ the component, and now hydrating through SignalR.

We don't see `Dispose` because the component is still held in memory, we haven't
gotten rid of it just yet.

If we were to move away from the page that renders the component, we will see
how the `Dispose` hook is called. Meaning that the component was unmounted successfully.
Since we are going to a new page (such as the weather page), and if this page is
SSR, due to crossing render mode boundary then our Interactive components will
go out of memory automatically. (But it also applies if we simply move away from
the page that requires for the component to be alive).

_Difference:_

Because of our setup the course shows that going back to `Servers.razor` actually
triggers all the lifecycles as if it was the first time. But in our case it will
only trigger the `second set` of hooks. That is because we are by default with
`InteractiveServer`, since the SignalR channel is already established we don't
need for the initial handshake. And now we simply reconstruct components in memory
and that's the second set of hook executions.

[NOTE]
====
We don't have a hook to show how `Initialize` should run before all other hooks.
But we can run the app with Debug and set a breakpoint in a state variable that
is initialized directly. We can then add breakpoints for all other hooks and see
how before any of the other hooks' breakpoint hits, the state variable line gets
hit first.
====

_Small Note:_ But I also noticed how `SetParametersAsync` gets executed sometimes
before. (Maybe async magic?). In any case, it's true, the state variable line
does get called before any of the other hooks. **proving the theory**.

[NOTE]
====
We haven't seen `ShouldRender()` getting called yet. This is easy to trigger,
just select one of the cities from the city list, and then this hook will be
triggered before any other (even before `SetParametersAsync`). We no longer see
`OnInitialized`, and that's because **the component is already in memory**. At this
point we are in the second stage of the lifecycle, the loop of `Receive Parameter >
Render`. Endlessly, always following the same order.
====

This second stage will comprise of these hooks in this order (most of the time):

````
CityListComponent: ShouldRender : 40780d80-66d6-4330-b4fc-f393b5389129
CityListComponent: SetParametersAsync : 6cdb5a0b-3fdf-4951-8b47-9901f3a44766
CityListComponent: OnParametersSet : 94cf4ddf-b72a-44b8-b13d-a6161842f7de
CityListComponent: OnAfterRender : 54b5d296-7f9d-44da-a206-9133444f59a4
````

Apparently (according to docs), `ShouldRender` should run before _EVERYTHING_, and
then after `OnParametersSetAsync` but that's not the case in practice. Due to this
fact **we have to be really careful on how we use the hook and understand if we are
at a stage that makes sense to leverage it**. The course implies this might be a bug
due to the contradiction with documentation and that it should be _fixed_. Well,
it hasn't been fixed. So, just know that.

==== Component Lifecycle events sequence Part 2

We have demonstrated the sequence of events but only for **one component**.
What will be the event sequence if this component has children?

First of all, let's apply all the hook logs that we had at `CityListComponent.razor` 
but on `CityComponent.razor`. Secondly, let's comment out all citie names of the
list of cities except `Toronto` that way we don't see as many logs. And lastly,
at `CityComponent.razor`, we will comment out the invoking of the `SelectCityCallback`
callback. This affects the hook lifecycle, and so under these conditions this is a
trace we will see:

````
// <- First Set ->
CityListComponent: SetParametersAsync : 990c2e95-7930-4ddc-baf7-1417783d389f
CityListComponent: OnInitialized : f441975f-41ae-421c-a094-7b8b8052a020
CityListComponent: OnParametersSet : e7ea7120-311a-446e-ab97-e5b03b035f32
CityComponent: SetParametersAsync : 24a912ac-768d-4e97-afb7-73cc9f399123
CityComponent: OnInitialized : fc81951b-c87d-4b78-a964-5d41f3c311c5
CityComponent: OnParametersSet : af98858c-cceb-4542-82f7-4d776d659ef1
CityListComponent: Dispose : e87685c6-f6b8-416c-b0e4-66ef2c4d5c84
CityComponent: Dispose : 289a75ef-4042-4b60-b872-b75542d93838
// <- Second Set ->
CityListComponent: SetParametersAsync : 30e5b774-85c5-4580-b270-25598dd502ed
CityListComponent: OnInitialized : 5bc993f0-00a7-4a7c-b1c0-d83ef896f8b0
CityListComponent: OnParametersSet : 6bded79d-48bd-4ed9-b2fc-a11d870b02a6
CityComponent: SetParametersAsync : d8e608b9-07c4-4d76-b453-7c9b2e366aa3
CityComponent: OnInitialized : 9f1f69dd-e4be-4736-854b-766dc85d5d5f
CityComponent: OnParametersSet : 82eca730-582f-45ba-8258-8f3326ef5f46
CityListComponent: OnAfterRender : 3d6ba6fb-a053-4226-92e6-d20a4012035e
CityComponent: OnAfterRender : fb7afe2f-8eb7-4c47-97f7-2ddcd1c26448
````
We also have the whole first set and second set of hook executions. We will ignore
the first set since we **know** this is just the handshake for establishing the
SignalR channel.

Focusing on the second set: The parent component's hooks are triggered first,
right after it the child component comes into play. The order will be usually
the same. We will run all hooks in order of `parent > child`, and after they render,
we will then trace back per hierarchy the `OnAfterRender`.

If we click on the city name button, we will see two hooks that are executed:

````
CityComponent: ShouldRender : 2b5586ba-9334-498b-aa70-00c5dc4d58b0
CityComponent: OnAfterRender : 92018463-be90-46d7-a948-788de583fcd4
````

The parent component did not re-render. Why? Because we have nothing interacting
with the parent component, because we are just living at the child component and
it's consuming that component's context, parent will not be told to re-render.

What happens if we now uncomment the callback for the parent. If we do that,
and now try to click on the city button:

````
CityListComponent: ShouldRender : dffd5154-a759-4190-ab64-ca48f8991f7f
CityComponent: ShouldRender : 167e6a30-dcdc-4402-b6c2-74191eefef0c
CityListComponent: SetParametersAsync : b939c628-bf44-4446-9200-947398da666b
CityListComponent: OnParametersSet : 3a7cd79b-40d6-4d3d-8d14-bf8441920cee
CityComponent: SetParametersAsync : 6ee205cb-0c01-48bc-95fb-bdb5bdd6c983
CityComponent: OnParametersSet : 8a9c29d3-88cb-436a-852f-ccb5ba07d741
CityListComponent: OnAfterRender : 7cdc7d9a-af59-4f6b-8f63-2ebc4361afd3
CityComponent: OnAfterRender : 96d6a04f-3e94-4358-b5b3-be4c545e8902
````
As you can see, that if we have interactions with the parent, we will trigger a
full re-render cycle, that is because parameters are marked as **changed**. With
the added `ShouldRender` that comes in when these components are already in memory.
As you can see we follow the usual order (and most of the time it's a rule we can
rely on). But the main take away here is that `Parent > Child` is the order in which
the component tree is rendered in Blazor. Interactions that bleed from children
to parents and vice-versa will trigger a full re-render.

- Parent component renders first
- Child renders after

_Note:_ With async methods, executions should follow the same idea, however the
conclussion of the method's logic might be different. Also keep that in mind.

==== The problem of component initialization

With SSR, the sequence of lifecycle events will always be predictable. However
with Server Interactivity this is not the same. **By default**, pre-rendering
is turned on. When a component is initially rendered, it is done so **twice**.
We have a "pre-render" and a second render when the SignalR channel has been
established. Most of the events are run twice, except the `OnAfterRender`, so
it's on us to come up with a solution for Server Interactivity.

The easiest solution is to just _turn off pre-rendering_. But the reason it's
turned on by default is **because rendering is faster that way**. The server prepares
the view and sends that to the client, you don't have to wait for a SignalR
establishment and get the view as quickly as possible directly from the server.
Hence we might not want to turn off pre-render.

The problem we are trying to solve here is **_we don't want to run initialization
code twice_**.

The problem accentuates further if we analyze at the code we wrote for `CityListComponent.razor`.

_Note:_ Okay, I don't technically have that problem, because I didn't code the
city retrieval on a lifecylce hook, the course did, it populates the city list
at `OnParametersSet`.

Anyway, if you were to put population logic on one of the lifecycle hooks, we would
be executing that logic twice, (and that's not a smart allocation of resources).

The hook that will save our lifes here is `OnAfterRender`, it has a specific
parameter called `firstRender`. This flag is key to us leveraging optimizations such
as running population logic only once.

[source, razor]
.CityListComponent.razor
----
protected override void OnAfterRender(bool firstRender)
{
    base.OnAfterRender(firstRender);

    if (firstRender) <.>
    {
        if (string.IsNullOrWhiteSpace(ServerFilter))
        {
            servers = ServersRepository.GetServersByCity(CityName ?? "Toronto")
        }
        else
        {
            servers = ServersRepository.SearchServers(SearchFilter)
        }
    }
    
    var guid = Guid.NewGuid();
    Console.WriteLine($"CityListComponent: {nameof(OnAfterRender)} : {guid}");
}
----
<.> So basically only if we are on the first render, is that we will attempt to run
the population and initialization logic **once**.

_Note:_ I just realized we simply offloaded the logic to `ServerListComponent.razor`,
so this "solution" is still applicable, I'll work with that component's code.

[source, razor]
----
protected override void OnAfterRender(bool firstRender)
{
    base.OnAfterRender(firstRender); <.>

    if (!firstRender) <.>
    {
        return;
    }

    if (!string.IsNullOrWhiteSpace(SearchCity))
    {
        servers = ServersRepository.SearchServers(SearchCity!);
        return;
    }

    servers = ServersRepository.GetServersByCity(CityName ?? FALLBACK_CITY);
    StateHasChanged(); <.>
}
----
<.> A good practice is to run the hook's base first.
<.> In case this isn't the first render we don't want initialization logic, so
in here we are simply returning early.
<.> There's one issue that pops up if we don't call the built-in `StateHasChanged`
method, and that is, on a first render we will be calling population logic, yet
the component won't update its state, hence it won't render anything with the
proper data that will map out to UI. So we manually execute this so that the
UI reflects the state that was changed with the initialization/population logic.

This is pretty eye-opening. Specially since I thought `StateHasChanged` had to
somewhat be trickled down from a parent to a child. In here, the `ServerListComponent.razor`
component is the only one in charge of populating based on parameters, and when
applying this code, the workflow still works flawlessly. **With the added bonus of
running population logic only once**.

[IMPORTANT]
====
So the takeaway here is that with Interactive Server, **by default** _pre-rendering_
is on, and lifecycle hooks run twice (initialization-wise). If we rely on these
hooks for population-logic or initialization, depending on the use case we might
be running really costly logic **twice**. To get around that we can safely rely
on `OnAfterRender` and its `firstRender` parameter (plus `StateHasChanged()`).
So that only on the **first render** we run the logic, and after state is updated,
we notify the component to again re-render with the newly updated state. A simple,
yet **key concept** that we have to remember.
====

==== Trouble with Pre-Rendering

_This is just some text content:_

````
The component initialization problem is caused by Pre-Rendering, which is enabled
by default by Microsoft. That is for a reason.

For deep understanding the reason behind it and solutions for resolving this
problem, please don't forget to see the chapter/section: "Pre-Rendering in Blazor"
which will be one of the last chapters/sections in the course.
````

==== The problem with OnParameterSet

There's a problem with this **hook**. This hook will only be triggered if a
parameter has been changed. The component might have **multiple parameters**,
say we have _3 parameters_. If we update the 3 of them, on each parameter change
detection, the hook will run, meaning we can be running the hook **three times**.

Even if we try and code "smartly" around this fact, it's really hard to keep track
of "what parameter change triggered the specific execution instance of the hook".
Any of the three parameters change could've triggered the hook.

So a parameter that has nothing to do with search or city selection could change
and trigger `OnParameterSet`, and potentially be executing an expensive database
call, or expensive processing logic.

How do we avoid that? We need to somehow code a mechanism that allows us to safely
and reliably detect if a specific parameter has changed, and it makes sense to
run code based on that change. Otherwise, avoid unnecesary code execution.

[source, razor]
.ServerListComponent.razor
----
public override Task SetParametersAsync(ParameterView parameters) <.>
{
    if (parameters.TryGetValue<string>("CityName", out var cityName)) <.>
    {
        if (cityName != CityName) <.>
        {
            base.SetParametersAsync(parameters); <.>
        }
    }
    
    if (parameters.TryGetValue<string>("SearchFilter", out var searchFilter))
    {
        if (searchFilter != SearchCity)
        {
            base.SetParametersAsync(parameters);
        }
    }
    
    return Task.CompletedTask; <.>
}
----
<.> The `SetParametersAsync` hook, as we know by now, runs before everything, and
it's its **base** method call that will execute all other hooks (such as `OnParametersSet`),
it also has a _dictionary_ of the parameter values that will be introduced into
the component (so on each parameter change this hook will be triggered).
<.> We can leverage the dictionary this hook provides to check for a specific parameter
we want to be tracking.
<.> We can then check if the parameter we are evaluating differs from the current
component's value. A simple operation of: "is this parameter after the state change
detection different than what the component currently has as state?"
<.> In the end we should just return an "empty" `Task.CompletedTask`, that way we
don't get compilation errors but also we don't run unnecesarily the `OnParametersSet`
if we don't want to run expensive logic there.

And as you can see, this code can easily be boiler-plaity in nature, and for that,
you can definitely come up with something that abstracts it, but this will do for
now, specially since it's a course and deminishing returns are a risk here.

[NOTE]
====
It's important to highlight here that depending on the use case we might leverage
the `OnAfterRender` or this parameter control pattern, but it will really depend
on what type of component, workflow, and component tree we are working with. We
should be able to choose what is not good to run, and how to get around that
with this new found knowledge with both hooks.
====

[IMPORTANT]
====
You have to be extremely careful of mixing these two concepts and solutions together
though, because you can easily enter an endless cycle of one solution conflicting
with the other and making the apparent "solution" actually just be running code
**twice** or even more than that. This definitely has to be labbed and tested out
way more than what the course entails, perhaps looking at how the components themselves
are architected (my hunch is that we should always be retrieving data at the orchestrator
component, he will receive signals from all children and then dispatch updates to
them by updating their properties). That way we avoid these _catch-22_ scenarios.
Besides, the parent is technically the guy that runs first and can potentially get
the info first hand.
====

_Todo:_ Currently the only problem that is detected is:

[source, razor]
.ServerListComponent.razor
----
public override Task SetParametersAsync(ParameterView parameters)
{
    if (parameters.TryGetValue<string>("CityName", out var cityName)) <.>
    {
        if (cityName != CityName)
        {
            base.SetParametersAsync(parameters);
        }
    }

    if (parameters.TryGetValue<string>("SearchFilter", out var searchFilter))
    {
        if (searchFilter != SearchCity)
        {
            base.SetParametersAsync(parameters);
        }
    }

    return Task.CompletedTask;
}

protected override void OnAfterRender(bool firstRender)
{
    base.OnAfterRender(firstRender); <.>
    if (!firstRender)
    {
        return;
    }

    PopulateCities();
}

protected override void OnParametersSet()
{
    PopulateCities();
}

private void PopulateCities()
{
    if (!string.IsNullOrWhiteSpace(SearchCity))
    {
        servers = ServersRepository.SearchServers(SearchCity!);
        return;
    }

    servers = ServersRepository.GetServersByCity(CityName ?? FALLBACK_CITY);
    StateHasChanged();
}
----
<.> If we load the component for the first time, this hook gets triggered, and in
turn will call the `PopulateCities` method since the parameters from "nothing"
turn into "something".
<.> The issue is that on the first render, this code path also evaluates to "populate
the cities please". Meaning, that by combining the solutions we were provided, we
are still running into the issue of "we are calling the population logic more than
once". And that's the issue. Again, this might have to do with the awful approach
that I implemented on a whim, I truly think we should adhere to the base principle
of "Parent component is an **orchestrator**, he should be the one getting data,
bringing together the children components, they are **dumb**, they should be
**dumb components**, no complex stuff, just display logic".

==== When does a component render

Why should we care about this?

With SSR (Static), the component renders once. But interactive components differ
in the sense that the component tree will re-render many times depending on how the user
interacts with the UI.

When a component is presenting issues (doesnt render, renders wrong), we should be
able to debug that behavior pretty easily by understanding the fundamentals.

- Where to set a breakpoint
- Where to write a `Console.WriteLine()`
- Where to log

. A component is rendered when it is created for the first time. (Obvious)
. When events are triggered (it has to be UI events, including `EventCallback`),
no timers, no deallocate. Only UI events will trigger re-renders. (Clicking on a
button, selecting an item from a dropdown list, make a change in an input box).

[NOTE]
====
But Blazor is intelligent, is not as simple as "ANYTHING" will trigger re-render,
Blazor looks specifically at **state variables**. Remember that Blazor does the whole
"reduce" operation from a previous component tree and a newly introduced component
tree. It will only re-render the portion that changed. _Don't worry too much about
performance since Blazor takes care of that_.
====

. When an event is triggered, and we have a parent-child structure. Say, we click
on a button (on the parent component) we will trigger re-render on the parent,
but the child will behave differently, why? Because of the reduce computation, if
state didn't change whatsoever, child will not re-render. _What if the button is
on the child?_ Only if we have an `EventCallback` tying them together to said
event, then we will have the parent also re-rendering.
. When component parameter value changes. Regardless of if the parent changed the
state, or some cascading parameter triggered the change, the moment one parameter
changes (state changes) and the reduce algorithm detects a difference, then re-render
**will be triggered**.

_Blazor will be able to determine if the parameter changed or not only if the parameter
is a primitive type_.

It is on the first re-render scenario that we can say it applies for SSR and interactive
render. All other scenarios we presented are entirely for **server interactivity**

**Class: Blazor won't be able to know if said parameter changed or not**.

. When a developer manually calls `StateHasChanged()` this is a manual trigger
of re-render on a component. _When do we call this method?_ On the case where we
used `OnAfterRender`, we had to call it manually since state changed but the component
didn't re-render so we had to tell it to re-render since then it would pick up
on the new state on the UI build process. Another use case is **async calls**.
If we know that after an async call state will be changed, we will have to go and
manually call `StateHasChanged()`. This could also be used for `delegate` types,
maybe we have a component providing a function and then another executing it
and then having to signal a component to re-render since this result would be
of a state change but UI not aware of that. **If a code execution is not a UI
event we have to manually call `StateHasChanged()`**.

E.g., If we have a timer, and everytime this timer finishes or sends signals,
and we need that info to build the UI. We need to mark the component with
`StateHasChanged()`.

That's it, we need for state to change, hence SSR doesn't work with state then
this method won't work at all.

==== The problem of ShouldRender

This hook runs when the component first renders, but then on each sub-sequent
render _before_ `OnParametersSet`.

Okay, basically it's suggested in the lesson that _Microsoft has a bug and this
should be fixed in the future_. But Lord and behold, the issue that I pointed out
before is still there. So let's follow the course's advice:

Use `SetParametersAsync` in order to control if the component should render or not.

==== Thread Safety & SynchronizationContext for Server Interactivity

We have a web browser, and we have the server side. As mentioned before **the server
keeps an _in-memory_ representation of a component through a `SignalR` channel**.

The web browser and the server process are both running in different threads, they
are technically not related, but somehow they still behave as if they were the
same thread (at least to the user it feels that way).

**Synchronization Context:** One of these exist per SignalR connection that
is established. It's thanks to this mechanism, that two completely unlerated threads
can collaborate to provide the SPA app experience to the user. This will take
care of mitigation of risky state updates and thread synchronization. Everything is
based around _UI Events_.

Say we have a _timer_ or whatever resource at the server side, and we want to interact
with a component, we won't get access to the component's state whatsoever, since all
of its context lives in its own (main thread), which is just a session for a user
the moment he loads the website. This is actualy a _thread safety_ issue, two
separate threads not being able to share state.

Let's introduce a requirement to then put us against the issue:

. The user is asking for the list of servers to display periodically the data
of users connected. So active polling and accessing the actual runtime. (Retrieve
every 10 seconds).


Let's try different ways of achieving the result.

[source, razor]
.ServerListComponent.razor
====
<button type="button" class="btn btn-primary" @onclick="@(() => { })">
    Refresh
</button>
====
A really important concept here, even if you don't attach an actual method to
a callback, just putting a handler (like this empty one) will immediately configure
the component to re-render based on this event.

If we press the button, because of the nature of how we setup the list of users
online, we generate randomly a number on each render. This button should then
trigger this behavior (and it does). There's a lot going behind the scenes, this
wouldn't be possible if there wasn't a Synchronization Context built-in, because the
web browser thread and the server thread are different. But an interaction in the
web browser still is kept together as if this was all but one thread, now
**if we try and use a timer** that's just story.

If we head to `ServerListComponent.razor`

[source, razor]
----
protected override void OnAfterRender(bool firstRender)

    base.OnAfterRender(firstRender);
    if (!firstRender)
    {
        return;
    }

    Timer = new Timer(_ => { StateHasChanged(); }, state: null, dueTime: 2000, period: 2000);
}
----
This code will break the application. There's problems reconnecting the circuit,
trying to debug leads to tons of errors. But the answer is simple, you are creating
an event on a separate thread. And then trying to patch back its logic to another
thread's runtime. This causes all sorts of issues internally, the app can't figure
out what thread holds the state it will update. The backend and UI literally
go out of sync a, hence we see all these cryptic error messages.

Luckily Blazor comes with its own solution to this:

[source, razor]
----
Timer = new Timer(_ => { base.InvokeAsync(StateHasChanged); }, state: null, dueTime: 2000, period: 2000);
----

This takes care of taking whatever "separate-thread process" and putting back
under the same context for execution. Hence it shouldn't break anymore.

_Blazor Web Assembly has no issue_ Why? Cuz everything is on the browser.

=== Routing and Navigation Deep-Dive

==== Static vs Interactive Routing

Routing:: Navigation from one page to the next.

We know this, we've seen it. You can put this to the test pretty easily. Every time
you click (with SSR) on a routable component and you bring out the DevTools, you
should be seeing a new entry with a whole new request there just so that the
navigation can work.

````
<Routes @rendermode="InteractiveServer" />
````

Remember, our setup already has this set in `Program.cs` with `app.MapRazorComponents<App>().AddInteractiveServerRenderMode();`.

I prefer this approach since through `Config Files` we can easily change the render
mode if we want to. Adding this in the HTML and stuffs will require for way more
overhead.

Anyway, when we have interactivity on: **This becomes an SPA, we no longer will
make static requests per navigation (except on the first handshake that we know
is the standard)**. (No way around that).

But yeah, all components get loaded through SignalR. No more static requests.
We can however see the SignalR channel and then debug there information that gets
passed around (as binary info). This SignalR info exchange powers the same UX
but without having to re-load the whole page.

You have to be careful about your assumptions however:

- If there's static content to be retrieved (i.e., some images) we will go to the
server to get them for a first time. Right after that they will be in memory and
we no longer will make a request for them.
- We have to look at the Pages themselves (routable components). If you have
interactive components on a static page, it won't matter, we will still have to
work with static routing. The **Router** has to be made interactive so that the
**Routing becomes interactive**.

==== Use NavigationLock to prevent navigation

We'll use one specific requirement:

- Say we have a really big form, it takes time to fill in and perhaps if we try
to navigate away from it by mistake, it will be annoying to have all of that lost.

For that use case we have something called `NavigationLock` this will allow us to
intercept some routing event and stop it manually.

[source, razor]
----
@page "/servers/edit/{id:int}"

@inject NavigationManager NavigationManager

@inject IJSRuntime JSRuntime <.>

<NavigationLock OnBeforeInternalNavigation="OnBeforeInternalNavigation"></NavigationLock> <.>

<h3>Edit Server</h3>
<br/>

@if (_server is null)
{
    return;
}

<EditForm Model="_server" FormName="formServer" OnValidSubmit="Submit">
    <DataAnnotationsValidator></DataAnnotationsValidator>
    <ValidationSummary></ValidationSummary>

    <InputNumber hidden="true" @bind-Value="@_server.Id"></InputNumber>
    <FieldComponent Label="Name">
        <Control>
            <InputText class="form-control" @bind-Value="_server.Name"></InputText>
        </Control>
        <ValidationControl>
            <ValidationMessage For="() => _server.Name"></ValidationMessage>
        </ValidationControl>
    </FieldComponent>

    <FieldComponent Label="City">
        <Control>
            <InputText class="form-control" @bind-Value="_server.City"></InputText>
        </Control>
        <ValidationControl>
            <ValidationMessage For="() => _server.City"></ValidationMessage>
        </ValidationControl>
    </FieldComponent>

    <FieldComponent Label="Online">
        <Control>
            <InputCheckbox class="form-check-input" @bind-Value="_server.IsOnline"></InputCheckbox>
        </Control>
    </FieldComponent>

    <br/>
    <button class="btn btn-primary" type="submit">Update</button>
    <a href="/servers" class="btn btn-primary ">Go Back</a>
</EditForm>

@code {
    [Parameter] public int Id { get; set; }

    [SupplyParameterFromForm(FormName = "formServer")]
    private Server? _server { get; set; }

    private void Submit()
    {
        if (_server is null)
        {
            return;
        }

        ServersRepository.UpdateServer(_server.Id, _server);
        NavigationManager.NavigateTo("/servers");
    }

    protected override void OnParametersSet()
    {
        _server ??= ServersRepository.GetServerById(Id);
    }

    private async Task OnBeforeInternalNavigation(LocationChangingContext context) <.>
    {
        var isConfirmed = await JSRuntime.InvokeAsync<bool>(identifier: "confirm", "Are you sure you want to leave this page?"); <.>
        if (!isConfirmed)
        {
            context.PreventNavigation(); <.>
        }
    }

}
----
<.> Really weird way to introduce this, but I remember this from way back. We have
an interface that allows us to run Javascript directly from blazor, we have to inject
this specific **interface** and then leverage the object.
<.> This is a built in component to which we can then attach callbacks to, in here
we are going to attach to a routing that happens only for application routes (you
can also hook into navigations that cross the app domain and go somewhere entirely
different).
<.> We need this specific signature since we will get as a parameter an object that
we can then leverage to manipulate the routing behavior.
<.> This is how you can leverage the service to run javascript natively, you have
to feed into it a name of a function, (in this case is the built-in function to show
a modal with buttons of confirm and cancel). And (this approach is so generic, it
relies on us making good docs, but basically based on the javascript function you
want to run, you will feed here all the respective parameters. In this instance,
we know that it takes as a first parameter the string for the message that will
be show on the alert). We also need to know what type of response it will spit back
out so that we type the result of the `InvokeAsync` correctly. This function is
async so it's recommended to work on an async method as well.
<.> We then based on the confirmation of the user prevent the routing or not do
anything so that it routes to another page.

The course denotes nuances here, how the page needs to be marked as `@rendermode
InteractiveServer`, and how that's not enough, finally landing on the idea that
the **Router** himself has to be marked as interactive so that the `NavigationLock`
works correctly. With **static routing**, we cannot leverage the `NavigationLock` at
all.

(Again, we have set it on our end programatically, so this doesn't apply to us,
but it's still GOOD TO KNOW ABOUT THIS SINCE SETUPS VARY IMMENSELY).

**Big Note:** For the injection of the `JSRuntime` be sure to inject the interface
`IJSRuntime` otherwise it won't be able to resolve it. Again, remember that C#
always tries to adhere to best practices and recommended approaches so by default
it will rely on an interface.

Anyway, after the **Router** himself has been marked as interactive, then we can
safely leverage the `NavigationLock`. We will get the confirmation window and
based on OK or Cancel we will stay in the page, and/or move away.

[IMPORTANT]
====
If we reload the page with the web browser, or try to go to another URL then
the NavigationLock won't work, we won't be stopped.
====

There's another parameter we can leverage on the built-in `<NavigationLock>` and
that's `ConfirmExternalNavigation="true"`. If we set that to true, and try to reload
the page, or go to another website, we will indeed get a confirm window, although
this doesn't have the message that we provided for the specific router navigation
javascript function workflow. (But there must be a way of customizing it for sure).

**AGAIN:** You need for the `Router` itself to be set to be Interactive. Otherwise
this interception will not work.

_Final Note:_ The course is just disabling this code we put, mainly because it was
only for demo pursposes. Still good to know that this is a thing.

==== Multiple Page Directives 

So far in our application, we only have "one-page directive". But **routable components
can take multiple routes actually**. Why would we need these type of components?

From experience: We add these multiple page directive components so that we cover
more ground with the component, we run different initialization/functionality
to cover more uses without creating a whole new component that is bound to repeat
code also.

This is a requirement we are adding to put this to the test:

- When we select a city (e.g., Ottawa), and go and Edit one server, once we come
back we still want to see Ottawa selected, we don't want to get that state nuked.
We want to provide good feedback to the user and leave traces of what he did.

We will cover this requirement with multiple page directives:

[source, razor]
.Servers.razor
----
@page "/servers/back-from/{previousCityName}"

[Parameter] public string? PreviousCityName { get; set; }

protected override void OnAfterRender(bool firstRender)
{
    if (!firstRender) <.>
    {
        return;
    }

    if (!NavigationManager.Uri.Contains("back-from") || string.IsNullOrWhiteSpace(PreviousCityName)) <.>
    {
        return;
    }
    
    CityName = PreviousCityName; <.>

    StateHasChanged(); <.>
}
----
<.> We want this as initialization logic, hence if this isn't the first render we will
just short-circuit.
<.> We are going to manually analyze the the URI and also check that we have received
a "at least not empty" route parameter for that city that we will leverage to trigger
a querying of a specific city.
<.> And if all our controls (that are else-less/return early btw) pass, we then assign
to the normal `CityName` state variable our route parameter valuable so that this
trickles down to querying a city that came back from that trace in the Uri.
<.> Lastly, remember that in `AfterRender` state won't be detected so a good recipe
is that by the end we trigger this signal ourselves so that we get the content
we want from initialization rendered correctly.

**NOTE:** We are actually clashing because the code we implemented uses `cityName`
already as a state variable, but we will get around it by simply changing the name
of this route parameter.

_Small bug:_ The server list is working just fine, but we don't get to see the
flagged city marked as selected in the city list. And that is because we have
disconnected the selected city state variable in the child with the parent, the
course simply turns that into a `[Parameter]` so that we can pass from the parent
in case we are at this second use-case to the child whatever they need to mark
as selected.

My take: This can be really bad, since we will start making a component way bigger
by accounting for multiple scenarios, this is because we are leveraging what we
know though. If I had introduced a store, we can leverage state there to then decide
on what to do, store really is a nice clean solution to avoid polluting components
with parameters, and noise overall. Still we would be adding tons of branches to
components, more code that makes them less maintainable, so please bear that in mind
and make wise choices.

So in `CityListComponent.razor`:

````
[Parameter] public string SelectedCity { get; set; } = "Toronto";
````

And on the parent side we will simply feed our state variable so that they are
intertwined and we trickle down state based on what the parent receives at its
route level:

````
<CityListComponent SelectedCity="@CityName" @ref="CityListComponent"
                   SelectCityCallback="HandleSelectedCity"></CityListComponent>
````

Testing out all the flows, we should be seeing how on edit, add, we are going
back to a previously selected city and both the list of servers are from that
city and also said city is marked as selected.

==== Optional Parameters

So, in order to test out how the parameters we have been using up until now are
**mandatory** we can play around with `Weather.razor`.

If we provide a route parameter that maps to a `[Parameter]` decorated state
variable:

URI:
`localhost:1234/weather/toronto`

`@page "/weather/{name}"`

The page will work normally, but if we omit the last resource (so no `toronto`),
we would end up with a _404_. And that proves that these types of parameters are
required (with this syntax). However, the easiest way to make them optional is
to add a question mark:

`localhost:1234/weather`

`@page "/weather/{name?}"`

The page would still render here, JUST FINE.

[NOTE]
====
Why would we want to mark a parameter as optional then? Well, there are many
scenarios you can take into account. E.g., For multiple scenario pages, just like
the multiple page directive pages we analyzed some time back.
====

However, one really common use case is to mix Add and Edit pages into an `Upsert`
type of component. So that we can do additions and editions on the same component
but based on specific parameters the code in charge of the flow will change at
runtime.

And so, by deleting the `AddServer.razor` and `EditServer.razor` pages, and adding a
brand new `AddEditServer.razor` page we would be effectively replacing them both
with **one page**.

[source, razor]
.AddEditServer.razor
----
@page "/server/{id:int?}" <.>

@inject NavigationManager NavigationManager

@if (Id is not null) <.>
{
    <h3>Edit Server</h3>
}
else
{
    <h3>Add Server</h3>
}

@if (Server is not null)
{
    <EditForm Model="Server" FormName="formServer" OnValidSubmit="Submit">
        <DataAnnotationsValidator></DataAnnotationsValidator>
        <ValidationSummary></ValidationSummary>

        @if (Server.Id > 0) <.>
        {
            <InputNumber hidden="true" @bind-Value="@Server.Id"></InputNumber>
        }
        <FieldComponent Label="Name">
            <Control>
                <InputText class="form-control" @bind-Value="Server.Name"></InputText>
            </Control>
            <ValidationControl>
                <ValidationMessage For="() => Server.Name"></ValidationMessage>
            </ValidationControl>
        </FieldComponent>

        <FieldComponent Label="City">
            <Control>
                <InputText class="form-control" @bind-Value="Server.City"></InputText>
            </Control>
            <ValidationControl>
                <ValidationMessage For="() => Server.City"></ValidationMessage>
            </ValidationControl>
        </FieldComponent>

        <FieldComponent Label="Online">
            <Control>
                <InputCheckbox class="form-check-input" @bind-Value="Server.IsOnline"></InputCheckbox>
            </Control>
        </FieldComponent>

        <br/>
        <button class="btn btn-primary" type="submit">@(CalculateButtonLabel(Server.Id))</button> <.>
    </EditForm>
}

@code {
    [Parameter] public int? Id { get; set; } <.>

    [SupplyParameterFromForm] public Server? Server { get; set; }

    private static string CalculateButtonLabel(int id) => id > 0
        ? "Update"
        : "Add";

    protected override void OnParametersSet()
    {
        if (Id.HasValue) <.>
        {
            Server ??= ServersRepository.GetServerById(Id.Value);
        }
        else
        {
            Server ??= new Server { IsOnline = false };
        }
    }

    private void Submit()
    {
        if (Server is null)
        {
            return;
        }

        if (Server.Id > 0) <.>
        {
            ServersRepository.UpdateServer(Server.Id, Server);
        }
        else
        {
            ServersRepository.AddServer(Server);
        }

        NavigationManager.NavigateTo($"/servers/back-from/{Server?.City}");
    }

}
----
<.> In here we are introducing the `?` to mark this as an optional parameter.
But something **REALLY IMPORTANT** is that we have to use the constraint for integer
here, otherwise when trying to access the edit use case e.g., `/server/1` then the
component will blow up because it will try to map a string to an `int?` and Blazor
doesn't want to do that (he's a little confused).
<.> Based on the optional parameter we can apply conditional rendering for a title
(as an example).
<.> The logic that was chosen here is to retrieve an actual server from the repository,
but in case it's an addition we create a base object that will have by default an
Id of `0`. Hence we can use this flag value to determine whether we are at the
Add or the Edit workflow.
<.> And in here, remember to use a `[Parameter]`. Also this should be nullable since
we could not be sending anything to map through a route parameter.
<.> Nullable types by default wrap the value, hence we get access to this properties,
and we can leverage to detect specific values in order to decide on the respective
workflow.

Besides, since we are nuking the original pages and swapping them with this new
Upsert page, we will have to update the respective places to match the route, and
the new format (so be sure to check any instances that had the previous route):

.Servers.razor
````
<a href="/server" class="btn btn-primary">Add Server</a>
````

.QuickGridDemo.razor
````
<a href="/server/@context.Id" class="btn btn-outline-primary">Edit</a>
````

.ServerComponent.razor
````
<a href="/server/@Server.Id" class="btn btn-outline-primary">Edit</a>
````

All these places had a different naming convention even (it didn't adhere to best
REST, HTTP practices even), but now with the Upsert page introduction we align
to best practices and the new format.

So we consume the same component, however, based on a route parameter that is
optional we load the page through different workflows.

After making the swap we should test the workflows and behaviors, they should
be behaving the same. If not, **FIX IT**.

The course argues that by leveraging optional parameters and merging two components
we reduce the maintain effort. Which is, _debatable_. Since you can easily argue that
by getting this component _closer to a god component_ then effort actually increases,
since code is less about "Single Responsibility" now.

But yeah, it's still _useful_ to know this is possible, and how to get around
it. (DRY => This is the principle argued as being applied).

==== Query Strings

In addition to route parameters (course calls them "route templates"), we can add
data to a URL with Query Strings. (This is basic Web knowledge).

Say, we would want to encode a city name in the url: `/server/1?city=Toronto`.

Blazor can easily retrieve these types of variables:

````
[SupplyParameterFromQuery] public string? City { get; set; }
````

Two notes here:

- A query string is **always optional**. So be sure to map all the possible
parameters to nullable types.
- The course is on SSR code, and in this instance using `OnParametersSet` for
init code is fine, with interactivity we should retrieve back to what we said
with `SetParametersSync`, this is more in order to avoid double execution of
code and stuffs.

[source, razor]
.AddEditServer.razor
----
protected override void OnParametersSet()
{
    if (Id.HasValue)
    {
        Server ??= ServersRepository.GetServerById(Id.Value);
    }
    else
    {
        Server ??= new Server { IsOnline = false };
    }

    // if (Server is not null && !string.IsNullOrWhiteSpace(City))
    // {
    //     Server.City = City;
    // }
}
----
The code is commented because the required we set here is just for demo purposes.
We would provide through a query parameter (city) a value that in our init logic
we can leverage so that the Server state variable has its `City` property set to
this query parameter. In the right place, at the right moment, this can be extremely
useful, I know that. And it's easy as just decorating a state variable, the name
is even mapped out with MS magic that abstracts even the obscurest of requirements
and scenarios.

=== State Management Deep-Dive

==== State Management Overview

Like we mentioned before, traditional web apps. **Don't deal with STATES**. With
SPAs however, (and in Blazor's case, regardless of Server or WebAssembly interactivity),
we need to now worry about state management.

We can easily come across challenges as we develop web applications:

_Scenario 1:_ What if we have different pages, and for _whatever reason_ we need
for a page 2, to know about state in page 1. The moment page 1 gets unmounted all
of that state will get lost.

_Scenario 2:_ Let's say we have a routable component, and it has an extremely
complex component tree. Perhaps branches that go waaays deep. And from the last
component of one branch we want to get state across to another component that's
at the deep end of another branch. (We have two subtrees), and we want to share
state between these children components.

We learned so far two techniques:

- Bubble Up. All the way from low levels to top levels.
- Cascade a parameter.

However, this can easily turn ugly, a callback hell and tons of repeated code
on top of complex logic without good reason.

These are the challenges we are attempting at solving in this section, and this
will work for WASM and Server interactivity without issue.

==== Use URL to pass info across routable components

The first approach for state management is to keep state across routable components.

We will use the URL to retain and pass state across **Pages**.

A common problem to solve with this technique is a **Wizard**. So a screen that follows
a series of steps. (E.g., Step 1 > Step 2 > Step 3). All the steps would be routable
components that are built around a workflow, the idea is to pass all the info collected
on a previous step to the next step.

The idea is to use query strings to pass variable info.

I probably won't implement this in the actual course repo, it's redundant and it's
just for demo. So we'll keep this "theoretical", but let's still extract the good
out of the lesson.

Three pages are created under a `Wizards` folder:

- SetCityName.razor
- SetServerName.razor
- SetStatus.razor

The `Add Button` that we have in the server list screen will redirect to **Step 1**
which is actually `SetServerName.razor`.

The code of this first step is just one field from the `AddEditServer.razor`,
we are separating each field onto a step. And the biggest takeaway is that on the
previous step we are navigating and adding the state the current page captured
as a query param:

````
NavigationManager.NavigateTo($"/cityname?servername={serverName}");
````

_Note 1:_ Another bootstrap class that might come in handy:

````
<div class="alert alert-danger">
    @errorMessage
</div>
````

This displays something "static", but it's a nice looking window with a color and
message inside of it. In this instance this is an error message in case the field
validation fails on the First Step.

Now going to the **next step**, we have to receive the query param information now,
the code for that uses what we already know:

.SetCityName.razor
````
@code {
    [SupplyParameterFromQuery]
    public string? ServerName { get; set; }

    protected override void OnAfterRender(bool firstRender)
    {
        if (!firstRender)
        {
            return;
        }

        if (!string.IsNullOrWhiteSpace(ServerName))
        {
            return;
        }

        ErrorMessage = "Server Name wasn't provided";
        StateHasChanged();
    }
}
````
This is just a double check (defensive code), in case we somehow accessed the
second step without a previous workflow setting the parameter, (notice how we
are leveraging `OnAfterRender`). And as you know, when we use this pattern, by the
end we have to trigger a re-render so that UI reflects the change in state we might
have applied. We populate the new screen's state variable with the query param,
and we then do our own bit of capturing info on another state variable.

_Note:_ I would actually just send the user back, or avoid entering this altogether,
specially if the workflow is important, so I would just stop navigation and kick
the user back to the first screen.

And then on the code to go to the next step and control that the two required state
variables to put as query params aren't invalid:

````
NavigationManager.NavigateTo($"/cityname?servername={serverName}&cityname={cityName}");
````

And I think you get the idea, on the next step we would add now two state variables
to capture each respective query parameter, control on `OnAfterRender` for possible
wrong inputs, and then when trying to trigger the next step/save of server we would
again check for invalid inputs, and then run the respective logic.

Pretty straightforward, and easy to grasp. But it can be a risk for maintainability
if the list of steps is too long, and you are by the end with 10+ query params and
its respective state variables. So be wise when using this approach.

[IMPORTANT]
====
Okay so to understand this correctly and we don't get stuck later because "it's not
re-rendering uhhhh....". The parent, when calling a `StateHasChanged()`, will attempt
to re-render children. But that's only if the parameters provided to them will
result in a `diff` detected by the **reduce** action. If nothing is different children
will skip re-render. _Hence we can sometimes have the `StateHasChanged()` execution
at the parent level and then child components reflect state change and behave
accordingly_. But as we implemented in `CityListComponent.razor` we can also manually
be scanning on the child component side for changes in parameters, and when they
are detected we can trigger **AT THE CHILD LEVEL** as `StateHasChanged()` and the
UI displaying correct behaviors. This will depend entirely on our preferences, and
of course, _if this is easier to edit later_.
====

**NOTE:** For Children, the place to be checking is `SetParametersAsync` and for
Parents, it could be `OnAfterRender`. Or the aforementioned `SetParametersAsync`.
But again, this depends on use case, however, this is the most preferred hook,
since it can also be extended for costly operations (database queries, network calls).
But you have to make sure that you aren't making double the calls. **PLEASE**.

==== Use browser storage to maintain states

Passing state with query params works, and it can be useful in some use cases. But
there's only so much you can pass through URL, it's not really convenient if that
info is too much. Secondly = The URL is preserved in the browser history, so people
will be able to see exactly what info you have passed around pages.

We can use the `Session Storage` or `Local Storage`.

Most modern browsers have implemented these two storages, and it organizes info
based on the domain e.g., `localhost:3234`, `google.com`, etc. It's a literal
key-value pair.

_What's the difference?_ Local Storage = Survives window closes, it will be kept
in browser virtually forever unless you manually clean the value. Session Storage
doesn't survive closing the browser. State is accessed per domain.

_Session Storage:_ Its scope is only for the **current tab and current domain**, you can't open another
tab and try to access another tab's session storage. _Doesn't matter if you are on
the same domain/app_.

If we save info in `Session Storage`, we can save in a cleaner, more secure way
data that can be passed across different components. Its limit is around 5 MBs also,
which is way more than what query parameters will allow us.

Local Storage will still be visible if the user goes to see it with the Dev Tools,
and also even if the browser is closed. However **Session Storage** is more volatile,
and the moment the browser and/or tab is closed all that info will be wiped.

_With this info in mind, you can make assumptions and build your code and what
storage you leverage based on security concerns, practicity, applicability,
requirements_.

[IMPORTANT]
====
For the specific use case of passing state across pages/components with storages,
prefer **Session Storage**, only stick to **Local Storage** for really nieche
things.
====

How do you access the browser storage?


Automatically Blazor loads into the DI container two instances that we can
inject into classes (and components)
````
public SessionStorage(ProtectedSessionStorage protectedSessionStorage, ProtectedLocalStorage protectedLocalStorage)
{
    // Run logic with this...
}
````
A note here, the course recommends wrapping these things behind our own class,
so it created a wrapper called `SessionStorage`, and on its constructor it resolves
the local and session storage DI injected instances, that it can then save on its
own properties.

And another thing to be aware of, we have to leverage async methods:
````
await protectedSessionStorage.GetAsync<Server>("server");

await protectedSessionStorage.SetAsync("server", server);
````
We can send direct objects, and serialization/de-serialization will take place
automatically under the hood. (You can see how we add a type argument for a class
we want to be used as the model for deserialization of the `server` key). And
how we don't need that when saving an object to a respective key. _Note:_ Another
thing worthy of note here is that the wrapper class is also acting as a Facade
so that any consumer calls its methods in order to save things into the storage
and not worrying about the inner logic. So it's a great abstraction interface
as well. Any other key-value pair that should be contemplated can be abstracted
into more getter-setters here. (I would abstract this further, and the course also
follows that same idea, so that we don't fall into boilerplate).

How would we use our wrapper?

.Program.cs
````
builder.Services.AddTransient<SessionStorage>();
````
Transient is a type of lifetime that every-time someone requests for this object,
it will create it right there and then. Simple, and not much to think about it,
this is a simple wrapper in the end. No longer lifetime for such a "trivial"
service.

So on a component:

````
@inject SessionStorage SessionStorage
````

And then just start querying and setting the respective data wherever you need it.

[IMPORTANT]
====
There's a reason the DI instance has the `Protected` suffix added to it. And that
is because this doesn't save the data in plain text. If you try and see the saved
key-value pair, you will immediately pick up on the fact that the value is a HASH/
ENCRYPTED value. _Another great benefit of using the built-in object from Blazor_.
====

And again the takeaway:

- If you save things in the Session Storage and you close the browser and navigate
to the same domain. You will notice how it will be empty.
- If you save things in the Session Storage and navigate to the same domain but on
a different tab, you will also notice how it will be empty.

==== Use DI container to maintain states

Whether we are with WASM or Server interactivity, we will always have **The DI
Container**. Count on it.

The only small nuance is that on WASM the DI Container is maintained on the browser,
whilst on Server, it will be on the Server itself.

We can create another service to hold the state, e.g., `ContainerStorage`. This
is a simple class, that we will add properties to, in order to save in its instance.

Now, for registering the instance we have to make the distinction between WASM
and Server interactivity:

````
builder.Services.AddScoped<ContainerStorage>();
````

For Server Interactivity, we should only expose our state object to the specific
SignalR channel for the respective user. It would be a security concern if we shared
the info with all the users. Hence `AddScoped` is the best practice to use here.
The lifespan of the DI Container Storage will end with the SignalR lifetime. Hence
it's a self-destruct mechanism. (Emulating the Session Storage state management
pattern).

Depending on the use case, you might leverage async or non-async methods, the
protected DI container session and local storage services by default us put us
to use async, but on our own self-implemented service we make that decision.
Async, for thread-blocking operations, and if not, keep it simple.

The idea is to use the same wizard UI implementation but then swapping out the
state management implementation, the workflow should still be the same, since
we are just leveraging different approaches, but in essence they are refactors and
are based on other requirements that are not functional.

Lastly, if you were to be with **WASM Interactivity**, you would DI the service
as `Singleton`. Beside that, nothing else changes. _Why?_ Because all the code is
downloaded into the browser, the sesion lives and dies there, we have no common point
from which other users could go into other user's sessions or data. So that "extra
security" measure is unnecessary.

````
builde.Services.AddSingleton<ContainerStorage>();
````

==== Use Observer Pattern to access state across component trees

We will talk about solutions for the second challenge:

_How would we pass state across components that are scattered across the component
tree?_

The observer pattern is a simple design pattern in which we introduce concepts
such as:

- Based on a specific value that lives at runtime, a class/service/module puts
himself in charge of listening to it and its changes (he's the Observer).
- Any other module that wants to know about these changes, should simply subscribe
to the Observer.
    - Any time a change in the value is detected, the Observer broadcasts about the
    change to all subscribers.
    - Subscribers then choose what to do with these notifications.

How do we leverage this pattern in Blazor?

We would have our **Observer**, that attaches itself to some specific component's
state. And every change should then be broadcasted by this Observer. Other component's
should subscribe to this _"channel"_ in order to receive the state update.

Let's introduce a new requirement to practice the pattern:

- We want to see the number of servers that are online for each city.

Everytime we click on "Turn On/Off" we should be getting the list of cities updated
(in the form of a number).

With this requirement, we introduce a sharing of state between the `CityComponent.razor`
and the `ServerListComponent.razor` components. Let's implement the pattern to
solve this current problem.

==== Implement state store with Observer pattern

. It is recommended to implement a generic class for the observer so that it's
flexible enough for multiple cases.

[source, razor]
.StateStore/Observer.cs
----
namespace ServerManagement.StateStore;

public class Observer
{
    protected Action? _listeners { get; set; } <.>

    public void AddStateChangeListeners(Action? listener) <.>
    {
        _listeners += listener;
    }

    public void RemoveStateChangeListeners(Action? listener) <.>
    {
        if (listener is not null)
        {
            _listeners -= listener; <.>
        }
    }

    public void BroadcastStateChange()
    {
        _listeners?.Invoke(); <.>
    }
}
----
<.> We will leverage delegates to hold a list of the subscribers callback.
(This is because a delegate in theory is also a collection of sorts). We make
it `protected` because we will derive from this class children observers for
different use cases and we want only those types of classes with access to this
property.
<.> Everytime a new subscriber wants to be on the channel we add its callback
to our internal "list" of callbacks.
<.> If a subscriber wants to get off the channel (and we have to cleanup references
to avoid memory leaks), this takes care of removing it from our "list".
<.> Lastly, in order to broadcast about the change, we would simply call this
`Invoke()` method so that all callbacks are executed at once in their respective
contexts and the subscribers react based on that execution.

The course takes a specific design decision:

"We will create multiple stores for each city, mostly to show for demo purposes".
But in theory you could create one store that holds state about each city's number
of servers. It will depend on the scope of the cities, and of course "is this
easier to maintain later?". So choose wisely what approach to take base on your
specific use case.

_It has to be recognized though that "one single store", goes a bit more into the
complex logic realm._

So, let's now make a store for Toronto:

[source, razor]
.TorontoOnlineServerStore.cs
----
namespace ServerManagement.StateStore;

public class TorontoOnlineServersStore : Observer
{
    private int _numberOfOnlineServers;

    public int GetNumberOfOnlineServers() => _numberOfOnlineServers;

    public void SetNumberOfOnlineServers(int number)
    {
        _numberOfOnlineServers = number;
        base.BroadcastStateChange();
    }
}
----
This is pretty straightforward, it's at the implementation class level that we
introduce the state property, and we then keep it locked as `private`, we establish
a getter and setter, and it's on the setter that we then call the base class'
`BroadcastStateChange()`.

When it comes to registering this store, we will add it to runtime with the DI
container:

````
builder.Services.AddScoped<TorontoOnlineServersStore>();
````

This is at `Program.cs`, `Scoped` because we are with Server Interactivity.

_Note:_ And a small note here, so that our `Program.cs` is clean, we can add a
`GlobalUsings.cs` file next to it, and then add all the namespaces we would like
to have imported implicitly:

````
global using ServerManagement.Components;
global using ServerManagement.StateStore;
````

Okay, the following code, I do not like whatsoever, it couples things to the
extreme, adding more cities is not maintainable at all, and we are adding extra
workaround logic with each new store. Open/Closed principle is completely destroyed
here:

.ServerComponent.razor
````
private void UpdateServerStatus()
{
    if (Server is null)
    {
        return;
    }

    var status = Server.IsOnline = !Server.IsOnline; <.>

    if ((Server.City ?? string.Empty).Equals("Toronto", StringComparison.OrdinalIgnoreCase)) <.>
    {
        var torontoServerNumber = TorontoOnlineServersStore.GetNumberOfOnlineServers(); <.>

        if (status)
        {
            TorontoOnlineServersStore.SetNumberOfOnlineServers(++torontoServerNumber); <.>
        }
        else if (torontoServerNumber > 1)
        {
            TorontoOnlineServersStore.SetNumberOfOnlineServers(--torontoServerNumber); <.>
        }
    }
}
````
<.> Using specific syntax here to basically assign the status change and also
saving that mutated value under a variable so that it's easier to reference later.
<.> In here we introduce this coupling code that checks if the city is "Toronto",
if it is we run the Toronto server store logic. (This has been previously dependency
injected).
<.> We get the current number of online servers from the store (more coupled since
this is _global state_).
<.> If the online status is `true` we then add a +1 in the store.
<.> If not, we make another check so that we are sure that the store has at least
**one** online server, otherwise we would introduce negative values.

Once this is done, the child component will now be wired to start updating the store
on his own. But we are still missing one component to make the flow work, where
do we initialize the store?

.Servers.razor
````
var torontoServers = ServersRepository.GetServersByCity("Toronto");

TorontoOnlineServersStore.SetNumberOfOnlineServers(torontoServers.Count(x => x.IsOnline));
````
It would be best at the parent that takes care of rendering the servers to initialize
the stores' values, in this instance we would simply query for all the toronto servers
and then update the stored based on a simple computation that counts how many are
online.

[IMPORTANT]
====
Blazor components also get access to `GlobalUsings.cs` imports. So besides its
`_Imports.razor`, if we introduce this other type of file, they will also have
access to these implicit imports. Remember that.
====

Lastly, on the subscriber side, we want to retrieve the store value:

.CityComponent.razor
````
<div>
    @if (City.Equals("Toronto", StringComparison.OrdinalIgnoreCase)) <.>
    {
        <text>@NumberOfOnlineTorontoServers</text> <.>
    }
</div>

@code {
    private int NumberOfOnlineTorontoServers; <.>

    protected override void OnAfterRender(bool firstRender)
    {
        if (!firstRender)
        {
            return;
        }

        NumberOfOnlineTorontoServers = TorontoOnlineServersStore.GetNumberOfOnlineServers(); <.>
        TorontoOnlineServersStore.AddStateChangeListeners(OnServerStatusChange); <.>
        StateHasChanged();
    }

    private void OnServerStatusChange()
    {
        NumberOfOnlineTorontoServers = TorontoOnlineServersStore.GetNumberOfOnlineServers(); <.>
        StateHasChanged(); <.>
    }
}
````
<.> Only for the component that is for Toronto, we want to be displaying the Toronto's
Store value.
<.> We will simply display a raw value for now, later we can style it.
<.> We need a state variable to keep track of the store's value.
<.> At init, we want to retrieve the store's current value to initialize correctly
our component state variable.
<.> And we also add a component's local callback to the store so that we start
getting notifications.
<.> When the callback gets trigger we will update the local state variable.
<.> Remember, (specially on `OnAfterRender`) that once we change state, the component
will not re-render automatically, in this instance we are getting a notification from
the store, and we are updating our internal state variable, however, we need the
UI to trigger manually a re-render with this updated value, hence we call this here,
otherwise the UI will not reflect the updated change.

**NOTE:** Course bug, we would never get to 0 in the server count, and that is
because this condition is not letting the value go down to 0:

.ServerComponent.razor
````
else if (torontoServerNumber > 1)

// It should be >= 1
````

And that's it, we should get the accurate number of online servers from all workflows
we trigger.

_Again: This is just demo code, production requires a way better approach_.

And so you can go and implement another store if you want for another city.

==== Dispose Subscribers

We have implemented the Observer pattern, and it's working just fine. However we
have one misisng piece of the puzzle, and that is. **Avoiding memory leaks**. Once
a listener is attached, you have to manually remove it as well.

_Note:_ Course is sneaky, it implemented all stores behind the scenes.

The best "hook" at which we can unsubscribe, is when the component goes out of
memory, so add `@implements IDisposable`, and on code:

.CityComponent.razor
````
public void Dispose()
{
    TorontoOnlineServersStore.RemoveStateChangeListeners(OnServerStatusChange);
}
````
We added previously the callback to the store's list of subscriptions and now
before the component gets unmounted we'll make sure we unsubscribe.

Another note here, because there's code for all 5 stores (all 5 cities) a `switch`
statement is used to allocate and deallocate "smartly". And yeah, this is brittle.

[NOTE]
====
One big reason as to why this approach is not good for production, is that we
are allocating more memory without good reason. For each city component, we are
registering 5 stores to listen to and to compute what value to display. Not good,
at all. Hence one store, that is dynamic, that extends and expands based on multiple
events is the best way to go about it. (More complex yes, but easier to change later,
without unnecessary memory allocations and so on)
====

=== WebAssembly Interactivity

==== WebAssembly Interactivity Locations

In short, we know about interactivity locations. You can set it Globally, or set
specific components to use interactivity. All of these concepts apply equally to
WebAssembly, there isn't anything to change there.

Due to the nature of everything working on the browser, that's where the implementation
might differ in its details, but virtually, and practically it all works exactly
the same.

Going a bit into the differences, is that whenever interactivity is marked for a
component then all of that component's info will be downloaded and handled  by
the browser instead of a server from which we initially get a response.

And don't worry, Blazor has been designed, optimize and iterated over so that it's
as smooth and performant as possible even with those constraints.

==== Create a new project with WebAssembly Interactivity

We will create a new project with WebAssemly Interactivity.

[NOTE]
====
We will simply create on the same repo a new project and then make that new project
the startup project. No need to create a whole new repo for this.
====

We will create it with some settings in mind:

- Use the recommended Blazor Web App Template
- Interactive Render Mode: WebAssembly
- Interactivity Location: Per page/component (For deep dive purposes, with global
we wouldn't get to see how things work under the hood since this would already
abstract everything for us.

[NOTE]
====
When creating a new project for a solution. Be sure to stop any running of the
solution's projects. It sometimes interfers with the creation process and we
run into weird states.
====

The moment we create the project, we will notice it will actually scaffold **two
projects**. One with the name we configured, and another one with a `.Demo` suffix.

If we go back a bit on how the architecture works, we know that we have to make
at least one initial handshake with a server to get info. And in the case of
WebAssembly we would be downloading component's in memory, however those in-memory
representations of the components will be at the browser level. In order to get
to that result, Blazor WASM uses this `.Client` project/app. It's crucial for this
to exist so that the application works correctly. This app's whole purpose is to
download the interactive component's info into the browser.

Again, it all depends on if a component is marked as interactive or not, any
interactive component will be handled by this app one way or another.

[IMPORTANT]
====
How do you run with the CLI a solution and marking a Startup project specifically?
Just be standing on the specific project you want to run and execute the same command
we had before: `dotnet run --no-hot-reload`
====

Once we run the app we will notice how this specific template has 3 pages for us:

- Home = SSR, lives in the default project
- Counter = This has interactivity turned on for it, so this lives in the `.Client`
suffixed project
- Weather = SSR, lives in the default project

Because we selected per-component/page interactivity location, our router is
configured as static rendering. So if we navigate away from a page and come back, 
state is also not kept at all. **This is a really important distinction**.

If we take out the Dev Tools, we can notice that a WebSocket connection is indeed
initialized on this WebAssembly setup, but even if we try and poke around on an
interactive page, we won't see any binary messages transmitted. So this connection
must be used only for init purposes (nothing confirmed on docs), maybe.

_Extra Info:_

When we configure a **Global WebAssembly Interactive** project, the `.Client`
project gets both the _Layout and Router_ components assigned to it. Since it
has to now set everything as interactive, it leverages these components a lot,
hence it makes more sense to put them at that project's level.

And another important piece of info is that on the non-global setup, the Router
component injects to itself all possible pages that are in `.Client`:

````
<Router AppAssembly="typeof(Program).Assembly" AdditionalAssemblies="new[] { typeof(Client._Imports).Assembly }">
````

There are small pieces of code also on `Program.cs` that take care of this smart
scanning of the `.Client` project in order to expose them to the gateway application
and make it work as if it was this one sole project (at least it seems that way
to the user).

In the `Program.cs` file the lines of code we should be aware of are important
are:

````
builder.Services.AddRazorComponents()
    .AddInteractiveWebAssemblyComponents();

app.MapRazorComponents<App>()
    .AddInteractiveWebAssemblyRenderMode()
    .AddAdditionalAssemblies(typeof(WebAssemblyDemo.Client._Imports).Assembly);
````
As you can see we have to call a specific method for WASM interactivity, and we also
have to reference smartly the `.Client` assembly so that all components living there
are injected correctly.

==== Mix Render Models

If we head down to `Counter.razor` we will see it has the render mode attribute
set to it as `@rendermode InteractiveWebAssembly`. We mentioned before that's not
a good practice, so we will delete that and specificy the render mode at the component
level (on a parent).

With this current setup, we won't get the same flexibility as before, so first, let's
actually create a page at the main project, that encapsulates the content's of
Counter that is currently at `.Client`.

| Main Project
| --- Pages
| ------- Counter.razor
| .Client Project
| --- Pages
| ------ CounterPage.razor (We actually rename this component cuz the scaffold creates
it without the `Page` suffix)

And on the new page at the main project we would make some code like this:

[source, razor]
.Counter.razor
----
@page "/counter"
<CounterPage @rendermode="InteractiveWebAssembly"></CounterPage>

@code {

}
----

To hide ugly imports we also added as a global import in `_Imports.razor`

````
@using WebAssemblyDemo.Client.Pages
````

With that we should be getting interactivity as before. A good refactor.

[NOTE]
====
There's perhaps a hurdle here, when we run with `dotnet watch run --no-hot-reload`,
this only scans the current project, so if we change things on the `.Client` project,
we won't get a hot reload triggered, (unfortunately), so that will require us to
stop and re-run the command. Which is also something I don't like, I'm used to the
React/Angular approach, I think that keeps a good _flow state_.
====

You can do stuff like this even in `Program.cs`:

````
builder.Services.AddRazorComponents()
    .AddInteractiveServerComponents()
    .AddInteractiveWebAssemblyComponents();

app.MapRazorComponents<App>()
    .AddInteractiveServerRenderMode()
    .AddInteractiveWebAssemblyRenderMode()
    .AddAdditionalAssemblies(typeof(WebAssemblyDemo.Client._Imports).Assembly);
````
Notice how we are adding `AddInteractiveServerComponents` to the DI as well as
the razor component mapping pipeline.

With all of this configured, the page should still work the same, however, it will
be now flexible, and it can adhere to the best practice that we stated that we
should be specifying a render mode at a _html level_.

What's cooler though, is that by enabling this setup, we can even set the render
mode to `InteractiveServer`, which might be surprising, (you can mix these two
modes even though we are on an InteractiveWebAssembly app?).

.Counter.razor
----
<CounterPage @rendermode="InteractiveServer"></CounterPage>
----

And yeah, if you do this, the functionality would still be fine. With the added
benefit that we know get a web socket and the exchange of binary info works as
if it where the previous approach we studied.

We get access to all of these possibilities, simply because we adhered to the
**best practices**.

You can even those stuff like this:

[source, razor]
.Counter.razor
----
@page "/counter"
<h1>Server Interactivity</h1>
<CounterPage @rendermode="InteractiveServer"></CounterPage>

<br />
<br />
<br />

<h1>Web Assembly Interactivity</h1>
<CounterPage @rendermode="InteractiveWebAssembly"></CounterPage>
@code {

}
----
That's interesting, you can declare the same component and switch its rendermode
however you see fit. And it would still work fine. No issue whatsoever.

[IMPORTANT]
====
A `.Client` component can be made as flexible as to be used multiple times, with
different render modes, and be used however we see fit. Always aim to make your
pages/components like this, extremely flexible, reproducible, clean.
====

**Conclusion:** If you can, place your components in `.Client`, and depending
on your use case, choose wisely which render mode to use. Besides that, try to
make the components as flexible as possible, so any requirement doesn't hard
lock you or you yourself then incurr in higher maintenance costs because a
component wasn't architected properly.

==== Life cycle events in WebAssembly Interactivity

Okay, using the previous analysis we had on Server interactivity, we can arrive
at similar conclusions but with a slight different nuance.

_I won't do this since it's redundant, but the course added code to the `Counter.razor`
component to print a message on each lifecycle hook_

First of all, **Pre-rendering is on by default for WASM interactivity as well**.
So we will get hooks running on the server, and then we will see `Console.log`
messages on the browser. Because the code will be running on browser right after.

A set of hooks runs on the server, and another set of hooks runs on the client.
We have the same "issue" discussed before, code will run twice, so when initializing
things, use the `OnAfterRender` hook and leverage its `firstRender` property.
(Or, as we know, we should actually leverage `SetParametersAsync` since there's this
"bug").

After the first handshake, all other messages should be shown on a `Console.log`
since all code gets downloaded to the browser.

**CONCLUSSION:** So, we can conclude in that all previous concepts that apply
for Server Interactivity and lifecycle hoooks, apply in the same manner, but only
with small nuances that when taken into consideration should allow us to build
applications correctly.

==== Browser Storage && Javascript InterOp

We previously used two classes to leverage the browser's storages: `ProtectedLocalStorage`,
`ProtectedSessionStorage`. And that works fine on Server Interactivity, however they
are Server solutions. We have to use something else for WASM. And that's `Javascript
InterOp`.

[NOTE]
====
`LocalStorage` is considered a store of "Global Variables". And we don't like those
since they can bring tons of problems. So that's another reason as to not try to
use it, and prefer `SessionStorage`
====

When trying to use any of the `Protected...` classes on components that live at
the `.Client` project, we won't have the ability to resolve them. It will seem
as though they don't exist, and that is because **they are server interactivity
technologies**.

In its place we have to use the `IJSRuntime` to run javascript code directly and
leverage the browser's capabilities that way.

As a way to demo this we will create two pages in the `.Client` project, one to save
into the session storage and another to retrieve the value:

[source, razor]
.Pages/BrowserStorageStep1.razor
----
@page "/browser-wasm-1"

@inject IJSRuntime JSRuntime <.>
@inject NavigationManager NavigationManager

@rendermode WebAssemblyInteractivity <.>

<h3>BrowserStorageStep1</h3>
<br />
<br />
<input type="text" class="form-control" @bind-value="Data">
<br />
<br />
<button class="btn btn-primary" @onclick="GoNextAsync">
    Next
</button>

@code {
    private string Data { get; set; } = string.Empty;

    private async Task GoNextAsync()
    {
        await JSRuntime.InvokeVoidAsync("sessionStorage.setItem", "demo-data", Data); <.>
        NavigationManager.NavigateTo("/browser-wasm-2"); <.>
    }
}
----
<.> We inject the interop class through its interface (dependency inversion)
<.> If we don't set this here, we won't get to work with inputs, buttons nor anything
like that, **SO DON'T FORGET ABOUT THIS WHEN YOU ARE WORKING WITH THE RECOMMENDED
APPROACH IN WHICH YOU MANUALLY MARK COMPONENTS AND PAGES THAT ARE INTERACTIVE**
<.> And we then run this `InvokeVoidAsync` variation, this is done specifically
because we don't expect a result back at all, hence we just default to a void.
This takes as a string the name of the javascript function/object, and then the
next parameters are parameters by convention that will be fed to the respective
JS function. In the case of `sessionStorage.setItem` we feed a key and then its
value to save in the _sessionStorage_
<.> And after that we leverage the `NavigationManager` just as in the server
interactivity project, this syntax and approach works the same.
+
One small comment here is the fact that we should leverage async programming here,
performance reasons most of the time, so always leverage `Task` and `await`.

And on the receiving component we will leverage interop as so:

[source, razor]
.BrowserStorageStep2.razor
----
@page "/browser-wasm-2"

@inject IJSRuntime JSRuntime

@rendermode InteractiveWebAssembly <.>

<h3>BrowserStorageStep2</h3>

<br/>
<br/>
<br/>

<text>
    @Data
</text>

@code {
    private string Data { get; set; } = string.Empty;

    protected override async Task OnAfterRenderAsync(bool firstRender) <.>
    {
        if (!firstRender)
        {
            return;
        }

        Data = await JSRuntime.InvokeAsync<string>("sessionStorage.getItem", "demo-data"); <.>
        StateHasChanged(); <.>
    }

}
----
<.> Again, don't forget to mark the page with interactivity so that it actually
works.
<.> We mentioned previously that we need to leverage async, so we have to use
this specific async variation of `OnAfterRender`, if we tried using another hook
we would even get errors pointing us towards this hook. And that is because we can't
try to run server hooks or objects that are on server when working on a browser.
And in this specific hook we can leverage WASM objects and functions safely.
<.> As you can see, leveraging async and await, we can execute the javascript code
in charge of retrieving the value that was stored in the previous page.
<.> Never forget to call this by the end, otherwise UI won't reflect the new initialized
state.

And so, we can head to `http://localhost:5182/browser-wasm-1` fill in the input,
press the button, and on `http://localhost:5182/browser-wasm-2` we should be
seeing the value that was saved on the first page.

And this is how we can leverage interop to then use the browser's native session
storage and not die while trying.

==== Use DI container to maintain states for WASM components

This is pretty different.

We will copy the same class we had for a _ContainerStorage_:

````
namespace WebAssemblyDemo.Client;

public class ContainerStorage
{
    private string _message = string.Empty;

    public string GetMessage() => _message;
    
    public void SetMessage(string message) => _message = message;
}
````

Let's go over the theory again, even though we have marked our demo pages with
WASM Interactivity, **Pre-render** takes care of rendering them on the server
first.

If we want to register a DI State Container, we have to register both on the main
project and the `Client` project. If I just save it in one of them, we will run
into issues.

We mentioned this before, but we will mention it again:

````
builder.Services.AddSingleton<ContainerStorage>();
````

On WASM we should add state containers as `Singleton`. On Server Interactivity
we prefer `Scoped` since the moment the SignalR channel dies, then the service
will also be cleaned up. But here, in WASM, the moment the browser dies, then
the app will die as well.

[NOTE]
====
If you want to use `Pre Render` you have to register DI State Containers in both
main and client projects. That is because it will be rendered once in the server
and another on the client. If you register the service only on the Client, then
you will get weird issues stating that the service hasn't been registered and
so on.
====

After this, we can swap out our JS Interop implementation with our State Container
and thing should still work the same. No SessionStorage should be in sight, however,
we would still get the same experience.

And yeah, you can try and turn off pre-render and test if just adding the DI
Container Service on the `Client` works and doesn't run into issues.

==== Debug WebAssembly Components

WASM Components' debugging is slightly different, that is mainly due to the fact
that this is in the browser.

There are three ways to debug:

- Debug with Visual Studio
- Debug with browser
- Debug with Console.WriteLine

**Visual Studio:**

If you want the ability to debug with Visual Studio, you need to add a Nuget.

````
<PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly.Server" Version="9.0.5"/>
````

And on the `launchsettings.json` you need a specific setting:

````
"inspectUri": "{wsProtocol}://{url.hostname}:{url.port}/_framework/debug/ws-proxy?browser={browserInspectUri}",
````

Be sure to update Visual Studio. Debugging WASM components is not very consistent,
and updates might fix issues that are present.

[NOTE]
====
You need Chromium-based browsers for debugging (at least with Rider), and so, even
with Visual Studio let's aim at that.
====

Configuring it was a hassle, but basically, on Rider you can press `Ctrl + Alt + S`,
and you will get a screen for settings, search for "Browser", and in there you can
configure what browser Rider will launch. The trick is to select the one that has
Google Chrome selected, and then just changing its path to `google-chrome-stable`,
depends on the setup but if you get an error stating that `google-chrome` doesn't
exist or whatever. Then yeah search in `/usr/bin/...` and see what's the name of the
Google Chrome executable.

After launching debug on the **MAIN** WASM project, we should get Chrome launching,
and breakpoints working. (We will even see a small message before the page loads stating
that the debugging is syncing or whatnot).

On the first load of the page, the proxies need to load first, so wait a bit until
they all initialize, and after they are up and running, try to interact with the
page and then check if breakpoints work. Under the hood, there's a proxy between
the browser and Visual Studio **NEVER FORGET THIS SPECIFIC PIECE OF INFO**.

If the first approach doesn't work, try to debug the second approach:

Which doesn't actually work, it involves launching Chrome with a specific setting
and stuffs. And apparently you can debug with the browser "Sources" tab. But...
I can't even see the source files listed, so Idk dude. Blazor, Blazor, Blazor. You
don't really make it easy to love you.

==== Other Differences

- Authentication
- Accessing Data

These are major differences depending on the interactivity type. So we will
cover them in their own separate sections.

=== Data Access for SSR or Server Interactivity

==== Overview of accessing DB from SSR or Server Interactivity

When we run SSR or Server Interactivity, the code that is running on the server
can access directly the database.

WebAssembly has the C# code running in the browser, meaning the code will have to
deal with an API most of the time.

We will use EF Core to access data from the server.

==== Add NuGet Packages for using EF Core

We will start by installing a couple of packages on the Server Interactivity project:

- EntityFrameworkCore (Don't forget to not apply the preview versions, at the time
of writing the project is on .NET 9, so install .NET 9 versions). With this set of
APIs you can target tons of different databases. But this are the base APIs.
    - This is an ORM. E.g., Two tables, with a relationship, that representation
    can all be mapped to memory with classes (on an application). The ORM maps
    classes to tables. You can run database migrations by having the database
    representation in the APP and then recreating all of that structure but on
    the actual database service.
- EntityFrameworkCore.SqlServer = This allows us to access APIs that target SQLServer.
- EntityFrameworkCore.Design = Migrations 
- EntityFrameworkCore.Tools = Migrations
- Get SQL Server Management Studio (Windows Only)
- There used to be a cross-platform solution. Azure Data Studio. But it seems it's
getting destroyed:
    - https://learn.microsoft.com/en-us/azure-data-studio/download-azure-data-studio?tabs=linux-install%2Cwin-user-install%2Credhat-install%2Cwindows-uninstall%2Credhat-uninstall
    - https://learn.microsoft.com/en-us/azure-data-studio/whats-happening-azure-data-studio?tabs=dev
- Rider seems to have integrations with SQL Server though I will try that.

Don't forget to start the docker service, and then run docker commands as sudo:

- sudo systemctl start docker
- sudo docker <COMMAND>

But you know the drill, let's start a container for a dev instance we can work on,
since the course will use this database:

````
docker run -e "ACCEPT_EULA=Y" \
           -e "SA_PASSWORD=12345678" \
           -p 1433:1433 \
           --name sql2019-dev \
           -d mcr.microsoft.com/mssql/server:2019-latest
````

- Extra = Because I'm on Linux, and want to move away from proprietary stuff,
I won't use Docker Desktop, but a container alternative called portainer:

````
docker volume create portainer_data && \
docker run -d \
  -p 8000:8000 \
  -p 9443:9443 \
  --name portainer \
  --restart=always \
  -v /var/run/docker.sock:/var/run/docker.sock \
  -v portainer_data:/data \
  portainer/portainer-ce:latest

````

Once you log-in be sure to create a user and password:

- admin
- admin12345678

I don't know what the hell happened, but I didn't get hit with a screen that
lists the environments. But you should, if not, click the Big Logo. You can
then click on "Live Connect" and with that you should get access to all the GUI
elements that inform you about the health of your docker instance.

**GOING BACK TO THE MAIN TOPIC**

The biggest selling point about doing a Code-First approach, and that it what
we'll do, is that the moment you update a class, add something for the database
representation in code, you can run a migration and have that change replicated
on the database side.

==== Create DBContext

Code-first, databae schema will be in code. We will run a migration, and we will
generate the databae.

Under `Data > ServerManagementContext`:

[source, csharp]
----
using Microsoft.EntityFrameworkCore;
using ServerManagement.Models;

namespace ServerManagement.Data;

public class ServerManagementContext : DbContext <.>
{
    public DbSet<Server> Servers { get; set; } <.>

    protected override void OnModelCreating(ModelBuilder modelBuilder) <.>
    {
        base.OnModelCreating(modelBuilder); <.>

        modelBuilder.Entity<Server>().HasData( <.>
            new Server { Id = 3, Name = "Server3", City = "Toronto" },
            new Server { Id = 3, Name = "Server3", City = "Toronto" },
            new Server { Id = 4, Name = "Server4", City = "Toronto" },
            new Server { Id = 2, Name = "Server2", City = "Toronto" },
            new Server { Id = 5, Name = "Server5", City = "Montreal" },
            new Server { Id = 6, Name = "Server6", City = "Montreal" },
            new Server { Id = 7, Name = "Server7", City = "Montreal" },
            new Server { Id = 8, Name = "Server8", City = "Ottawa" },
            new Server { Id = 9, Name = "Server9", City = "Ottawa" },
            new Server { Id = 10, Name = "Server10", City = "Calgary" },
            new Server { Id = 11, Name = "Server11", City = "Calgary" },
            new Server { Id = 12, Name = "Server12", City = "Halifax" },
            new Server { Id = 13, Name = "Server13", City = "Halifax" });
    }
}
----
<.> We can separate code based on domain, concern or many other criteria. But in short,
we can create multiple contexts and have them inherit `DbContext` so that we get
access to tons of overrides and stuffs that dynamically (under the hood) run and
start talking to our actual backing service (database).
<.> We always work in a model of `DbSet` this represents a table and its records.
We will actually re-use our `Server.cs` class that we created before for our static
repository approach.
<.> If we want to seed data, we can use the `OnModelCreating` method it receives
an object that we can use for multiple use cases.
<.> Don't forget to run the base methods, Blazor might be one thing, but things such
as EF actually have important logic on them.
<.> As mentioned before, this parameter has an API that allows us to do tons of
things to the database, we can establish reltionships, constraints, etc. But in our
case we just want to seed, `HasData` is used for that and you can feed both a list
or just consequent initialization variables. By convention it will try to map to
the primary key a property like: `<ENTITY-NAME>Id`. We have a `ServerId` prop which
means we shouldn't get any weird errors or stuffs.

==== Configure connection strings and run migration

Now that we have architected the Code First code. We will connect to the database
now.

[NOTE]
====
So apparently the password for the server needs to follow this:

ERROR: Unable to set system administrator password: Password validation failed.
The password does not meet SQL Server password policy requirements because it is
not complex enough. The password must be at least 8 characters long and contain
characters from three of the following four sets: Uppercase letters, Lowercase
letters, Base 10 digits, and Symbols..
====

My choice (of course for testing purposes): `Str0ngPassw0rd@`

After that you can use either client to connect, just remember the basics:

Server=localhost;user=sa;password=Str0ngPassw0rd@ (THIS CONNECTION STRING WORKS
FINE IN RIDER.)

(Port by default is 1443).

Trust the server certificate, encryption can be set as optional.

Once we connect to the database we won't have the ServerManagement database yet.
So now, how do we populate our Database?

**Connection Strings: ** A string to embed into our project the way to connect
to the database.

_NOTE:_ The course uses some GUI thing in Visual Studio to generate the connection
string. Let's **NOT**, okay? Keep it Simple.

We know a good practice is to keep configurations external, and .NET has that
requirement already figured out:

````
"ConnectionStrings": {
  "ServerManagement": "Data Source=localhost;Initial Catalog=ServerManagement;User ID=sa;Password=Str0ngPassw0rd@;Trust Server Certificate=true"
},
````

Reading plain text makes pretty evident what's going on. Only thing worth of note
is that `Initial Catalog` is the property that allows us to set the database name,
and for our specific local dev container powered env, the user by default is `sa`,
and the password is what we mentioned before.

After we have setup these things, we can go and configure some DI Container stuff
to start integrating with the DB.

You would normally just do something like this:

````
builder.Services.AddDbContext<ServerManagementContext>();
````

But there's an issue with this code. **EF Is not Thread Safe**. And when adding
the context like this, it is created as `Scoped` by default. Meaning that the instance
will only live as long as the SignalR channel lives. You are bound to run into
concurrency issues, multi-threading will be blocked from your tool of options (unless
you want to live with nasty issues in prod) due to our Server Interactivity nature.

So we will leverage a different method:

````
builder.Services
    .AddDbContextFactory<ServerManagementContext>(options =>
        options.UseSqlServer(builder.Configuration.GetConnectionString("ServerManagement")));
````
This can help us creating contexts that are not as short-lived, and in turn are
safer. On top of that we will now connect to the connection string we added to
our `appsettings.Development.json`. We will leverage the `UseSqlServer` extension
and we will then leverage the `builder.Configuration` object and its method that
automatically will look at the `ConnectionStrings` properties, and then depedning
on the key it will retrieve the respective value that we configured.

After this, we need to go back to our context class and somehow also wire it up
so that it will start talking to the database, we don't have to re-invent the wheel,
the tools are there for us to leverage:

````
public ServerManagementContext(DbContextOptions<ServerManagementContext> options) : base(options)
{
}
````

In here, we can simply call the constructor, receive an `options` parameter,
and then pass it down to the base class' constructor. Under the hood this will
initialize things and connect to the database and start integrating seamlessly.

And now, we will run commands, but all on GUI. NO IDE MAGIC.

. `dotnet tool install --global dotnet-ef` = Install the tool.
. Navigate to the project directory: `cd path/to/ServerManagement`
. dotnet ef migrations add Init --project ./ServerManagement.csproj --startup-project ./ServerManagement.csproj
. dotnet ef database update

[NOTE]
====
If you get an error such as:

````
Unable to create a 'DbContext' of type 'ServerManagementContext'. The exception
'The seed entity for entity type 'Server' cannot be added because another seed
entity with the same key value for {'Id'} has already been added. Consider using
'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see the conflicting key
values.' was thrown while attempting to create an instance. For the different
patterns supported at design time, see https://go.microsoft.com/fwlink/?linkid=851728
````

This means that there's an instance with the same Id, and hence the migration can't
be applied, so check the seeding code DUDE!
====

[NOTE]
====
More errors:

An error was generated for warning 'Microsoft.EntityFrameworkCore.Migrations.PendingModelChangesWarning':
The model for context 'ServerManagementContext' changes each time it is built.
This is usually caused by dynamic values used in a 'HasData' call (e.g. `new
DateTime()`, `Guid.NewGuid()`). Add a new migration and examine its contents to
locate the cause, and replace the dynamic call with a static, hardcoded value.
See https://aka.ms/efcore-docs-pending-changes. This exception can be suppressed
or logged by passing event ID 'RelationalEventId.PendingModelChangesWarning' to
the 'ConfigureWarnings' method in 'DbContext.OnConfiguring' or 'AddDbContext'.

We configured our class to have a Random number decide if the server is Online or
not. **DELETE THAT CODE** That's bad code dude.
====

Once that's done, be sure to delete the `Migrations` folder. And run the commands
again, everything should run smoothly.

Also, Rider's database integration is kinda weird. It doesn't update with the new
database, so just "try to create the same database" it will error saying it
exists, and it will finally show up. Be sure to select to connect to the default
schema `dbo` and with that, you should be able to connect to the local SQLServer
instance and start querying and stuffs, if we query our Servers table we should
get the 10 seeded records we configured. _Cool, cool_.

If we know go back and analyze a bit further, what happened under the hood, was
that a migrations file was created under `Migrations/` this file actually is auto-generated
code with two main methods:

- Up = Method with all sorts of code to apply mutations that change the schema
of the database
- Down = All sorts of changes that undo some structure on the database

[NOTE]
====
By default, there will always be a metadata migrations table created by EF Core,
so don't panic if you see an underscore prefixed table you didn't expect.
====

Also, you can choose to run a specific migration by specifying its name directly,
since we created a migration called `Init` we can run a command such as `dotnet ef
database update Init`. And it will try to run the migration, and after refreshing
the database state, we should be seeing the rows and all just like before.

==== Implement the ServersEFCoreRepository

Up until we now we have been working with a static data repository (in-memory),
however, since we are now going to integrate with SQL Server, we will swap it out
with an actual database connecting repo. (We can definitely apply patterns here and
interfaces to make the swap painless, but well, the course is Blazor focused, not
backend focused so we will go a bit ugly with it).

`ServersEFCoreRepository` => Apparently this should be an abstraction that could
connect to any database.

And so we will start creating methods on our repository:

[source, csharp]
----
namespace ServerManagement.Models;

public class ServersEfCoreRepository(IDbContextFactory<ServerManagementContext> contextFactory) <.>
{
    public async Task AddServerAsync(Server server) <.>
    {
        await using var db = await contextFactory.CreateDbContextAsync(); <.>
        db.Servers.Add(server); <.>

        await db.SaveChangesAsync(); <.>
    }

    public async Task<List<Server>> GetServersAsync()
    {
        await using var db = await contextFactory.CreateDbContextAsync();
        return await db.Servers.ToListAsync(); <.>
    }

    public async Task<List<Server>> GetServersByCityAsync(string city)
    {
        await using var db = await contextFactory.CreateDbContextAsync();

        return await db.Servers
            .Where(x => x.City != null && x.City.Equals(city, StringComparison.OrdinalIgnoreCase)) <.>
            .ToListAsync();
    }

    public async Task<Server?> GetServerByIdAsync(int id)
    {
        await using var db = await contextFactory.CreateDbContextAsync();

        return await db.Servers.FirstOrDefaultAsync(x => x.Id == id); <.>
    }

    public async Task UpdateServerAsync(int serverId, Server? server)
    {
        if (server is null) <.>
        {
            throw new ArgumentNullException(nameof(server));
        }

        if (serverId != server.Id)
        {
            return;
        }

        await using var db = await contextFactory.CreateDbContextAsync();
        var serverToUpdate = await db.Servers.FindAsync(serverId); <.>

        if (serverToUpdate is null)
        {
            return;
        }

        serverToUpdate.IsOnline = server.IsOnline;
        serverToUpdate.Name = server.Name;
        serverToUpdate.City = server.City;
        await db.SaveChangesAsync(); <.>
    }

    public async Task DeleteServerAsync(int serverId)
    {
        await using var db = await contextFactory.CreateDbContextAsync();
        var serverToDelete = await db.Servers.FindAsync(serverId);
        
        if (serverToDelete is null)
        {
            return;
        }
        
        db.Servers.Remove(serverToDelete); <.>
        await db.SaveChangesAsync();
    }

    public async Task<List<Server>> SearchServers(string serverFilter)
    {
        await using var db = await contextFactory.CreateDbContextAsync();

        return await db.Servers
            .Where(x => x.Name != null && x.Name.ToLower().StartsWith(serverFilter.ToLower())) <.>
            .ToListAsync();
    }
}
----
<.> We will leverage primary constructors to make the DI cleaner.
<.> We will leverage async methods, since a database call is technically a thread
blocking operation that can be optimized with async programming.
<.> We will use a special syntax also for an unmanaged resource with `await using`.
And in here notice how we are actually leveraging the factory so that we get a short-lived
instance of the context. With `using` the moment the variable is out of scope (so
after the method is executed) then the resource is disposed of for us. Becase EF
is not **thread safe** we should apply this pattern to avoid concurrency issues.
<.> This is the typical pattern with EF, in which we "make operations in-memory".
<.> And lastly to persist the changes we are going to do to the database, we run
a `SaveChangesAsync()`.
<.> We should also leverage async retrieval of the records of the database. Also,
`ToListAsync` is used here so that the SQL Statement takes place at this point in
time, so we make a query to the database.
<.> The course uses a really old way of finding and comparing and using an int
as a comparison value, but I am pretty sure that modern EF supports the equals with
this culture parameter so we should be fine.
<.> We are returning if we find a record, if not it will return a `null`, course returns
a "default" object, which I don't agree with.
<.> These checks should not be here, I think **mixins** could be applied here.
<.> And yeah, we can directly feed an int to match to a primary key and then
retrieve that record in memory and do whatever we want with it.
<.> After we make all the changes we want in memory, we can just hit the database
to perform an update.
<.> We can directly remove an object of the collection and then apply the query
with a `Save`, under the hood EF Core will attempt to match the record that has
to be queried for deletion at the DB level.
<.> This is the correct way to convert to SQL with EF a starts with, the IDE can
even suggest to do something else, **DON'T**. This is convertible, and should be
fine.

==== Use the plugin based repository

We will now swap the old repository with the new repository that talks to the
database.

The course leverages what is "Extracting an interface". I know Rider has this,
but maybe with the way I wrote the class it messes up and it doesn't show up. Anyway
I leveraged its built-in AI to generate the interface so that I can just copy-paste
it into an interface file:

[source, csharp]
----
namespace ServerManagement.Models;

public interface IServersEfCoreRepository
{
    Task AddServerAsync(Server server);
    Task<List<Server>> GetServersAsync();
    Task<List<Server>> GetServersByCityAsync(string city);
    Task<Server?> GetServerByIdAsync(int id);
    Task UpdateServerAsync(int serverId, Server? server);
    Task DeleteServerAsync(int serverId);
    Task<List<Server>> SearchServers(string serverFilter);
}
----
And you can easily put that under `ServersEfCoreRepository` for implementation.
And with that we should be fine.

_A bit of theory:_ Why are we adding this layer with an interface? Basically because
we want to apply the **plugin based architecture pattern**.

This basically states that we should design and implement things around **Interfaces**,
and that is because the implementation details should live outside of the application,
we don't couple our modules to implementation types or details. We simply wire that
up somewhere else, yet other teams, other projects can design the implementations following
the contract established and we can simply swap out things, loose coupling becomes
king in this sense.

The course states that this could live in another project, but we won't go that
far for this course. Also it says it follows _Clean Architecture_ with _Use Cases_.
And it is project-based. I know this.

UI will only leverage the interfaces, it won't be coupled to implementations this
way.

And so the last piece of the puzzle:

````
builder.Services.AddTransient<IServersEfCoreRepository, ServersEfCoreRepository>();
````

We will leverage DI to resolve this service in the consumer side. And it should be
`Transient`. Why? Because this is a stateless, lightweight type of service, the
backing service (database) is always there, and this is an interface into it. Transient
is created the moment it's requested for DI and dies the moment it goes out of scope.
(Typically when the requesting class gets garbage collected). And so, we want for the
service to live as little as possible, hence we are registering as so.

And here comes two things:

- The course suggests we replace all the calls to the static store manually. This
wastes so much time, and in real life applications it's unacceptable. Hence **always
design around interfaces from the start, tech debt otherwise creeps in pretty hard
the more the project grows**.
- The course used sync methods, I prefer the more performant async methods, but that
comes with a price, async gets replicated all across the code, if one thing is
async, all other things must be async, hence tech debt hits you even harder.

But in short the process is:

. Inject the interface at the component level, better to call it the same name as
what the static repo had so that you swap out the name easily
. Turn all calling methods to the repo's methods async, and adjust with `await`
accordingly
. Clean up everything to start using the SQLDatabase repo (EF Core) and fix any
compilation issues

[NOTE]
====
Also making a big change that changes tons of code is also extremely dangerous,
I wouldn't even try to make a single commit with so many changes as the course
suggests.
====

One interesting thing that I ran across and implemented:

[source, csharp]
----
private List<Server>? _servers; <.>

protected override async Task OnAfterRenderAsync(bool firstRender) <.>
{
    if (!firstRender)
    {
        return;
    }
    _servers = await ServersRepository.GetServersAsync();
    StateHasChanged();
}
----
<.> This used to initialize in-line. But when injecting and initializing with
a server we can no longer do that.
<.> Hence (because we have set the app to be InteractiveServer), we should leverage
`OnAfterRender` as the place to initialize our things.

After changing anything and running the app. We should still have the same user
experience. With the difference that populating the list of servers might be
a bit different now, since we now rely on a backing service, and it takes a bit
longer to get data from there than an in-memory list.

Found bugs within the code, also the one thing I called out ages ago, about how
the list's "Turn On/Off" button worked because we were in-memory came up now. We
never updated the actual state.

````
return await db.Servers
            .Where(x => x.City != null && x.City.ToLower() == city.ToLower())
            .ToListAsync();
````
Course was right, we need this "old-school" type of comparison so that EF Core
can translate this correctly.

On `Servers.razor` I had to fix it:

````
protected override async Task OnAfterRenderAsync(bool firstRender)
{
    if (!firstRender)
    {
        return;
    }

    if (NavigationManager.Uri.Contains("back-from") && string.IsNullOrWhiteSpace(PreviousCityName)) <.>
    {
        return;
    }

    CityName = PreviousCityName ?? "Toronto"; <.>

    var torontoServers = await ServersRepository.GetServersByCityAsync(CityName);

    TorontoOnlineServersStore.SetNumberOfOnlineServers(torontoServers.Count(x => x.IsOnline));

    StateHasChanged();
}
````
<.> This had to be a `&&` because only when we hit the `back-from` workflow and
we don't provide a `PreviousCityName` is that we shouldn't attempt at retrieving
something.
<.> And in here we should fallback into `Toronto` for the use case in which we
are just getting to the page for the first time.

And the fix for the list's turn on/off button:

````
var status = Server.IsOnline = !Server.IsOnline;
        await ServersRepository.UpdateServerAsync(Server.Id, Server);
````
We don't just work with the in-memory representation, we have to make a query to
the database.

After all these changes, we should be seeing how the database gets updated. How
the use cases should still behave the same and everything.

=== Data Access for Blazor with WebAssembly Interactivity

==== Access DB from WebAssembly
