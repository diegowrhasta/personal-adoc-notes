= Introduction

https://gsap.com/[GSAP] is a JavaScript animation library built for professionals.

== Getting feet wet

They have their own https://gsap.com/resources[Docs] that you can look through for
tons of insightful and highly produced learning resources. GSAP used to be **paid**,
hence its support is quite strong. It's after a buyout that it became free for
the World Wide Web.

Since I want to leverage this in a React app, we can have a look at their React
tutorial:

https://www.youtube.com/watch?v=l0aI8Ecumy8[Youtube Tutorial]

== GSAP for React

GSAP is framework agnostic. However React can be paired up with it, the idea of
GSAP is to _imperatively animate anything_. DOM transitions, SVGs, Three.js, Canvas,
WebGL. The limits _are on your mind_.

However, there are pain points when trying to pair **GSAP** with **React**.

It is due to the pain points that the GSAP team made a React hook specifically to drop
into a React component, it's a replacement for `useEffect()` or `useLayoutEffect()`,
`useGSAP()` will handle all sorts of cleanup automatically. It can be used on _SSR_,
you can scope animations to specific containers and state also can be the trigger
of an animation.

So, there's tons of things that had to be implemented manually before the hook was
created by _GSAP_, in short, lots of ugliness, due to the fact that React has
`useEffect()` and things get called twice, and sometimes animations stuck around
still taking memory. The main idea is to always clean animations to avoid **memory
leaks**. The ugliness has been simplified (abstracted) away so that you get clean
code that cleans up for you in the background:

[source, code]
====
import { useRef } from 'react'
import gsap from 'gsap'
import { useGSAP } from '@gsap/react'

const box = useRef()

useGSAP(() => {
	gsap.to(box.current, { x: 360 })
})
====

== GSAP Basics

[NOTE]
====
I learned the hard way that `basics` are king. (By learning Japanese the wrong way).
So I know that it's best to start small, bit by bit, perhaps by doing "boring"
stuff first. But with a clear goal in mind, and specifically taking whatever you
can get (and leaving behind whatever doesn't feel as useful).
====

And so, this is a really basic introduction to how GSAP works, concepts, lingo,
and ideas to start with to then start actually animating whatever we want to
animate.

=== What is GSAP?

GSAP stands for _GreenSock Animation Platform_. This is a suite of tools (with
lots of backing and rewards) that help you animate practically everything with
JavScript. **In any framework**. The _core library_ has everything one should need
to create **blazingly fast**, cross-browser, friendly animations. This platform
has also tons of **plugins** which help with different (and specific) animation
challenges. (_You don't have to learn all of them mandatorily_)

=== GSAP in React

There are specific things to React, but to start with basics, we need to install
the specific **React package** from `GSAP`.

``` 
pnpm install gsap @gsap/react
``` 

It's after this that we can start making our first animation:

[source, typescript]
----
import { useRef } from 'react'

import gsap from 'gsap' <.>
import { useGSAP } from '@gsap/react' <.>

import './App.css'

gsap.registerPlugin(useGSAP) <.>

function App() {
  const container = useRef(null) <.>

  useGSAP(() => { <.>
    gsap.to('.box', { x: 200 }) <.>
  }, { scope: container }) <.>

  return (
    <>
      <div ref={container}> <.>
        <div className='box green'></div> <.>
      </div>
    </>
  )
}

export default App

----
<.> We have to import `gsap` manually in order to make the registration later.
<.> The magic hook that takes care of cleanup is `useGSAP`.
<.> A good practice is to register the hook in order to avoid React version
discrepancies
<.> In modern React versions we need to provide something to `useRef()` hence we
initialize it as null, as the component gets rendered the reference ends up
attached without issues.
<.> As any hook we should use this in place of a `useEffect()`.
<.> And now, all code that we write inside of the hook should be really similar
to anything we get in the docs (both for React and for the simple HTML versions)
<.> We can provide a specific scope so that the animations only get activated
from that specific container.
<.> It's really important to provide a parent container when it comes to the reference
that we attach with `useRef()`, **because when setting up this way GSAP will look
inside of this element**. So if we were to directly use the reference to the `.box`
element, nothing would move since inside of it there's nothing.
<.> This is the actual element we want to animate, and so by making parallels to
what's inside the `useGSAP` hook we can see that this element is selectable through
its `.box` class name.

If we were to reload the page, we should see how our green box is actually being
moved around based on what we fed to GSAP, he then takes care of the rest.

[NOTE]
====
It's best to use the global styles and the styles that the examples the GSAP
docs provide so that we bootstrap and get to the actual thing we are interested
in. (Which is not styling).
====

=== Animation Basics

A single animation is called "tween".

The basic example's tween:

[source, typescript]
----
gsap.to(".box", { x: 200 })
----

Is actually saying gsap to: _gey GSAP, animate the element with a class of '.box'
to an x of 200px (like `transform: translateX(200px)`)_

And so, the anatomy of the syntax you can separate it into three components:

to:: This is a `method`
".box":: This is a `target`
{ x: 200 }:: This is a `vars object`

All of these three parts contain information in regards to the animation (_tween_).

=== Types of tweens

There are four types:

`to`:: Most common type of tween. A `.to()` tween will start at the element's current
state and **animate "to" the values defined in the tween**.
`from`:: Like a backwards `.to` where it **animates "from" the values defined in
the tween** and ends at the element's current state.
`fromTo`:: **You define _both_ the starting _and_ ending values**
`set`:: **Immediately sets properties** (no animation). It's esentially a zero-duration
`.to()` tween.

A simple way to use them would be as so:

[source, typescript]
----
useGSAP(
        () => {
            gsap.to('.box', { x: 200 })
            gsap.to('.to-circle', {
                duration: 1.1,
                ease: 'none',
                x: 40,
                fill: '#00bae2',
            })
            gsap.from('.from-circle', {
                duration: 1.1,
                ease: 'none',
                x: -40,
                fill: '#00bae2',
            })
            gsap.fromTo(
                '.fromTo-circle',
                { x: -40, fill: '#00bae2' },
                { duration: 1.5, ease: 'none', x: 40, fill: '#0ae448' }
            )
            gsap.to('.set-circle', { x: 40, fill: '#00bae2' })
        },
        { scope: container }
    )
----
As you can see, we are following the same principle of calling a method, and then
selecting an element through _some form of selection that in this instance is
its class name_, and then passing down a configurations object so that the **tween**
can be shaped into something we want. 

A key concept to bear in mind here is that we need to be aware of the **initial
state** of the element. This is what dictates how each of the `tween`s will make
it look when it's animated. So **never forget how it starts**.

==== The target (or targets)

We need to tell GSAP **what** we want to **animate**. Under the hood GSAP uses
`document.querySelectorAll()`, so for HTML or SVG targets we can use selector text
like `.class` and `#id`. Or you can even pass a variable and/or array.

[source, typescript]
----
// use a class or ID
gsap.to(".box", { x: 200 });

// a complex CSS selector
gsap.to("section > .box", { x: 200 });

// a variable
let box = document.querySelector(".box"); <.>
gsap.to(box, { x: 200 })

// or even an Array of elements
let square = document.querySelector(".square");
let circle = document.querySelector(".circle");
                                      
gsap.to([square, circle], { x: 200 }) <.>
----
<.> So you can manually query for the HTML element, and then pass the reference
(saved under a variable) to `gsap`.
<.> You can also query multiple elements in the DOM, and all of them be passed
down and run under a specific set of `tween` options.

==== Variables

The vars object contains all the information about the animation. These can be
arbitrary, or _special properties_ that influence the behavior of the animation
- like `duration`, `onComplete`, `repeat`.

[source, typescript]
----
gsap.to(target, {
  // this is the vars object
  // it contains properties to animate
  x: 200,
  rotation: 360,
  // and special properties
  duration: 2
})
----

So, **what can you animate?**.

[IMPORANT]
====
Basically, **_anything_**. This includes CSS properties, custom object properties,
even CSS variables and complex strings. However, _the most commonly animated
properties are `transform` and `opacity`.
====

[NOTE]
====
Transform's are a web animator's best friend. They can be used to move elements
around, scale them up and spin them around. Transforms and opacity are also very
performant because they don't affect layout, so it's less work for the browser.

When possible, using transform and opacity is better than layout properties like
"top", "left", or "margin". You'll get smoother animations.
====

==== Transform shorthand

As explained, transform and opacity are amazing tools for animating, and so
`gsap` is built under that premise, everything that you might pass to the _vars
object_ it is analogous to the underlying css capabilities.

E.g., `transform: rotate(360deg) translateX(10px) translateY(50%);`, would be
easily translated to `{ rotation: 360, x: 10, yPercent: 50 }`. There's a whole
table that can give you a better insight at the https://gsap.com/resources/get-started#transform-shorthand[docs],
but in short, anything you know/want to do with CSS can be replicated with `gsap`.

[NOTE]
====
By default, `gsap` uses `px` and `degrees` for transforms but you can use other
units like, vw, radians or even do your own JS calculations or relative values.

[source, typescript]
----
x: 200, // use default of px
x: "+=200" // relative values
x: '40vw', // or pass in a string with a different unit for GSAP to parse
x: () => window.innerWidth / 2, // you can even use functional values to do a calculation!
  
rotation: 360 // use default of degrees
rotation: "1.25rad" // use radians
----
====

=== More things to animate

==== CSS properties

==== SVG attributes

==== Any numeric value, color, or complex string containing numbers

==== Canvas

=== Special Properties

=== Repeats and alternating repeats

=== Delays

== Text Animations

== Scroll Animations
