= Introduction

These are notes in regards to Architecture Testing. A simple type of Unit Testing
that brings project security in a different form.

== Code

I have setup a small project in order to test different patterns that can be useful
when doing Architecture testing for DOTNET:

https://github.com/diegowrhasta/archunit-dotnet[Github]

== Background

The more you do software development, the more you realize that this is hard
subject, and even harder career to really establish yourself with. This isn't
related to one's mental capacity whatsoever, but there are so many variables you
have juggle with that sometimes we tend to forget to keep things in check, and
more often than not, you always end up with the typical tale pattern that's as
old as time:

[quote, A disillusioned developer]
____
_Dev:_ Man, I can't wait to start this new project with a really beatifully crafted design
both for folder structure, but also from the very Architectural and inception
decision.

_> Months pass_

_> Dev leaves for another company_

_> Dev comes back after a while_

_Dev:_ Can't wait to see how my _baby_ has been treated after all these years?

_Dev:_ Wait, why have all the decisions and designs that I so carefully documented not
being followed? Why are there all these files in this folder? This doesn't make any
sense, I explicitly stated that we should be relying on interfaces and yet here
they are making the code harder to maintain with all the coupling in these
instances started at the constructor? Please stooooop.
____

There used to be a time in which I thought I had to have all the rules, all the
knowledge ingrained into my brain and to always apply that in Code Reviews, and
when designing new solutions. But that's, (imo) _still a junior speaking_. In
the real world, we don't have the luxury of time, nor the luxury of dealing with
some really small application that we can wrap our head around with easily.

And so, as **software developers**, we _should_ make good usage of our own skills.
Our own abilities. And that is **_writing software_**. We can automate tasks,
we can automate so many things with the right mindset, with the right goal in mind.
And so, _assuming the theory of unit testing/integration testing_. We know that
tests are a great way to document code, to add a safety net to everything we did
so that we try to minimize pushing code with bugs or weird edge cases lurking in the
shadows ready to strike whenever we lower our guard.

=== Architecture Testing

And that's how we land on a simple idea: _Why don't we document our folder structure/
architecture on top of keeping everyone in check in case they didn't follow the fules_?_
And that's when we can write a simple test suite, that will solely focus on scanning
the whole project/solution and check all the code written against our architecture
rules.

- _You wrote a Feature/Service/Business Logic class in the wrong folder?_
	- The test will blow up and immediately tell you to **FIX THAT**
		- The seniors won't have to spend time telling the juniors about how they
		need to refactor _this or that_, they delegate that **to the test**, **the test**
		is now the senior keeping in check of people going rogue.
- _You made a project reference from one layer to another even though that should
be illegal and you will create this tech debt that will go unnoticed until it is
too late?_
	- The test will tell you **STOP**.
		- So that one _small decision_ that someone made because they didn't know,
		or because they thought they knew better, will be policed automatically.

=== Value

And so, with this simple idea in mind, we can offload work that otherwise would
overwhelm people, specially in big projects when there's a lack of time, a lack
of motivation and our dreams can end up crushed because we wanted to do _amazing
software_. The way the **Gang of Four** intended, but reality often had other _plans_
for us.

This repo is .NET focused, but the underlying concepts, specially for the different
architectural patterns I think can be useful to anyone, the idea is to establish
a well researched and accurate set of rules, and stick to them, _and making the
tests being the autoamted policeman enforcing them_.

== Clean Architecture

The Clean Architecture pattern (and for our purposes, folder structure pattern),
stays that there are 4 layers to an application

- Domain/Core
- Application
- Infrastructure
- WebUI / Client

There are tons of other ideas and theory for them but we will simplify rules according
to our technical concerns and needs:

The **Golden Rule** states that dependencies should flow **_INWARDS_**. That means,
we should have a dependency tree as such:

WebUI -> Infrastructure -> Application -> Domain/Core

image::assets/clean-architecture-diagram.png[]

We should **NEVER** have dependencies that flow the other way:

- Domain/Core -> Application

Having such a project reference should be _forbidden_.

This is but one clear example of the rules that the pattern states and what we
should code to be enforced. Of course we will add the different uses cases and concepts
further down, but this is the idea.

=== Layer Dependency Check

As stated in the example, we want to make sure that the 4 layers have dependencies
flowing inwards, nothing more than that. And so, we can write some tests:

[source, csharp]
.LayerDependencyTests.cs
----
using ArchUnitNET.Domain;
using ArchUnitNET.Loader;
using ArchUnitNET.Fluent;
using ArchUnitNET.xUnit;
using static ArchUnitNET.Fluent.ArchRuleDefinition; <.>

namespace Wan.ArchUnitTests.CleanArchitecture.Tests;

public class LayerDependencyTests
{
    private static readonly System.Reflection.Assembly CoreAssembly =
        System.Reflection.Assembly.Load("Wan.ArchUnitTests.CleanArchitecture.Core"); <.>

    private static readonly System.Reflection.Assembly ApplicationAssembly =
        System.Reflection.Assembly.Load("Wan.ArchUnitTests.CleanArchitecture.Application"); <.>

    private static readonly Architecture Architecture =
        new ArchLoader().LoadAssemblies(
            CoreAssembly,
            ApplicationAssembly
        ).Build();

    private static readonly IObjectProvider<IType> CoreLayer =
        Types().That().ResideInAssembly(CoreAssembly).As("Core Layer"); <.>

    private static readonly IObjectProvider<IType> ApplicationLayer =
        Types().That().ResideInAssembly(ApplicationAssembly).As("Application Layer");

    [Fact]
    public void Core_Should_Not_Depend_On_Application()
    {
        var rule = Types()
            .That().Are(CoreLayer)
            .Should().NotDependOnAny(ApplicationLayer)
            .Because("Core should not have dependencies on Application layer"); <.>

        rule.Check(Architecture); <.>
    }
}
----
<.> These are all necessary imports that you need in order for all ArchUnit's
utility methods and types to be available to you.
<.> A good pattern is to keep all the assemblies you are referencing in their own
private field, that way you get a variable to reference when loading them later,
but you can also leverage this field to then run a check against it pretty easly.
<.> Another example of referencing, it might be a bit "ugly" since we are using
magic strings here, but we have to make some compromises (and I'm sure there's an
obscure way of doing this with hard types and so on). Also **_big note:_** Be sure
that the `Test` project references all these assemblies that you are trying to
load/resolve. If you don't have them referenced then this line will fail.
<.> As you can see, we can now reference the assembly variable in here and avoid the
usage of magic strings.
<.> It's nice that we can leverage a _Fluent Pattern_ here since it reads better
to us, and allows for all manners of other possibilities. It's nice that we also
get to add metadata to the message like this.
<.> And The moment you have "configured" the rule as you see fit, then you can just
run it with `Check`.

And this is great, the moment any class in `Core` has a declaration to a class in
`Application` the test blows up. (_You can try and verify that if you want_). This
will then keep enforced the design decision of "NO REFERENCES TO THE OUTSIDE". Which
Clean Architecture enforces. Anyone who reads the code, or gets policed will then
retroactively **learn** about this project detail and slowly but surely _start
coding with that in mind_.

[NOTE]
====
Be aware that, ArchUnit is technically a bit `overkill`, specially since we are
doing assembly loading. If you were to run simple unit tests you can get execution
times of _< 50 ms_. But ArchUnit tests are around _250~ ms_. So they are in a way
_slower/heavier_. But you shouldn't really fret over that. Unless you are doing
something **extremely wrong**, tests should still adhere to the principle of
_they should be really fast_.
====

[IMPORTANT]
====
It's also worth noting that whilst, _yes_, we have a set of unit test naming
conventions (https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-best-practices#follow-test-naming-standards[Reference])
when it comes to these _Architecture Tests_ things can turn a bit different in a
way, we don't have methods to test, nor specific conditions. So you _can_ stray
a bit further from these rules with a good reason: _these type of tests are not
really unit tests_, they are **infrastructure tests**.
====

==== Good Patterns

And so, when writing a test, it's best to avoid redundancies, luckily the API from
the library is extremely useful and you can chain things together with `And()`,
and so a _nice looking pattern_ that I came up with can be:

````
var webRule = Types()
            .That().Are(CoreLayer)
            .Should().NotDependOnAny(WebLayer)
            .Because("Core should not have dependencies on Web Layer");
        
        var infrastructureRule = Types()
            .That().Are(CoreLayer)
            .Should().NotDependOnAny(InfrastructureLayer)
            .Because("Core should not have dependencies on Infrastructure Layer");
        
        var applicationRule = Types()
            .That().Are(CoreLayer)
            .Should().NotDependOnAny(ApplicationLayer)
            .Because("Core should not have dependencies on Application layer");

        webRule
            .And(applicationRule)
            .And(infrastructureRule)
            .Check(Architecture);
````
Of course, all the assemblies referenced here were declared previously as private
fields. But I think you can _get it_. We literally compose different rules as
if they were "functions" that in a certain line we just "check", we sort of run
the test after we have declared all the rules that will be checked. This is indeed
a _pretty nice pattern_. What I like the most is that it's quite clean.

And looking at this from the outside, you can easily see how by reading these tests,
you immediately can get a good feeling as to how the project has been structured
and what rules should you follow. (_No broken glasse_).

Thus leading us into the biggest argument that I have when justifying these type
of tests:

[IMPORTANT]
=====
Tests should act as a form of documentation for your application. We have Unit,
Integration tests that will add a safety net and document how the application is
expected to behave. And **Architecture Tests** can now add a layer of documentation
_in the form of code_ as to how the project was laid out, what design decisions have
been made, what to stick to, and it can even open up the possibility to realize
the design might not be the best, and push you to refactor or another iteration
of a better design since tests made you realize that you didn't account for **that
one use case**, or that by looking at this **you are incurring in technical debt**.
=====

_TESTS WERE WRONG:_ After further testing I realized something:

````
var coreRule = Types()
            	.That().Are(WebLayer)
            	.Should().NotDependOnAny(CoreLayer)
            	.Because("Web should not depend on Core");
````
Code such as this one checks: **If NOT EVEN ONE CLASS from Web has a dependency
to Core**. This is good for our check of _no reference whatsoever should be in
sight_. But for our checks of _okay you should have references, or you "can"
at the very least_ this is not good, cuz it will expect for all classes to have
at least one dependency, and that doesn't make any sense (it would push us to
breaking the _Interface Segregation_ principle, referencing things for the sake
of a test).

Hence tests should be slightly adjusted for that:

````
public void Web_Should_Only_Depend_On_Application_And_Infrastructure()
{
    var webRule = Types()
        .That().Are(WebLayer)
        .And().DependOnAny(ApplicationLayer)
        .Should().Exist()
        .Because("Web should depend on Application");
    
    var infrastructureRule = Types()
        .That().Are(WebLayer)
        .And().DependOnAny(InfrastructureLayer)
        .Should().Exist()
        .Because("Web should depend on Infrastructure");
    
    var coreRule = Types()
        .That().Are(WebLayer)
        .Should().NotDependOnAny(CoreLayer)
        .Because("Web should not depend on Core");

    webRule
        .And(coreRule)
        .And(infrastructureRule)
        .Check(Architecture);
}
````
You can see how switching the `Should()` for `And()` on top of then just applying
a `Should().Exist()` allows for our tests to actually test what we intend to test.
