= Introduction

I realized, I might not have the best basics whent it comes to Microsoft SQL.
And so, this is a literal refreshing, and powering up of those skills/knowledge.

The content of these notes will be based around this course:

https://www.udemy.com/course/complete-microsoft-sql-server-database-administration-course/[Udemy Course]

But of course, the idea is to also make my own ideas, investigate even further and
note all those extra bits and pieces that (imo) give a much rounder depth of
knowledge than just limiting yourself to course content.

== Complete Microsoft SQL server Database Administration Course

=== Introuction

Two instructors. They seem to be veterans with 20+ years of experience in IT
plus reputable degrees from good unis.

_Databases are my passio_ and the _Accidental DBA_ bits lead me to believe these
are green flags of the course.

=== Course Overview

Seems we will get a good mix of theory on top of practical stuff. That's good,
since my opinion is always to know your basics/theory well enough so that you
can then apply all of that practically. We are already pretty far away from
what many tutorials and materials used to be just a "copy what I do, and don't
ask questions".

Looking forward to learning interesting concepts on top of actually applying
them. _Besides just basics_. Since, well, I like learning, but also because when
push comes to shove and I need to also help a discussion with extra knowledge
that some might not have at the moment, that's when a difference can be made.
And we can ship things faster, and **get that user need fulfilled**.

=== Introduction to a Database

We know this. But in short.

- Data = Any piece of info that is unstructured but that can mean something
in a certain context (date, age, height, name)
- Databases are a solution to manage large volumes of data easily, with a way
better framework than a spreadsheet, and taking a fraction of size.
- There are powerful concepts in databases such as `joins`, `groups` and many
others. Things that in Excel are not a thing, or trying to replicate is also
way harder.

=== What is RDBMS?

Relational Database Management System.

So, a Relational Database is but **one** type of database. It uses a **structure**
that allows us to **identify and access data** in relation to another piece of data
in the database. Often, data in a relational database is organized into **tables**.

Here's an example of how the data would be organized:

.Employees Table
[cols="1,2,2,1", options="header"]
|===
| ID | First Name | Last Name | Department
| 1  | John       | Smith     | Engineering
| 2  | Maria      | Garcia    | Marketing  
| 3  | David      | Chen      | Sales
| 4  | Sarah      | Johnson   | HR
|===

.Addresses Table
[cols="1,3,2,2", options="header"]
|===
| Employee ID | Street Address       | City       | State
| 1           | 123 Main Street      | Boston     | MA
| 2           | 456 Oak Avenue       | Chicago    | IL
| 3           | 789 Pine Road        | Houston    | TX
| 4           | 321 Elm Boulevard    | Phoenix    | AZ
|===

Now, zooming out of this SQL world. Let's go back to spreadsheets for another example,
you can in theory organize data into _tables_ right? They might look the same,
but their properties are fundamentally different. Excel tables have no inherent
relation between them, and you certainly can't apply operations between tables
that can perhaps refine, extrapolate or summarize the data that both tables
hold. (Can't combine to pull **info** out of **data**).

**_Now going back as to how SQL Tables are different_**

Say, I have the data about employees, and those employees' addresses. What if I ask
the question _How can I get Diego's address_? Well you might have in both tables
a common field such as `ID` or `Employee ID` and by matching that specific piece
of data between the two tables, you can build your way into knowing _Diego's address_.

And so, the course will focus on how to wrap our head around the concept of SQL
tables, and how we can use them to store data, and refine it, and query it, and
overall make it work for us so that really complex pieces of info are structured
in such a way we can understand them (there's logic to them) but also are under
a framework that is extremely powerful when getting information out of data.

=== What is SQL?

Structured Query Language = It's a **programming language** used to communicate with
data **stored** in a **relational database management system**. SQL syntax is similar to
English language, which makes it relatively easy to READ/WRITE/UPDATE/TRANSLATE
data.

_S Q L_ or _Sequel_. Pronounce it either way.

Why is it called like that? It actually was created with the name Structured English
Query Language. And it was named **sequel**. But that was trademarked, and so,
to avoid lawsuits, it was changed to `SQL`.

[IMPORTANT]
====
SQL IS NOT A DATABASE. It is a command line language that many RDBMS use to access
data from tables.
====

Just like in Linux, there are 10K distros, and there are 10K DEs, under the hood,
they are still using `bash` they still share many tooling from what `GNU/Linux`
is.

Similarly, **SQL** has the same concept, this language has been designed specifically
to be used to pull, **query** data from a database. And we have tons of relational
databases out in the market (PostgreSQL, SQLite, MySQL, Microsoft SQL, etc).
_The correct way to define them with a general term is Relation Database Management
Systems_

An example of a statement is: `SELECT * FROM tablename;`. Check this statement out,
it almost reads as english, the idea is to be perceived that way. Later you will
see how there are other words that are _powerful_ operators like `WHERE`, `AND`,
`OR`, `GROUP BY` amongst others.

=== Top 5 RDBMS using SQL

- Oracle DB = Old, one of the biggest database vendor in IT.
- Microsoft SQL Server = Old, amongst the first ones actually, it's consired as
really stable, secure and reliable. It competes against Oracle and IBM DB2.
- MySQL = Swedes, community developed, open-source. SUN Microsystems bought it.
Then Oracle got SUN Microsystems. Even though this is open-source, there are
commercial licenses from Oracle. _Easy to use, inexpensive, reliable, large
community_.
- PostgreSQL = Community developed, open-source, (Successor of Ingres).
- MariaDB = Community developed, open-source, this actually is a fork of MySQL.
Because someone was concerned about the Oracle acquisition. Hence it branched off
and became its own thing. This actually was done by the original people that made
MySQL.

=== Introduction to Microsoft SQL Server

MSSQL = Microsoft Server SQL is a suite of database software published by Microsoft
and used extensively in enterprise world.

- Features:
	- A relational database engine which stores data in tables, columns and rows.
	- Integration Service (SSIS), which is a data movement tool for importing,
	exporting and transforming data.
	- Reporting Service (SSRS), which is used to create reports and serve reports
	to end users.
	- Analysis Sevice (SSAS), which is a multidimensional database used to query
	data from the main database engine.

In this course we will work with MSSQL 16, 19. And work on a Windows Server 2016, 2019.
"machine". Depending on which SQL Server version you decide to use, then you will have to
match the right OS.

Oh yeah we will use the full **Enterprise Version** for both RDBMS and OS. They
have a trial of 180 days (about 6 months). _We should finish the course by then_.

[NOTE]
====
85% of corporate companies around the world use MSSQL 16 or 19, or older, hence this
course will focus around them. (_That way you can have the biggest chances of saying
you know how to work with a version that a potential employer might have a need for_)
====

**SQL Server Management Studio** is an additional software we have to download to
be able to query data, run reports, manage tables and rows, perform backups and
analyze performance charts.

_Note:_ Even though they have a year in their name, they are not actually released
on those years.

The most recent versions are:

- SQL Server 2014
- SQL Server 2016 **
- SQL Server 2017
- SQL Server 2019 **

.Pros and Cons
[cols="2,2", options="header"]
|===
| Various supported versions   |   Expensive Enterprise edition
| Online product documentation |   Difficult licensing process that's always changing
| Microsoft premiere support   |
| On-premises and cloud database support |
| Plenty of tools and applications
| Support for use on Linux
|===

[IMPORTANT]
====
The main idea of the course is not to sell you on Microsoft SQL. But to make you
fluent in SQL. The language that is _more or less_ the universal spoken language by
all the major RDBMS out there. So if you know how to use it to query, filter, manipulate
data, you can easily jump between all the different databases.
====

=== Different editions of Microsoft SQL

- Enterprise Edition = This delivers **high-end data center** capabilities with
**blazing fast performance**, unlimited virtualization, end-to-end business intelligence.
So basically high service levels for mission critical workloads and end-user
access to data insights.
- Standard Edition = **basic data management** and business intelligence database
for departments and **small organizations** to run their applications and support
common development tools for on premise and cloud, it enables effective database
management with minimal IT resources.
- Web = **Low-total-cost-of-ownership** for **web hosting companies**. E-commerce
sites use this a lot.
- Developer = This is basically **Enterprise** but the idea is for testing purposes,
and also learning. You can't use this for production though, if Microsoft gets
word of some company using this for production. You can get easily get sued.
- Express = **entry, free level database** The idea is something small to start
with, Microsoft's idea with this tier is for people to start small, and if things
work out really well, they seamlessly upgrade this edition to the "better ones"
seamlessly.

The idea behind aiming for the **Enterprise Edition** choice of usage, is that
you will get exposed to the full capabilities of the suite that way. Since it has
all the features, and it focuses on the most complex problems, since this is the
_corporate world_ with different needs than small businesses (which are still valid
things to be respected, but the nature of the problems that each organization tries
to solve vary in scope and just overall amount of users).

=== Quiz 1: Introduction

- What is a database?
R: A database is an organized and systematic collection of data generally stored
and accessed electronically from a computer system

- What is the difference between spreadsheet and database?
R: A lot, but databases storage costs are less, and give a way better framework to
work with data so that you can really manipulate and do what you will with it.

- What is a difference between database and relational database?
R: DBMS store data as file whereas RDBMS stores data in a tabular form, AND In
database the data elements need to access individually and in RDBMS multiple data
elements can be accessed at the same time.

- In RDBMS an identical field in one table can be used to pull data from another table
R: True

- SQL stands for:
R: Structured Query Language

- Which year SEQUEL was first invented by IBM?
R: 1970

- Which of the following is NOT a relational database
R: MongoDB

- Oracle DB is an open source RDMBS
R: False

- What is the difference between SQL and MySQL?
R: SQL is a standard language for retrieving and manipulating structured databases.
On the contrary, MySQL is a relational database management system. AND SQL is used
to query and manage RDBMS.

- MariaDB is named after
R: Monty's younger daughter, Maria.

- Which of the following is NOT MS SQL version?
R: 2015

- Which of the following is Development edition of MS SQL?
R: Basically, ALL FEATUREs, but its intended purpose should be testing environments.

== Download, Install and Configure Windows

=== Welcome to Download, Install and Configure Windows

=== MS SQL Server Pre-Requisite

- Admin rights on a computer
- Hard Disk = 6 GB minimum (20 GB for the course)
- All editions of Microsoft SQL (except Express) require 1 GB of memory. Express
- 512MB, and 4 GB for Windows. We will have a Windows machine, with Microsoft
SQL installed.
- Only x64 processors are needed. 1.4 GHz, Recommended 2.0 GHz.
- OS = Windows Server 2016, or the newer 2019. Whichever is available.

=== Lab Setup

. With limited resources = You could just have your computer with OS and install
the Microsoft SQL RDBMS. If your computer is really slow, you can still use the
Express version, but many of the features of the course that will be covered won't
be accessible to you.
. The recommended approach is to **Virtualize**. We will use a virtual machine,
so that we will have a virtual machine installed with Windows Server. And we will
install Microsoft SQL Server Enterprise Edition there.

=== What is virtualization?

In the real world, in the world of infrastructures (servers), the bread and butter
is actually **virtualization**. But before, you usually just installed a OS, an app
on top of it and you were done.

This has a problem though:

- A physical server has some specs (e.g., 16 GB RAM, 4 CPU)
	- You install a OS (takes 4 GB of RAM)
		- You install services (like MSSQL)
			- And then this only takes half of all the capability of the server.
			It became a waste of resources. **Hence** virtualization came to try
			and optimize, to use that computing power and still get more value of
			it.

The infrastructure then changes:

- A physical server
	- You install a virtualization layer
		- You install tons of different OS and each one has applications running
		on it (how many will depend on the specs of the server and the requirements
		of the different virtual machines you will install)

What's the advantage? You can actually **use all the resources**. The beauty of
virtualization is also the fact that you can _three or four SOs at the same time_,
it's really important and beneficial for the world of computers (servers and infrastructures).

The main point is: **It uses all the resources of the server/machine**

=== Download and install VMWare Workstation Player

This is a virtualization layer that sits on top of your OS. (I will not, because
I'm on linux and QEMU kicks VMware's Butt)

We need the right resources:

- At least more than 4 GB of RAM (On Windows 10).
- HDD should at least have 50 GB.

[NOTE]
====
Did VMWare sell its soul or something? There's a whole website you have to go to
and register just to get an installer. Jesus.
====

=== Optional - Download and Install Oracle Virtualbox

Another virtualization software such as VMWare Player, made by **Oracle**.

=== Create a Virtual Machine

Remember:

- Computer
	- Virtualization Software (VMWare Player)
		- Virtual Machine (Container that has resources added to it). 20 - 50 GB
		of space, 4 GB RAM, 1 - 2 CPU

In VMWare Workstation you need to set the connection to Bridge, but on QEMU, things
are differently, NAT is actually what allows to connect the HOST to the VM and viceversa
on top of allowing the VM to get access to the internet.

How, we will install:
- `Windows Server 2019 Datacenter Evaluation (Desktop Experience)`
- Custom
- Allocate all the HDD
- Next
- Set a Password (Has to be somewhat complex otherwise it won't let you go past this
screen)

And yeah to unlock it is with `Ctrl + Alt + Supr`.

- Accept the default network with `Ok`
- You can disable the Server Managment to pop-up always on startup.
- On VMWare you will have to install the VMWare tools (for better experience)

- **Change the name of the machine to `LABMSSQL`**.
- Change the timezone to your timezone
- You will get a splash screen reminding you about for how long you have the
evaluation copy (and it's 180 days - 6 months). If you don't finish the course
in that amount of time and come back, you will have to install Windows Server
AGAIN.

=== Fix EFI Network Time out error for VM Player

Basically, some people get this error when trying to run the same workflow that
is shown in the Desktop.

- Head down to the physical path at which the VM is being saved.
- In that folder look for the Virtual Machine Configuration File
- Open the file and change the `firmware` key to `bios`
- The next boot should now work

=== Download and Install Windows Server (2019)

Remember:

- OS
	- Virtualization Layer (VMWare, VirtualBox, QEMU)

This is redundant (for experienced people I'd assume). It's basically the same
series of steps that we took for 2016 though. Only difference is looking up specifically
for this version instead of 16 in Google and the Microsoft Website.

=== Virtual Machine Management

How can we manage our Virtual Machine that's on the Virtualization Software?

This is obviously catered towards `VMWare Station`, but I guess the ideas that are
brought forward are things that I can totally extrapolate for any other virtualization
manager.

- You should be able to dynamically change the memory for a machine (RAM)
- You should be able to dynamically also change the disk space (expand HDD capacity)
- You should be able to add other extra interfaces (network adapter, disk reader, printer)

The idea is that VMs are way more dynamic, we can change so many things about them
on the fly, without going through the whole hassle of what an actual physical machine
would require. Hence this technology and the paradigm with which we work is so
powerful and useful.

**Note:** Most of the time you should keep your host and VM's time `synced`.

=== Quiz 2: Download, Install and Configure Windows

1. What is a hypervisor?
R: Software managing virtual machines

2. Which of the following is an example of a hypervisor?
R: Microsoft Hyper-V

3. What is a virtual machine (VM)?
R: A software emulation of a physical computer

4. Which feature allows you to capture the state of a virtual machine at a particular point in time?
R: Snapshotting

5. How does virtualization contribute to high availability in SQL Server environments?
R: By allowing quick movement of virtual machines between servers

6. What does a hypervisor manage in a virtualized environment?
R: Virtual machines

7. Which of the following is NOT a benefit of virtualization in Microsoft SQL Server environments?
R: Limited scalability

8. What does dynamic resource scaling in virtualization allow you to do?
R: Adjust allocated resources based on workload demands

== Download, Install and configure MS SQL Server

=== Welcome to Download, Install and Configure Microsoft SQL

By now we should have VM with Windows Server running. And our choice of RDBMS is
Microsoft SQL Server, so we will install it on top of this VM.

We will install

- Microsoft SQL Server
- Microsoft SQL Server Management Studio
- Configure MSSQL
- Use AdventureWorks Database

=== Which Version of SQL Server to Install?

There are many versions that have been released already:

- SQL Server 2022
- SQL Server 2019
- SQL Server 2017
- SQL Server 2016 - Mainstream support ended in July 13, 2021, but extended support
is until July 14, 2026.
- SQL Server 2014

**Mainstream Support:** There can be _paid support_ through a program and extra charges,
but this type of support basically is active, and current features can be improved and
extended, so you get more interesting things to work with. (On top of security updates)

**Extended Support:** We won't get new features or extensions to current ones, but
you will still see security updates so you have this extended time to still be safe.

So which version should you choose? It's not an easy answer.

[IMPORTANT]
====
It really depends on your business needs. Most of the time the oldest versions are
being used (because we tend to not migrate or stay up to date for very different
reasons). So it's not as black-and-white as to say _Always go for the latest version_.
Pick from the latest version one version lower, since that's where probably most
of the demand is. Besides it definitely has more time to become more stable than
the brand new version.
====

The course was made during versions 2016 and 2019. But later 2022 was dropped.

- 2019 is also widely being used now.

But just pick one version, and stick to it. That's the best advice.

=== Prerequisites for MSSQL 2016 Installation

These are good requirements for Lab and for Production environments. But of course,
for production we should have at least 6 GB of RAM (recommended), on top of (_of course_)
Microsoft's own format (NTFS, ReFS).

- Express Editions: 512 MB RAM, All other editions: 1 GB RAM
	- But recommended: 1 GB RAM, 4 GB RAM respectively
- Intel or AMD processors are okay
- And don't worry about network, that comes built-in and it's already working

**NOTE:** You need .NET Framework 4.6 for the Database Engine, Master Data Service,
or Replication.

_Considerations:_

- MSSQL 16 only works on **x64** machines
- MSSQL 16 can be installed on Windows Server 2012, 2016, 2019
- You cannot run SQL Server services on a domain controller under a local service
account
	- In English, this means that (I guess by default?), SQL Server won't run on
	the same server that has all credential and login info. (This is the Domain
	Controller, the most **sensitive and secure server**, it's literally the keys
	to the kingdom)
	- And a local service account, is the most generic type of account that can
	be registered (and used) under a Domain Controller. SQL Server cannot run
	with such an account, it needs an account specifically created and catered
	towards using the SQL Server service.
- Separate disks for Data Files, Log Files, and tempdb (This is Microsoft's
recommendations)

=== Prerequisites for MSSQL 2022 Installation

The newest MSSQL version.

So, in short. **_It requires the same things that all previous versions required_**.

_Good_.

[NOTE]
====
Okay, **ONE THING** that is different, and of course it turns like this. Is that
you can only run this in Windows 10 TH1 1507 or greater. And if this is running in
Windows Server it has to be **2016 or greater**
====

=== Download and install Chrome Browser

Okay, this isn't really one lesson on how to click some links and install. It actually
teaches you how to stop Internet Explorer of being annoying for a second.

_I'm not saying this is good, for Prod environments, definitely, being annoying is
way better than being completely laxed_.

But to stop pop-ups every 2 seconds saying that a site is not trusted:

. Open Internet Explorer
. Search for the **cog**
. Select `Internet options`
. Go to `Security`
. Select the `Trusted sites` icon
. And lower the lever of "Security level for this zone" to `Medium Low`

And when you still get the pop-ups, just check anything that says "Don't show again"
or "Continue", basically, ignore all the warnings (because we are power users and
we know what we are doing).

Even now though, you can still try and look for Chrome or Mozilla, try to download
and it won't work either. You have to go to the same screen we were before but:

. `Internet Options`
. Security
. Custom level
. Search for "Downloads"
. Mark "Enabled" instead of "Disabled"

After this, you can google whatever browser you want, and download it.

Because we are cool, we chose _Firefox_. But in a perfect world, we would go
for _Librewolf_.

It is with this new browser we should search and download "AdventureWorks Sample
Database" this is on the Microsoft Docs, it's probably a pretty widely used database
sample hence it is in Microsoft Docs even.

Download the OTLP => 2019 version. (bak file). Depending on what OS you decided to
install and what MSSQL Server you will install then you should match the specific
backup. (For the uninitiated, a `.bak` file is a typical extension for a database
backup in the MSSQL world)

[NOTE]
====
When running specifically Windows Server on QEMU, resolution might seem a bit off,
luckily by playing with the resolution settings at the VM level we can get a better
view that might suit your needs. Play around with it.
====

=== Download MSSQL and SQL Server Management Studio

Search in google "Download Microsoft SQL Server 2019". Get to the first official,
link, try to download the `.exe`, and you will have to fill in a form (literally
walled by data harvesting). After filling it in with totally real information,
you can then actually download the `.exe`.

- Open the .exe
- Select `Media File`
	- This will download the ISO for the server (and all the files that are necessary).
	And it will take some time, probably around 10 minutes or so. So just wait.
- Close
- Search for SSMS 19
- Download the installer

[NOTE]
====
If you are turning off your VM. Do clean shut downs, do not suspend or use the
Hypvervisor's controls.
====

=== Install and Configure MSSQL 2016

So a production environment might look something like this:

- Most Powerful Machines had MSSQL Server
- 96+ CPU
- 256+ GB RAM
- Solid State Drives
- Terabytes of Storage Attached
- Data files, Log Files, tempdb and backups or separate disk drives

Now, we do not have such a thing. We have a fairly small machine, with small
capacity. Still we will try to emulate a bit of how production might work by
working with different folders and labeling them as you would for different data
files, log files, etc.

**FIRST**

Let's create some folders in the C: drive.

- SQL_LOG_FILES
- SQL_DATA_FILES
- SQL_TEMPDB
- SQL_BACKUPS

This is but a naming convention the instrudctor has been following for years.
Bear in mind this is entirely theoretical, yet, you can extrapolate that into
other environments, teams, conventions. But having a sense of **ORDER**, I think
is the biggest thing you should keep in mind. There are many use cases, many requirements,
many things that actually dictate how you will structure a database, how you will
setup many devices, servers, services. But in the end, you need to have a logic
to your own madness, if you don't. Things are not going to be pretty, if things
have _too much of a lean structure_, then productivity tanks, (and many other
factors play into this, it's not just "having order or nomenclature"). But I know
from first-hand experience that followin your basics, having organization, can
be useful (_when done properly, and when not over-preparing nor over-engineering
getting in your way_).

And now we will open up the setup for the copy of MSSQL 201x we downloaded.

This opens up a wizard that's kinda craaazy, in the sense that there are tons of
options. Again, it's a toolbox, and (only someone who's insane) would know every
single thing. It's something you have to understand just about enough to navigate,
and when the moment comes, you can dive into a topic or tool and make it work
for your need. That's more realistic, pragmatic, and actually professional than
pretending that sole memorization of things without a sense of applying that
"knowledge" practically is somehow "better" or "good".

- You can also read in the MS Docs, tons of links in the "Planning" page, but a
really useful tool there is the `System Configuration Checker`. By clicking this
it will run tons of checks to tell us if the current machine can have SQL Server
installed without issues. There are tons of things to check, yet this tool automates
the checks. It's a **good practice** to always start this tool. If something is
wrong we have to go and **FIX IT**.
- Once all of that is done we simply click on the second tab "Installation" -
New SQL Server stand-alone installation or add features on an existing installation
	- You can go through the installation wizard pretty easily, yet there are some
	interesting points to highlight: You are asked for a license, in prod you would
	need to buy one and input it here. For a course, the evaluation copy should
	be more than enough.
		- This tool also runs the checks we ran before
		- We should check the option to "always check for updates"
- After continuing another set of `checks` will run. These checks are actually
focused around you solving them in order to continue, the one thing that usually pops
up here is "Firewall is on". We (for the purpose of this course) turn it off,
once that's off we have to re-run the checks, the firewall should not be an issue.
- Next screen asks for what features would you want to install. We will only be
focusing on three:
	- Database Engine Services
	- SQL Server Replication
	- Client Tools Connectivity
A cool fact about the wizard and each option you select is that there's tons of
information, like it tells you what are the pre-requisites for services, you should
install things that might be missing. It also will tell you how much everything will
take in store. These three options we selected are about 1 GB in storage.
- We will come across another screen that talks about "Default Instance" and
"Named Instance". Basically, this is a specific configuration that for specific
use case scenarios might be useful.
	- E.g., You want to have multiple sets of SQL Server installed on a machine,
	because you want a specific set to be encrypted whilst another not (this is
	but one example). And so, when you install more than one SQL Server, you will
	need to point to the `Default Instance` and the other instances will become
	named instances. There can only be **one default**. We will only work with one
	instance so we will keep it as "Default Instance". Another thing is that
	you can choose a name for your instance. However a good practice is to keep
	it as `MSSQLSERVER`.
- The next screen introduces the concept of "Service Account", and how MSSQL
adheres to best practices from the get-go. So there are these options:
	- SQL Server Agent
	- SQL Server Database Engine
	- SQL Server Browser
All these services have different roles to play when it comes to allowing MSSQL
Server to work as intended. **And**, we actually will create per-service a service
account, this is the "user" that communicates the Windows (the OS) with the Service
itself. _By default the Local System Account is used_. This is a highly privileged
service account that has access to everything. (He's admin basically). In prod
you would have to install the `Domain Controller`, and we then create Domain Accounts,
and each one with a specific access to the specific service.
	- Set all the services to be `Automatic` so that when we boot-up they also
	boot-up
	- And in Collation > Keep the default. But in short, this setting tells SQL
	Server how to share, compare and sort data based on characters.
- After that, we will setup the Configuration itself.
	- SQL Server has **two types of authentication**
		- Windows Authentication = Default one, and referred as "Integrated Security".
		This security mode is _of course_, integrated and tightly coupled to Windows.
		So specific users and groups are trusted to log into SQL Server. A Windows
		user does not need additional credentials to authenticate with MSSQL Server.
		So you don't actually need to input a password and stuffs, since if you
		have logged in, your user is used to manage SQL Server.
		- Mixed Mode = SQL Authentication plus Windows Authentication. So SQL
		Authentication is a mode that basically saves credentials **within**
		the MSSQL Server. _In Windows, we save them under the **Domain Controller**_.
			- We will actually use this. In here you can set a password, which will
			be the password for the `sa` the Server Administrator. This _of course_
			has to be **really strong**. And there's a handy button there to also
			add the current user as the administrator, that way you can login
			and have to add credentials (which is more secure).
	- After we save the credentials we can head into `Data Directories`. In here
	it allows us to map folders for different purposes to System Directories. We
	previously created 4 folders in the `C:` drive, each one will be mapped to these
	locations that MSSQL Server by default configures
		- Data root directory > C:\SQL_DATA_FILES
		- User database directory > C:\SQL_DATA_FILES
		- User database log directory > C:\SQL_LOG_FILES
		- Backup directory > C:\SQL_BACKUPS
	- TempDB = We will later explain what this is, but for now, just be sure to
	remove the default path that was there and add a new map to `C:\SQL_TEMPDB`
		- Also set the `Initial Size` (on the two locations that are there) to
		**128 MB**. This part of SQL Server is really important, it helps with
		performance basically, so you should try to make it _as big as possible_.
		It will also depend on the number of files. Depending on the cores the
		PC has, then the default number of files filled in varies `1:1`. Before
		you used to have to create all these files manually, but since that version
		the installation itself picks-up the number of CPUs and generates the respective
		number of files.
	- FILESTREAM = Nowadays, data is not just "date of birth", "name". Stuff like
	that. Data now has pictures, songs, movies attached to it. Other types of
	file formats. And so, to store them, we don't use the DB, we actually keep
	them in disk, and then we create a reference on the Database. Why? SQL Server
	doesn't allow you to create a BLOB record that's bigger than 2 GB. And that,
	of course, nowadays is _child's play_.
		- And so, for these use cases/file types. We enable the FILESTREAM setting.

Once that's done, we get a summary of all the config we established, and it will
also save an `.ini` file in disk (this is really well made dude). Once we hit
`Install` (after 10 - 15 minutes), many steps will take place.

==== SQL Server Best Practices

We will go in depth later, but it's best to understand that SQL Server has tons
of config, and depending on the environment we might have to setup things with
performance and other considerations in mind (nature of workflow, OLTP database,
BI SQL Server). Once we install the SQL Server, we tune the server after based on
such requirements. "Fascinating stuff".

After the installation is done, we actually get logs, we see everything that the
installer did, and it's AMAZING. _If there was an error in the installation_, the
logs should be a good source of truth to debug and fix.

After that also, we should search in the Search Bar of Windows "SQL Server". In there
we should be able to the `SQL Server 2008 and SQL Server 2016". 2008 should be empty,
but 2016 will have an option called **Configuration**. In there under `SQL Server
Services`, you should be able to see `SQL Server` and that `running`.

To stop, restart, the best is to come to this place and right click the services to restart.
If you manually shutdown the machine or something, data might be corrupted, and bad
things could happen. Using this interface and options will **ASSURE** that you
do a graceful shutdown of the service.

[IMPORTANT]
====
Oh wow, so now I get why the course took the time to make different videos for each
installation. In here there are less options that in `2019` for example. I was trying
to just install 2019, but now I see the difference.
====

It's nice, this is like, really nice. But, come on, a bit redundant, still it's good
to know this, and learn from my "mistake". Can keep in my head "If I want details,
I can come back to these videos for further "examination"

Okay, so since I won't lab all versions, I will take notes of the other versions that
I will "not" be installing. 

=== Install and Configure MSSQL 2019

[NOTE]
====
Props to the course. So they themselves understand that this could be dead time,
dead weight, so they went out their way to mix it up, it's not just the previous
tutorial plus some extra steps. They are adding also extra content. Wow.
====

_Short presentation:_

Before any installations, before anything that has to do with the tools. We need
to understand that a fundamental level, Databases are the key sources of data
for our business, and this in turn makes them extremely important. These are
the backbone of a business.

This is where:

- Transactions get saved
- Inventory gets saved
- Sales are getting served

Everything that is related to the business relies on the business data, regardless
of Front Office work, or back office work. Internal systems such as HR, Payroll.
They all share this same idea at their code. Data is **King**.

Because of this degree of importance, we also have to understand that the most
powerful machines in the company should be dedicated to the databases (servers).

That extra background, adds into the overview of how a production environment might
look like:

- Most Powerful Machines had MSSQL Server
- 96+ CPU
- 256+ GB RAM
- Solid State Drives
- Terabytes of Storage Attached
- Data files, Log Files, tempdb and backups or separate disk drives
- Most Powerful Machines had MSSQL Server
- 96+ CPU
- 256+ GB RAM
- Solid State Drives
- Terabytes of Storage Attached
- Data files, Log Files, tempdb and backups or separate disk drives

Again, because data and databases are so important, we also should really look
after the idea of preparing, configuring these machines and systems in such a
way that they are reliable, resilient. And recover from errors or disasters.

And now we will follow analog instructions to what we had in the `2016` section.
Download Chrome or a modern browser that doesn't have as many restrictions as the
per-default Internet Explorer (which is also a really old browser). It takes too
much time to work with Internet Explorer, doesn't really help, hence we install
another browser as the first step.

- Download SQL Server 2019. (From the official MS site)
	- Microsoft offers cloud integrations that you could pick, but in order to
	install MSSQL server we should pick the "On Premises download" option.
- The installation wizard is not just some run-of-the-mill installation program.
It has tons of tools and options that help maintain, research further and overall
support in the installation of MSSQL.
- 1443 is the default SQL Server connection. The correct _production ready_ approach
is to manually allow this port. **NOT DISABLE THE FIREWALL**. But for the sake of
the course, we will just do that. But for **security purposes** it's best to
always follow the idea of: `least privilege is best`. Also a _small note_ here,
the firewall being turned on is treated as a **warning**.
- Most important things to install
	- Database Engine Server
	- SQL Server Replication
	- Client Tools Connectivity
+
Yet, depending on your requirements, there are tons of other features and tools
we can choose to pick.
- As you continue with each step, the wizard is always keeping track of the machine
and configurations, if anything might be a problem, it **will let you know**.
- Expanding on the idea of the named instances and default instances, if you were
to configure a named instance you would have to connect to it by combining two
things: `MSSQLSERVER-test`, the anatomy is: `<InstanceId>-<Name>`.
	- We will cover how this feature is used further when we go around **replication**.
- Another reminder of the service accounts, and how a good practice is to separate
per each feature a different service account, and by pairing this with a domain
server we should provide both a user and password for them. For the purposes of
our lab though, we will use the `NT Account` which is local, and all services should
be configured to have an **Automatic** startup.
- When setting up authentication, something to keep in mind is that if you configure
your instance as `Windows Authentication Mode`, you effectively lock yourself out
of creating SQL Server users and connecting to the instance.
	- Hence, mixed mode is the best of both worlds. And in this mode you need to
	create from the get-go a SA or admin account. (Also don't forget to add the
	current user as admin)
- In `production` we will have different drives for different concerns of **data**.
	- MDF and LDF files are the ones to store data and logs respectively, in an
	ideal world, **these types of files should be on different drives**.
	- In order to mimick the separate drives, we will be using different folders
	for the different data locations (separated by concern/type)
- TempDB is really important, but its details will be explained later.
	- It's a good practice to always keep more than 1 file for TempDB, and the initial
	file size and different parameters will highly depend on the business requirements,
	(this is different to the information told at the previous section). In production
	environments files will be around 3 - 4 GB in size, and other parameters as
	well will be really buffy, we will be working with MB numbers:
		- Initial size (MB): 64
		- Autogrowth (MB): 64
		- TempDB log file
			- Initial size (MB): 8
- MaxDOP: When we run SQL Server on a computer that has **more than one core**,
it detects the best degree of parallelism. Number of processors employed to run a
single statement, for each parallel plan execution.
	- When we execute a query, we have the option of running it through multiple
	cores, so that said query also runs faster. Multiple CPUs work together in this
	instance to process the query and make it way more performant. This all depends
	on how many Logical CPUs you have on the server. (_Production numbers go from 32
	CPUs to way higher)
- Memory: This setting showed up on 2019. This is a configuration that entirely
allows you to set how much memory you want for SQL Server to allocate from the
server.
	- **IMPORTANT:** SQL Server uses a lot of memory. _Why?_ Because this DBMS
	_by design_ tries to pass data from disk onto memory, in order to access the
	data quickly. _Quick Select, Quick Update_. So the more memory you allocate
	it the better, however resources and finite, and we have to balance the memory
	used by the OS and SQL Server. A good rule is 80 - 20. 80% of memory to
	SQL Server and 20% to Windows should be a good ratio.
		- And another **good practice** is to state the server with SQL Server,
		should **only be running SQL Server**, don't try to host a web server
		or other stuff like that.
+
We will select: `Recommended` and allocate Max Server Memory (MB) to `512`. And
also be sure to tick the check mark.
- FILESTREAM = The options here basically are extra configurations that you can
add to write things to disk, allowing users to access FILESTREAM and things alike.
We will check everything.
- Again, a summary is displayed by the end with all the things you set for the
server, alongside the path of all the config in **text form**.
	- Hit `Install` and just wait, dude. Depending on the computing power of the
	machine this can take up to 30 minutes.
	- By the end, you will see a summary of all features that were installed
	(and whether their installation was successful or not), alongside a path
	to a **log file**. In case there was an issue, you should go into this log
	file and read the contents to understand better how to fix the problem.

To check if you truly have the service installed, you should open up the Start
Window and search for `Microsoft SQL`, you should get a folder with tons of
executables, but the most important one being **Configuration Manager**, this is
a program that DBAs use a lot actually, to restart, start and just manage the
service's lifecylce. And _as already mentioned before_, this is the recommended
approach when trying to interfere with the server's status. This tool makes sure
SQL Server shuts down gracefully and avoids issues by pulling the plug and corrupting
things.

By double-clicking on the respective service, you will get a Window to manage
differen aspects of it. You can choose to switch the path for logs, or features
to be turned on/off. There are tons of things that you can do here, and we will
definitely go into detail in further sections. (You can even find the path to the
log file here)

You can even go into: `SQL Native Client 11.0 Configuration > TCP/IP > Port` to
change the default port in which the service is running. (_If you do end up changing
it, you will have to restart though_)

=== Install and Configure MSSQL 2022

[IMPORTANT]
====
When we talk about SQL Server in Production environments, we refer to the most
powerful machines. They are serving trafick/data from customers and transactions
of applications. SQL Server runs on the most powerful machines in our infrastructure.
====

Of course, for our lab purposes, we won't replicate the same specs as production
machines, our VM will have the installation and usage of MSSQL Server as the
reason it has been setup, so the machine is low on specs, but just good enough for
**our purposes**.

[NOTE]
====
So, on 2022 there's a new option to choose `Developer` edition. This is the
"perpetual" version that we can use "forever". Well as long as not for production
environments. Evaluation is `90 days`.
====

It also comes with Terms and Conditions > **Accept Them**.

[IMPORTANT]
====
In production environments **WE DO NOT UPDATE THINGS WILLY-NILLY** so automatic
updates should never be set by default. The right procedure is to first update
in lower environments, test, and if everything looks fine, then production can
be upgraded knowing that we won't break it.
====

- Checks on top of checks are across the whole installation wizard. (And this is
a great idea you should be inspired by, or at the very least appreciate).
	- That's how the Firewall check pops-up.
		- **IMPORTANT:** But now this video tells a different story when it comes
		to the Firewall issue. It's more pragmatic, in a way. _It all depends on
		the business requirements_. Based on your particular use case, team,
		setup, you will probably configure the firewall differently, but a given
		is that in **production**, just having _no firewall_ is **BAD**.

(Oh wow, there's Machine Learning as a feature for MSSQL Server, _wow_).

- By default the service is installed in `C:\Program Files\Microsoft SQL Server`

Do you want to give your SQL Server the same name as the instance? Actually the
name of the instance adheres to the **name of the machine**. So if your machine is
called "TestMachine" the instance name would have that name by default. However,
if you can change the name, you should always do that.

_We tend to keep it to the default name_. The only use case in which we make use
of named instances is when we want to install more than one SQL Server instance
on **one server**. (_The SQL Server services can work independently in this setup_).

MSSQL Server => Runs as a service on a Windows Machine. And like any service,
an account has to be associated with it. Through said account is that the service
gets to actually run. _Said account needs privileges_.

We usually work (_in production_) with Service Accounts. This is with a whole
Domain setup ready. In our lab we don't have that, and won't set it up, so we
won't use Service Accounts. We will just use **the local account**.

The idea is to separate each different "service" into a different "service account".

When the SQL Server goes down, if you stop it, or if the hardware goes down and
we have to stop the machine. When the bring the server back online, do we want
SQL Server to automatically start? Then you should set that up in the configurations.

If you want it manually, then set it up as **Manual**. By default SQL Server Agent
is set to `Manual`. You can always change that to _Automatic_ though.

- MIXED MODE

[NOTE]
====
The reason as to why a good practice is to not put all the drives for the different
types of files and data inside the same Server Drive is because if that goes down,
it becomes a `one point of failure`. It's then **always** recommended to put each
data directory in different drives, so that the chances of losing the data are
less likely.
====

_It's only for our lab purposes, that we have a small machine and with limited
resources that we will emulate this separation of concerns by creating **diferent
files**_.

- On `TempDB` be sure that the Log and TempDB files are both pointing to the
`TempDB` folder.
	- Okay, params here are completely different to the other SQL Server versions.

- No 80-20 rule here for memory :(

- I don't think the other versions asked for a restart? 2022 seems to require it.

**Don't forget:** There's a log by the end. You should use the log to debug if
there was something wrong. (And please, use these things as inspiration for the
software you yourself build, imitate, take ideas that are cool, that way you will
build cool things)

[IMPORTANT]
====
Okay, I'm an idiot and forgot the password to access the machine. Luckily there's a
good way of resetting it. You just need to plug in the installing ISO for Windows
Server. And then choose to "Repair" the computer. After that you should choose
"Troubleshoot". In there a console pops-up, input this: `net user Administrator Str0ngPassWorD@`.
This is how you set a password again. And yeah, this is the password now. **DON'T
FORGET IT AGAIN**

A bit more than that though: https://www.youtube.com/watch?v=m4BBSa8uS5E[Tutorial]

Really cool way of "hacking your way" the command is actually

`net user administrator Passw0rd` => Have it just like that. JUST EASY.`
====

=== Install 2016 SQL Server Management Studio

We already downloaded SMMS, and installed it (don't remember doing that? HEH).
Apparently it takes longer to install this than the actual MSSQL Server database.

[NOTE]
====
There are tons of other database access tools. But the first-party developed one,
and of course with more features (at least up to date) will be the one that Microsoft
themselves develops. (But I want to give a quick shoutout to `DBeaver` this is insane
once you set it up correctly. You can even get DDL scripts and diagrams all reverse
engineered from Microsoft SQL Server)
====

Once the program opens up we will be greeted with a window to connect to MSSQL Server.
Now, if you choose to use `Windows Authentication`. you will see how the password
field is actually completely grayed out. And the reason being, we are already logged
in, already authenticated, so by just switching to this option. Our user will be
used to authenticate with MSSQL Server and get access to the instance.

However if we we choose `SQL Server Authenticate` we can also use the `sa` account.
And yes, it is **TONY**.

_Note:_ Oh yeah, the installation is just (Next > Next > Next).

Once you open up SMMS and then log into the instance. You get access to all the
system databases that are there by default. You also get access to the `Security`
folder, which actually shows all the different accounts to log into the instance
(Under `Logins`). And in there at the bottom, you should be able to see `sa`.
If you open its properties, you can then access `Server Roles`, and at the bottom
you should see the account with a check on `sysadmin`. This should enable the account
to literally do WHATEVER you want with the instance.

=== Install 2018 SQL Server Management Studio

_How do we communicate with SQL Server? Microsoft has its own GUI to talk to it,
and it's Microsoft SQL Server Management Studio. It used to be part of the SQL
Server installation until the 2012 version. But since then, you have to separately
download it and install it.

When accessing the official page to download SMMS, you get access to download
different management studios, all different versions, be sure that you use the
recommended versions (not previews) and ones that match the version of Microsoft
SQL Server.

[NOTE]
====
OHHH, dude, this also installs `Azure Data Studio`. This is a lightweight and
a bit cooler GUI to connect to servers. (Not just MSSQL Server).
====

The setup of this version will require to also restart the computer.

**BIG NOTE:** Oh, so like, when you are the wizard to connect, you can choose
to connect to different services, not just a "Database" **ONE** of the services
is the _Database Engine_, and yeah that is the most used one and the one that
deal with the data portion of the whole suite. But just know, that we have tons
of other features and Engines.

- If we have multiple instances, (named instance use case) we can also choose in
the connect wizard which of the instances we want to connect to. (This is used
for replication)

(_Azure Active Directory_ will be skipped for now, but that's another type of
authentication)

_Note:_ You can actually "log in twice", with the `sa` account and with the
`windows` account. And it will show you on each connection, with which account
you have logged in.

SMMS is the place that we will use to connect to MSSQL Server, it has all types of
information and ways to leverage the database features.

**There are two types of databases:**

- System Databases = Installed automatically with the setup we did when installing
Microsoft SQL Server
	- master = main database
	- model =
	- msdb = setup jobs and ssi packages
	- tempdb = the temporal database
These are all system databases, and we should back them up just as we backup user
data databases.
- User Databases = These are databases that deal with actual user data, and we
create all of them manually

Using GUI you can create databases pretty easily, literal right-click, go through
wizards. _Typical Microsoft pattern_.

- Security Tab = In here you can see all the users (logins), you can see all the
roles that we can configure for users on a database
- Server Objects = In here we can specify linked servers, triggers, etc.
- Replication = If we want to replicate data from one server to another server
- High Availability
- Management = In here you can see tons of options, but one **really important**
option here are the SQL Server logs. If there are any sort of issues with the
database, you can go into the logs here and start troubleshooting what the heck
is up fam.
	- Maintenance Plan = These are for backup management
	- SQL Server Agent = Service which comes pre-installed, the Agent is in charge
	of scheduling the jobs. Jobs that we are going to run on different schedules.
		- Backup every 2 am (for example).
		- We can create scheduled jobs (e.g., Okay at 2 am every day, run this
		script, automations are built-into SQL Server). Nothing by default, we
		setup everything here.
		- We can setup alerts
		- Proxies

=== Install 2019 SQL Server Management Studio

Repeated info. But extra:

You can just right click on a database and then choose `Run Query`, after you
do that you can run a pretty generic command: `SELECT @@VERSION`, this command
will show you immediately what's the version of the MSSQL Server instance.

The interface tells you a lot of info:

- What databases you have
- What tables a database has
- Logins allowed to connect to a database
- Server Objects

We will be looking into all these features and details further in the course.

=== Download and Install AdventureWorks Database

This is a sample database used for learning purposes and to test different
features that Microsoft SQL Server provides.

You can Google it like: `AdventureWorks sample database`, and under a Microsoft
Docs page, you should be able to see a table with tons of download links. Depending
on your database version you should download the respective backup. (Also be sure
to download the **OLTP** version).

- Once you download that, move the `bak` to the backups folder on our machine.
- Log into the SMMS application. (It would be recommended to login with Windows
Authentication though, it has more auditing around it.)
- And now to restore the backup:
	- Right click under `Databases`
	- Restore Backup
	- Select `File`
	- Search for the backup that should be under the `BACKUPS` folder
	- Once you select it, the folders for both `DATA` and `LOGS` should be automatically
	mapped to the ones we set at the installation step
	- Click `Restore`
	- Once the restore is complete, you can look at the architecture of the database
- This test database has `Tables`, `Views`, `Stored Procedures`, `Security`

Let's run our first `SELECT`.

- New Query
- Be sure you double-clicked the database and chose `New Query`, or in any case:
	- `use AdventureWorks2019`
	- go

[NOTE]
====
On SMMS you don't have to write semi-colons as you would in MySQL, Oracle. You
can just put `go` at the next line.
====

Okay, this is _cool_, didn't know you could do that with SQL Server. You can literally
Drag and Drop a table into the `Query Window` and it will immediately write/render
that table's name (a full access to it). So you can literally write queries with
motions. That's _cool_.

So the first query we will run is

`SELECT * FROM [HumanResources].[Employee]`

And this should render a all the records from the table at the bottom. You can
play around and do selects to all other tables to get a feel for it too!

=== Download and Install AdventureWorks 2022 Database

So with each new Microsoft SQL Server, Microsoft creates a new backup that has
differences in its architecture. So depending on your version you will see
a different structure.

_NOTE:_ Okay this is... interesting. But basically, for the most advanced features,
we will leverage 2022 and its AdventureWorks sample. (Why is that? No idea, still
hopefully we still get the chance to lab all those lessons, unless I want to run
another install for 2022).

- The backups that are provided for AdventureWorks are actual backups of AdventureWorks
that are free and used for learning and labbing.
- `Device` is the option with which you can point to the path at which a backup
is saved.
- When restoring a backup for a Database that doesn't exist. Then SMMS will take
care of both creating the database itself, and then putting all the values that
are respective.

[IMPORTANT]
====
There's a button on the `Restore` screen stating `Script`. This will actually
generate SQL that takes care of the restore of a backup. You can run the command
or just press buttons with the GUI. (Two alternatives)
====

Of course, _make sure the data is there_. Run a couple of `SELECT` statements and
stuffs.

== Database Fundamentals and Design

=== Welcome to Database Fundamentals and Design

Let's recap a bit:

- Section 1: Data, Databases and Relational Data Base Management System
- Section 2: VM, Windows Server Installation and managing Lab VM
- Section 3: Download, Install and Configure MSSQL Server

_What will we cover?_

- What is Data?
- What is Database?
- How Data is Stored?
- What is Table, COLUMN and ROW?
- What is a Key?
- What is a Primary Key, Foreign Key, Unique Key, etc?
- What is a Transaction and ACID properties?
- Database normalization AND different forms of Database Normalization
- Create your first Database, Table and Populate table with data...

=== What is Data?

When we use the term _database_, we inevitably make the connection to the word
_data_.

**Data** is a _collection_ of facts, numbers, words, measurements, observations
or descriptions. However this data starts as **raw**, something that might not
have that much meaning outside of context or _pre-processing_, once we process that
data, we can turn it into **information**, which is actually data with meaning
and with the potential to give us insight into conclussions that can be drawn.

In the context of databases, _data_ is referenced as any single item that can
be stored in our _database_, this can be a single item or a set.

=== What is Database?

_Base:_ Data-base => A structure that holds data.

=> Organized collection of structured information or data, typically stored
electronically in a computer system.

We typically also have a DBMS (Database Management System) that helps us interact
and manage said database. There's also _systems_ that are interconnected to the
database that provide different functionalities around **data**. All of this group
of system and subsystems, are still referenced as a Database, or Database system.

Example:

When going to the Dentist for an appointment, and a recepcionist looks up your
name, more than likely this is on a file written somewhere, in said document there's
tons of info in regards to you. Name, Last Name, Drugs prescribred, age, gender.

All of this info can be extrapolated and put in a database, the data, the underlying
information will be the same, but the value, the important piece of abstracted
knowledge, can change its form and become electronic, and be represented in
`Tables` and `Columns`. Each column can be of a certain type, and can house
a specific piece of data that brings together a greater whole, and we can have
more than one table leveraged in order to represent all of the data that the
traditional _real-world_ process employs.

Many traditional file systems, move into Databases or tend to do so. And it doesn't
matter how many tables or columns are employed to represent the original process,
as a whole, everything is referred as a database (_system_)

_Why not just a Spreadsheet?_

- This all depends on convenience and how all data is stored.
- Who can access the data.
- How much data can be stored.

Spreadsheet is used is great for a small group of people, that also don't have
to do a whole lot of complex data manipulation.

Databases => Designed to hold a much greater amount of data, and in organized
amounts. (Terabytes of data). Databases => Allow multiple users to connect to
them, and run queries that also can become highly complex yet with an almost
human readable high level query language.

=== How Data is Stored?

_This is not referring to saving data to HDD in binary_.

This is how data is stored within the database.

. Data is stored within tables (the basic unit of storage)
. Structured Query Language (SQL). In order to query data in a structured manner,
we need to save said data in a structured way. (We normalize the data through tables)
. **Tables are not databases**. See the database as a folder, and there are files
inside of a folder, the tables are these **files**, all data is written into them.

=== What is a Table, COLUMN and ROW?

A database is made of many components, one of those is **Tables**. Without them,
we wouldn't have much actually, tables are the essential structure in which data
is stored.

- There can be more than one table
- The data is stored in these tables, tables are like _placeholders_
- A table should have a **unique name**
- The number of tables is limited by the number of objects allowed in the RDBMS.
For example Microsoft SQL Server has a limit of more than 2 billion tables (which
is kinda impossible to reach)
- MySQL has no limit

**What is a Column?**

A set of data values, all of a single type, in a table. E.g., Age, name, Department,
salary.

- Each column tells you what type of data is going to be saved in that column
	- The name should imply what type of data is going to be saved
- A column may contain all sorts of data types, text values, numbers, or even pointers
to files in the system
	- You can put dates, even currency specific types, decimals, precision
	- **IMPORTANT:** The column names should be unique
- SQL Server => You technically have 1024 columns. It's not practical to have as many
though, 30 - 40 columns are extreme cases. This is where normalization comes into
picture.
- There should be _at least one column in a table_
- Field = Column.
	- However, some developers might refer to a Field as the intersection of a
	Row and a Column.

**What is a Row?**

Collection of fields that make-up a record.

E.g., We have a row that tells data such as `EmployeeNo, Name, Age, Department,
Salary`.

- A row is also called a _record_
- A row should be unique (when all of its values are combined)
- A table can contain 0 or more rows. When there are no records, the table is
referred to as _an empty table_
- The number of rows is only limited by the storage capacity of the machine (unlike
Excel as an example)

=== What is a Key?

Tables store a lot of data in them, most of the time these records are unsorted
and unorganized. If you want to filter data, you can try and make usage of some
column's value, but if those values are repeated, you immediately will run into
an issue such as records that you don't want popping up as results.

To avoid all these issues, **Keys** are the solution, this is a way of making a
record truly unique, and reference it by that unique **value**.

- A key is a data item that exclusively identifies a record.
- E.g., You have a table of students, and there are more than one "John" students,
you can pinpoint to the one you really care about by using his `StudentId`
- Key can be a single attribute of a group of attribute (composite key)
- Keys are also used to generate relationships amongst different tables, tables
most of the time are connected to each other and that is through the keys, for
that purpose you use a _foreign key_.

[IMPORTANT]
====
A key is an important component of a table. And it's used to exclusively identify
a record whenever we are trying to query for it.
====

=== What is a Primary Key, Foreign Key, Unique Key, etc?

First, let's run a quick exercise. In a table with no concept of keys introduced
yet, what column would be a good key?

**Candidate Key:** An attribute or set of attributes that uniquely identifies a
record. (Many columns cannot be used alone to try and uniquely identify a record,
hence those wouldn't be good candidate keys)

In a table such as:

[cols="1,1,1,1"]
|===
|StudentId | Name | Class | DOB | Email

|1001, John, 1st Year, 01-08-2008, john1@gmail.com

|1002, Roger, 2nd Year, 01-08-2013, roger@gmail.com

|1003, Michael, 3rd Year, 02-02-1993, michael@gmail.com

|1004, John, 3rd Year, 02-03-1992, john@gmail.com
|===

Candidate keys, could be `StudentId` and `Email`. But nothing more than that,
_why?_ Because they are unique amongst records. Any other value can be clash
easily, (you can already see two johns there, and there could be people with the
same birthday, and perhaps same name and same birthday)

- Tables can have multiple candidate keys
- Amongst the set of candidate keys, **one** is chosen as a **Primary Key**.

_NOTE:_ When naming tables, DBAs tend to name tables with **Camel Case**. E.g.,
`studentInfo`. This is but a convention, and in real world, you will definitely
see all manners of conventions. But it's good to know that there is a sense
of "convention" and people tend to follow that.

- Primary is a set of one or more fields (columns) of a table that uniquely
identify a record (row) in a database table.
- A table can only have **one primary key**, and you should pick one _candidate
key_ as that.
- A primary key should be picked only if its value is rarely or never changed
- A `primary key` cannot be `NULL`
- Primary key fields contain a clustered index

**Secondary Key** => All candidate keys that were **not selected as primary keys**,
you could use them as ways of identifying a record, but again, _in practice they
are not the primary key_. Sometimes they are referred as **alternate key**.

**Uniqe Key:** Set of one or more attributes that can be used to uniquely identify
the records in a table. They share the same attributes as **primary keys**, however
these columns can have `NULL` values. A unique field containst a _non clustered
index_.

**Composite Key:** A combination of one or more attributes can make up a "primary
key". A composite key can be a candidate for a `primary key`. E.g., StudentId +
Email can become a composite key.

**Foreign Key:** A field in a table that is a **primary key** in another table.

E.g.,

.studentTable
[cols="1,1,1"]
|===
|StudentID, Name, Class

|1001, Diego, 3rd Class

|1002, Richard, 1st Class
|===

.invoiceTable
[cols="1,1,1"]
|===
|StudentID, InvoiceID, Cost

|1001, 1, 3000

|1002, 2, 3500
|===

As you can see, we have _two tables_ and on the second one, we have the `StudentID`
as a column. This is actually a reference that ties the record in the `invoiceTable`
to a student record in the `studentTable`.

- A foreing key is used to generate a relationship between two or more tables.
	- The way to trace back all the way to another table is to pick the foreign
	key column value and search it in the respective table
- A foreign key can be duplicated, and it can have `null`

[IMPORTANT]
====
The concept of keys plays a very important role when designing databases. They can be
of much help when running queries, and good design on them can make life easier
when managing a database.
====

=== What is a Relational Database and Relational Database Management System (RDBMS)?

Relational Database = Type of database, based on the _relational model of data_.

The idea is to store and provide access to data points that are related between
each other. To ensure the data is always accurate and accessible, relational
databases follow certain integrity rules.

Logical data structures => Means that we abstract things, and are separated from
the actual physical hardware. The relational data model was designed to resolve
multiple data structures that in old times were used arbitarily by engineers.
These structures were verbose, complex, and hard to maintaint. So the idea of
the relational model with its **Table** structure was a way more intuitive, simple,
and extendable approach to data storage.

_Relational databases_ => They have **Relations** as the key concept between them.
Keys are the columns that manage to connect/relate different records from different
tables.

A relational database management system (RDBMS) is a software that allows you to
manage a RDBS. Most RDBMS use the SQL Language to access the database. Meaning that
regardless of what RDBMS you are using, the language should be pretty similar,
meaning your knowledge can be transferred over pretty easily.

**Advantages:**

- Enhanced data security (authorization, access control can support encryption that
is strong). You can even configure what data is accessible to who. So for businesses
that require control of the data and its access, Relational is good
- Retain Data Consistency => Because of the ACID properties, data can be assured to
be in a consistent form
- Better Flexibility and Scalability => Updating can be done independently, that
is because modifications can only be made once, you change one place (one table)
and that value will then ripple across all other data access points
- Easy Maintenance => You can regulate, fix and backup data pretty easily. And
that is because there are automation tools that do all of this easily

=== What is a Transaction and ACID properties?

Transaction => In day to day to live, we often here "Transaction" in DBMS, this
is a single logical unit of work which accesses and possibly modifies the content
of a database. A transaction accesses the data with **write** and **read** operations.

A transaction groups SQL statements so that **ALL** of them are comitted, or **ALL**
of them are rolled back (means they are undone).

_When do you rollback transactions?_ When there is a **failure**.

ACID => Concept, or acronym to the 4 properties of a transaction in a database
system.

Atomicity
Consistency
Isolation 
Durability

If you follow these four properties data can remain consistent and accurate on
a database, the data should be become corrupt in case of some failure. And
lastly, because of ACID, we can focus on the application logic instead of
failures, recovery and sync of data. (_So the idea is to abstract more, and let
developers do more of other value adding tasks_).

==== Atomicity

This means, that a transaction needs to be an atomic unit of work. Meaning, either
**all of the operations are executed** or **NONE**. So if one part of the query
fails, then everything else will immediately fail, in case you encounter an error,
none of the changes will be commited.

==== Consistency

The database must remain in a consistent state after **any transaction**. So
a transaction needs to ensure that it adheres to **integrity constraints**. That
way the data should remain _consistent_. The data has to remain "correct". When
trying to add/modify a value to a column, depending on its constraints.

So if a column can't be negative, this constraint should be enforced, and fail
a transaction if trying to do such a thing.

==== Isolation

The transaction will be carried out, as if it was **the only transaction** in
the system. Meaning that one transaction should not be changed, influenced or
changed by another concurrent transaction (but this is bs, innit? Deadlocks, stuff that clashes
does happen, specially in _production_).

_So in a perfect world, a transaction should wait for another transaction to act
on a record before trying to manipulate any of its data_. In order to avoid
inconsistency, databases put locks on records, that way one transaction has a
sort of **reserved spot** until its done with its operations.

=== Durability

Once a transaction is comitted and applied, then its changes are kept **permanently**
in the database. Hence databases should make use of Hard Disks, that way if the
power goes out, then when coming back online, the data should still be there,
the transaction's changes should remain, be _durable_.

[IMPORTANT]
====
ACID is just a theoretical way of looking at it. It's a great start, concept and
core values to have. But in practicity you run into all sorts of scenarios and
weird things that do prove the rules that they are not so _black-and-white_. You
have to make concessions, and sometimes just accept that guidelines or rules
inevitably end up broken due to specific business requirements or scenarios,
or perhaps there are other issues at hand, and you should be prepared to deal
with those issues.
====

=== Database Normalization AND different forms of Database Normalization

_Why do we need normalization?_

To avoid redundancy on data, (having a table with records that save the same
data for different columns). We are not really optimizing the usage of storage
space, we **waste disk space**. Maintenance also becomes harder, say you want to
update the details of a customer, with a bad structure, you would end up having to
go to all sorts of places and iterate across tons of records to change each one
in order to keep data consistent. That's **BAD**, you should always aim to have
_one place_ that can get updated, and then all of that info remain consistent to
any of its relations.

==== Normalization

Process that organizes the data in the database in order to reduce data redundancy
and increase the data integrity.

- It's a systematic approach of decomposing tables to eliminate data redundancy
(repetition) and undesirable characteristics like Insertion, Update and Deletion
Anomalities
- This is a multi-step process that puts data into tabular form, and aims at
removing all manner of redundant data from relation tables.
- This works with a series of _Normal forms_.
- Although other levels of normalization are possible (1NF, 2NF, 3NF), the third
level is the highest level considered to be necessary for almost all applications,
_so if you go above that, then you are just trying to show off_.

**1NF**

- A relation is in this normal form, only if **it contains atomic values**. Means
it has a value that cannot be divided. Also, if there are no _repeating groups_.

So, in order to normalize with 1NF, look out for rows that have repeated values
in its columns, and after that, inside each value, check whether you are saving
_more than one value_ in a column, that is bad, you should probably put each value
in a separate column or perhaps making another table to keep tabs on these multiple
values that could be qualified as a specific field.

**2NF**

- If it's in 1NF, and **all partial keys dependencies are removed**. When an
attribute depends only on a _part_ of a primary key, and not the whole key, we are
**bad**. In _English_. If you have a record that does indeed reference a key,
but also info about this key is getting repated with each record, then that means
that this is a **partial key dependency**. You should separate such a case
in **2 different tables**. That way you only keep references to keys, and on
each separate table said kays can have all the attributes they want.

**3NF**

- If it's in 2NF, Non-Primary Keys columns shouldn't depend on the other non-
Primary key columns.
- No transitive functional dependency

Okay, in _English_. Basically your columns, should not depend between each other.
E.g., A `courseCode` column, depends on the value of a `majorCode`. Firstly,
**you can't make either of these fields a primary key**, cuz changing one of
its dependencies can immediately break the records way of being referenced by
other records. And even if you don't have a direct dependency between two columns,
if there's a **third** column thrown into the mix, and it has a dependency,
the _third column_ indirectly will also become dependant on the dependences of its
own _first-class dependency_. To avoid all of this **non-sense**, you should separate
the table columns into different tables, and basically just assign their own
primary keys, that can then be later referenced on the other table.

_In short:_ Always, look out for maintainability, look for problems that might
arise with the design decision you make, (normalization is done at the design
stage anyways). Normalization should help a lot with a good design. After you
identify a problem for a **ETC** EASIER TO CHANGE later situation, then split
things into smaller tables, try to reference keys always, avoid dependencies
between columns, and avoid data redundancy. **That's the essence, the key to
normalization**.

=== Create your first Database, Table and Populate table with data

Okay, let's actually get our hands dirty. Just boot up the VM. Don't forget the
Passw0rd DUDE :D.

_Note:_ It's better to use the Windows Authentication to log into the SQL Server
instance.

_Note 2:_ Also don't forget about update management, you should update, test that
in lower environments, and once everything seems in order **THEN** update prod.

We will now create our database from the group up, you can do it with a script or
with the GUI. (Which apparently it's easier, _yeah no_). Anyway, once you right
click Databases and select "Create Database", in the wizard you will pick a name
and later you will choose an **Owner**. A good practice is to either leave the owner
as `Default` or add `sa`. Don't put a single user for it (in practice this is just
not true, what if we want granular control with service accounts?)

When configuring the DATA database and the LOG database, you have several parameters
you can fine tune depending on the use case. But the initial file size for `DATA`
for example, we will set as `64 MB`. **Autogrowth**, is a setting that we can fine
tune depending if we are on PROD or DEV, you can even limit the size of the database,
this is also dont on lower environments, and mostly when the need arises that wants
for you to re-use a server for multiple other applications so other databases and
you are organizing how much will **this** database actually take in disk. In PROD
however we should keep it as `unlimited`. With this setting, the moment we reach
the maximum, any insert will start throwing an error. We will set its limit to 1
GB due to our VM having limited resources.

There's also the option to change the `Path`. However, we already set the default
path and that gets applied, (still you have the choice of changing to another
_path_).

- We also get to configure the LOG database, which will be covered in detail later,
but it's basically really useful when restoring a database after a failure or
outage.
	- We will also limit the LOG to half a GB

- If we head down to `Options` now, we will get a plethora of things to configure,
these will be covered later, but just for now let's explain extra things:
	- Recovery Mode: Full or Simple allows you to go back in time and restore the
	database at **one** point in time. E.g., A banking database, a failure is
	detected, a user registered a value that was invalid in a table. We can go
	back to a minute before that catastrophe (Only in Full Recovery Mode) which
	in turn also keeps a lot of LOGS. In our case, our database will be simple,
	so we use the **SIMPLE** option
	- We can just press "OK" and then the wizard will make sure of running all
	queries under the hood to get the database up and running with all the configurations
	we set out.
		- But an extremely powerful tool is the "SQL Script" button, if you press
		this and select the "In new Query Window" option, then you will be put in
		a SQL Query Window with all the scripts that will be run in order to create
		the database and its configurations.

There's a whole structure to the SQL Query and many parts to it. You can run all
the queries with `Ctrl + E`. Now, a basic way to use the SQL Query Window is select
everything, select nothing and run with `Ctrl + E` or just press the `Execute`
button. _The best practice is select what you want to be run and run it_.

From the different options you can make out the recovery mode, the autogrowth,
all of that. At first, if you don't see a database, then **refresh**.

We will now create a table with the GUI. `Right Click on Tables > New Table`.

The columns we will create are:

- firstName, varchar(50), nullable
- lastName, varchar(50), nullable
- dob, datetime, nullable
- ID, int, not nullable

If you choose to close the window now, it will ask you if you want to run this
creation, alongside the table name, we will put it as `personalInfo`

After refreshing, you should be able to see the table, also its columns, a note
here, the order of columns in the GUI is not really important. We can create a
script for existing tables also, SCRIPT Table as => CREATE. This will then show
you all the SQL that was run in order to create the table, it's pretty handy and
you should always look at this, in production and real life, GUI is way less practical,
and deployments and configurations done through an Infrastructure/Server team will
always rely on scripts, TEXT files is just a powerful way of transmitting files,
versioning, and overall acquiring information while reading.

Oh, right, on the wizard you don't get an option to set a primary key, HUH. So
after we create our table, we actually don't have a PK yet. Yo can make edits
to an existing table by `Right Click > Design`. You can then select the box
to the left of a column and "Set as Key". Once you try to close the window
it will ask you to run stuff.

Once you run, you can again try to generate a `CREATE` SQL script. You will see
how it should have a new statement that's all about making the ID column the
**primary key**. Now, if you wanna autogenerate an `INSERT` you can use the
`Right Click > Script Table as > Insert To`. This will generate a template you
can use for inserting data, for our purpose we will just write our info there to
insert, if the query has any syntax error the window will let us know, and stop
us from trying to run a malformed query, until we fix the syntax then we are
protected against that possible mistake.

**Notice that this is only syntax, if a value is wrong or whatever that falls on us
to double check**. Once you run the insert you should see `1 row(s) affected`.

Now if you wanna see the data of the table, `Right Click > Select Top 1000 rows`.
Or you can write `SELECT * FROM personalInfo`. Either approach works fine.

[NOTE]
====
In SQL Server we tend to separate statements with `GO` not with semicolon. Although
it's supported and you should be fine.
====

You can also edit values with `Right Click > Edit Top 200 Rows`. With this you will
get a GUI to edit values in wizard. After all your changes, if you use the **keyboard**
with `TAB` then the changes to the rows are automatically applied. But _please
don't use this approach_. It's there, but it's best to use INSERT or UPDATE statements.
The GUI is **too error prone**.

=== Quiz 3: Database Fundamentals and Design

What is the primary purpose of a database? 

- To store and organize data

Which term is used to describe a collection of organized data? 

- Database

In a relational database, what is a column often referred to as?

- Field

What is the smallest unit of data in a database table?

- Field

Which of the following is an example of a non-relational database model?

- MongoDB

In a relational database, what does a row represent?

- A record

Which SQL keyword is used to retrieve specific data from a database?

- SELECT

What does RDBMS stand for?

- Relational Database Management System

What is the purpose of the "WHERE" clause in a SQL query?

- To filter the rows based on a condition

Which term is used to describe a unique identifier for a row in a table?

- Key

== Introduction to SQL Commands

=== Welcome to Basic SQL Commands

This section will be about the basics of SQL Commands. We will learn about
a SQL statement, types of SQL statements (how they get used and examples, we will
run labwork to see how they perform as well)

=== What is a SQL Statement and types of SQL statements

[IMPORTANT]
====
Forgot where I placed this note, so I'll keep writing it as long as I need. If you
restart your PC, you need to start two services to use QEMU on Linux:

- `sudo systemctl start libvirtd`
- `sudo virsh net-start default`
====

SQL = Structured Query Language. Used to communicate with a database. It's this
language that we use to communicate with the database. _Actually_ according to
ANSI (American National Standards Institute), it is the standard language for
**relational database management systems**.

We use SQL statements to perform operations on data, such as update on a database,
retrieval from database. Also create users, grant permissions to users and all sorts
of stuff like that.

**Most common RDBMS**, like MariaDB, MySQL, Oracle, all use SQL. However, they
also have **extensions** to the base language. Queries, keywords, or functions that
are only specific to **that** RDBMS.

However these statements are the ones that we can be sure exist in _most_ if not
_all_ database relational systems. And we can do almost everything we will need
with them:

- Select
- Insert
- Create
- Update
- Delete
- Drop

These are the basic commands, **_universal_**. There might be a difference in
syntax, but the purpose and functionality should still fall within the usual
standards.

Some examples:

[source, sql]
----
USE AdventureWorks;
SELECT * FROM Sales.SalesOrderHeader
WHERE [OrderDate] BETWEEN '1/1/2021' AND '4/31/2021'

USE AdventureWorks;
UPDATE Sales.SalesOrderHeader SET OrderDate = getdate()
WHERE [OrderDate] = '1/1/2021'

USE AdventureWorks; <.>
DROP TABLE Sales.SalesOrderHeader
----
<.> We rarely do these kind of statements and in this structure, at least in
production/real-life scenarios. But, still, it's good to know a bit about the
different things that are possible within all of this.

All these statements perform different operations, but if you try and read them
like normal english, you should be able to make a pretty good educated guess
as to what the statement is doing.

We actually saw different type of SQL statements. There's a classification:

- DML (Data Manipulation Language) = SELECT, INSERT, UPDATE, CREATE
- DDL (Data Definition Language) = CREATE TABLE, CREATE DATABASE, ALTER TABLE
- DCL (Data Control Language) = GRANT ACCESS
- TCL (Transaction Control Language) = These are statements that help with ROLLBACK
and SCOPING

=== DML Statements with examples

Data Manipulation Language = As its name implies, it's a subset of the SQL universe
focused on manipulating data. Actually most of the most common statements are under
this category, SELECT, INSERT, UPDATE, DELETE, etc.

_We use these statements, to insert, delete, update, create records in a database_.

**SELECT statements**

A statement used to get records from a table, _with or without conditions_

- SELECT * FROM student - Gets all records of a student table
- SELECT * FROM student WHERE rank > 5 - Gets all records with the condition where
student's rank is greater than 5

**INSERT statements**

Used to insert a set of values into a database table. INSERT statement is used
with `VALUES` as a pair of sorts.

- E.g., `INSERT INTO Student(Rank, StudentName, Mark) VALUES (1, 'Abbas', 450)`

With this statement, a record will be inserted into the Student table, and looking
at the structure, we provide all the columns we want to insert a record into,
followed by the actual values that are mapped **respectively**.

**UPDATE statements**

Used to update an existing value on a table, _based on a condition or not_. Usually
we make updates with `some kind of condition`.

- E.g., `UPDATE student SET StudentName = 'Abbas' WHERE StudentName = 'Imran'`

[IMPORTANT]
====
In the previous statement, if we didn't specificy a condition, then as a result we
will be updating the whole table on that specific column to a specific target value.
In real world scenarios, this could be catastrophic, hence **always keep in mind**
if your update has the correct condition set for it.
====

**DELETE statements**

Used to delete an existing record in a table. This is usually based on a condition,
and it follows the same idea as UPDATE actually, _if you don't want the statement
to delete everything within a table, please **add a condition**_.

- E.g., `DELETE FROM Student WHERE StudentName = 'Abbas'`

This will delete the complete row that satisfies the condition. (If there are many
records all of them will be deleted, **keep that in mind**)

=== DDL Statements with examples

Data Definition Language, this type of language deals with database schemas and
descriptions. They basically help declare **how** data should reside in a database.

- `CREATE, ALTER, DROP, TRUNCATE`

**CREATE statements**

Used to create a new table, database, user in the database. This can be used to
create other objects like stored procedures, functions, and others...

This helps defines objects and create them in a database.

- E.g., `CREATE TABLE Student (Rank Int, StudentName varchar(50), Mark Float)`

_Personal comment:_ Okay this is pretty succint and clean, didn't know you can
group them together like that for a CREATE TABLE_

So yeah, you can declare the name of a table, and then all the columns alongside
their type.

**ALTER statements**

This is used to _change_ an existing object. These can add a column, modify, drop,
rename, rename an index, change the name of a database. Its scope is actually
**really big**. It can be used to modify most if not all of the database objects
that are out there in SQL Server.

You use this to **modify an already existing object**.

- E.g., `ALTER TABLE Student ADD (StudentAddress varchar(100))`

Pictures this use case: We have an already running system and it has a Student
table, with records that are of course precious to us. We can't just drop the
table and lose all of that for a modification that we want to make (adding a new
column). `ALTER` comes in pretty handy to yes, mutate the table's structure with
a new column, but keeping the records in it.

**DROP statements**

Used to drop objects in a SQL Server. Remove a table definition. _NOTE: Don't
forget that when you drop a table definition all of its data also is deleted (dropped)_

You can drop index, trigger, constraints, permission specifications for a table.

**NOTE:** These statements are generally regarded as kinda dangerous, so really
think twice and how you are using them to manipulate a database structure.

- E.g., `DROP TABLE Student`, `DROP DATABASE AdventureWorks`.

**TRUNCATE statements**

Removes all rows from a table, without logging the individual row deletions.

_Remember how we talked about `DELETE`?_ Well `TRUNCATE` is similar, but the
**key** difference is that DELETE statements are logged in the database. Technically,
because there's a log, we can actually roll-back that execution if something happened.

But a `TRUNCATE` won't register any logs. Once we run this statement, **there's no
way to recover DATA**. _We could also save time since the logging overhead is not
there_.

[IMPORTANT]
====
In real life world scenarios, DBAs tend to use `TRUNCATE` when the performance of
the deletion is time-sensitive/critical, to the point that we can't afford all the
logging overhead of a `DELETE`.
====

_Another difference:_ `DELETE` has the abilities to select a row we filter (condition)
so that specific rows are affected, however `TRUNCATE` is pretty simple. (You simply
delete everything at once)

- E.g., `TRUNCATE Student`

=== DCL Statements with examples

**Data Control Language**

- It defines the control over the data in the database, e.g., `GRANT, REVOKE`,
wich are used to grant access or revoke access from a user.

**GRANT Statements**

GRANT is used to grant SQL `SELECT, UPDATE, INSERT, DELETE`, and other privileges
on tables and views.

- e.g., `GRANT UPDATE ON ORDER_BACKLOG TO JONES WITH GRANT OPTION`. This statement
for example, **yes** it does allow `JONES` to do updates on `ORDER_BACKLOG`, **and**
it also lets him `GRANT` this same permission to others. (So you see that this is
extremely granular, or well, can be).

- `GRANT SELECT ON TABLE Q.STAFF TO PUBLIC`. This statement acts upon a **Group**
actually. Any person that is part of that group, can now do `SELECT`s on the
`Q.STAFF` table, but no one can gran that same permission to others.

**REVOKE Statements**

This is used to cancel previously granted or denied permissions.

- E.g., `REVOKE DELETE ON employees FROM anderson`. Here, we take away the permission
to `DELETE` from `anderson` on the `employees` table.
- E.g., `REVOKE ALL ON employees FROM anderson`. Here we take away **all possible
permissions on the `employees` table from `anderson`.

=== TCL Statements with examples

**Transaction's Control Language**

- Used to manage the transactions in the database
- Used to manage the changes made by DML statements
- It also allows all statements to be grouped together into logical transactions,
meaning that tons of statements can be executed as _one transaction_.

**COMMIT Statements**

- This command is used to permanently save any transaction in the database
- When we use COMMIT in any query, then the changes made by that query will be
permanent and visible
- e.g.,
+
````
BEGIN tran d
UPDATE emp SET empName='D' WHERE empid = 11
commit tran d
````
The way to understand this SQL statement is pretty simple, you create in memory
a transaction object with an alias (variable name), and then wrap as many DML
statements as you want, when SQL Server runs all the query, everthing that executes
inside of a transaction is only **in-memory**, it isn't yet "official", the moment
we hit a `COMMIT` that's when all those changes that were memory-only are then sent
to be written to disk.

**ROLLBACK Statements**

- Used to undo the changes made by any command, but only before any commit is done.
Meaning, the moment info is written to Disk, we **CANNOT** roll that back. That's
out of this statement's capabilities.
- If a `COMMIT` has already run, we cannot roll it back

This is a bit verbose, but a good example of how you would leverage a ROLLBACK:

[source, sql]
----
DECLARE @BookCount int <.>
BEGIN TRANSACTION AddBook <.>
INSERT INTO Books VALUES (20, 'Book15', 'Cat5', 2000)
SELECT @BookCount = COUNT(*) FROM Books WHERE name = 'Book15'
IF @BookCount > 1 <.>
BEGIN
ROLLBACK TRANSACTION AddBook <.>
PRINT'A book with the same name already exists'
END
ELSE
BEGIN
COMMIT TRANSACTION AddBook <.>
PRINT'Now book added successfully'
END
----
<.> Not explained in the course, but this is akin to programming, we can declare
variables in an SQL statement, this declares an `int` variable named @BookCount
<.> And here we start logic by marking it under a transaction named `AddBook`
<.> We then run some insert and check after the insert if we get **two rows with the
same name**, meaning there actually already existed another record with that same
name (for that same book)
<.> In case yes, we already had that book in the database, we rollback the named
transaction, and also print a nice message.
<.> In case no, we inserted the first record for that book, then we commit the
transaction cementing it to be written to desk, on top of writing a nice message

So yeah, I can definitely see the use cases here, it's weird that we don't use
these more often though, good leveraging of transactions can save you a lot of
headaches to be fair.

**SAVEPOINT statements**

- `SAVEPOINT` is used to temporarily save a transaction so that you can roll back
to that point whenever neccesary
	- So, you can choose to scope statements with a transaction, commit them,
	but after a certain point, due to requirements or something else, you are
	not sure of how things will pan out after, hence you choose to mark this
	as a `SAVEPOINT` and based on the result of the next group of statements you
	can either go back to the beginning (where the `SAVEPOINT` started) or continue
	executing forward.
- Savepoint names must be distinct within a given transaction.
- After a savepoint has been created, you can either continue processing, commit
your work, roll back the entire transaction, or roll back the savepoint.
	- So, kinda cool, and I guess savepoints are created always inside `TRANSACTION`
	I guess? then they become like a second layer of restoration points depending
	on the use case and logic.
+
Another verbose example, but good to illustrate what these statements do:
+
[source, sql]
----
UPDATE employees SET salary = 7000 WHERE last_name = 'Banda'
SAVENPOINT banda_sal <.>
UPDATE employees SET salary = 12000 WHERE last_name = 'Greene'
SAVEPOINT greene_sal
SELECT SUM(salary) FROM employees
ROLLBACK TO SAVEPOINT banda_sal <.>
UPDATE employees SET salary = 11000 WHERE last_name = 'Greene' <.>
COMMIT <.>
----
<.> Okay, so a good "formula" so that you don't forget. Is to literally after
some statements ran, you go and do a `SAVEPOINT <name>` you are literally placing
a save file at this point in time for the database's **STATE**
<.> Perhaps after some operations, you realize that numbers don't add up, or you
just made a mistake, so you can invoke the "loading" of the save file with `ROLLBACK
TO SAVEPOINT <name>`. This essentially _rollsback_ all state changes done after
said `SAVEPOINT`. And with that idea in mind you can now run new logic that adheres
to something that's _"correct"_.
<.> As you can see this UPDATE would then differ from the one that was done before
but was rolled back due to it being out of the scope of the specific `SAVEPOINT`
<.> Lastly, you can commit all the changes made up until that point.

This `SAVEPOINT` concept definitely feels nieche, never heard or saw it ever being
used to be honest. But then again, maybe I just wasn't exposed to environments
that leveraged the concepts in interesting or clever ways.

=== Quiz 4: Introduction to SQL Commands

Which of the following is not a type of SQL statement?

- SELECT
- INSERT
- MODIFY [X]
- DELETE

What is the purpose of the SQL statement "INSERT"?

- To insert new records into a table

Which SQL statement is used to modify data in a database?

- UPDATE

What does the SQL statement "SELECT * FROM employees;" do?

- Selects all columns from the "employees" table

What is the purpose of the SQL statement "ALTER TABLE"?

- To modify the structure of an already existing table

Which SQL statement is used to retrieve unique values from a column?

- SELECT DISTINCT [X]
- SELECT UNIQUE
- SELECT UNIQUEVALUES
- SELECT DIFFERENT

What does DDL stand for in SQL?

- DATA DEFINITION LANGUAGE

Which of the following SQL statements is considered a DDL statement?

- SELECT
- INSERT
- CREATE TABLE [X]
- ALTER

Which DDL statement is used to remove a table from the database?

- DROP TABLE [X]
- DELETE TABLE
- REMOVE TABLE
- ERASE TABLE

What is the purpose of the SQL statement "GRANT" in DCL?

- To give privileges to users

What does TCL stand for in SQL?

- Transaction Control Language

Which of the following SQL statements is considered a TCL statement?

- SELECT
- INSERT
- COMMIT [X]
- UPDATE

Which TCL statement is used to roll back a transaction in SQL? 

- ROLLBACK [X]
- UNDO
- CANCEL
- REVERT

What is the function of the SQL statement "SAVEPOINT" in TCL?

- To mark a point in a transaction to which you can later roll back to

What does DML stand for in SQL?

- Data Manipulation Language

What is the purpose of the SQL DELETE statement?

- To remove records from a table

Which of the following statements is part of Data Control Language (DCL)?

- GRANT

Which SQL statement is used to revoke previously granted permissions?

- REVOKE

In SQL, what does the DENY statement do in terms of permissions?

- Revokes permissions from a user or role

What is the purpose of Data Control Language (DCL) in SQL?

- To control access and permissions

== Query and Manipulation of Data using SQL

=== Welcome to Query and Manipulation of Data using SQL commands

=== CREATE TABLE(s) and Temp Table(s)

=== What is a View?
